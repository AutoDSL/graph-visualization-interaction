{"id":"node_modules/@antv/layout/lib/layout/er/forceGrid.js","dependencies":[{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\er\\forceGrid.js.map","includedInParent":true,"mtime":1676178923628},{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\src\\layout\\er\\forceGrid.ts","includedInParent":true,"mtime":1676178923883},{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\package.json","includedInParent":true,"mtime":1676178924413},{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\package.json","includedInParent":true,"mtime":1676178923486},{"name":"./grid","loc":{"line":6,"column":37,"index":253},"parent":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\er\\forceGrid.js","resolved":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\er\\grid.js"}],"generated":{"js":"\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar grid_1 = __importDefault(require(\"./grid\"));\nfunction layout(data, options) {\n    if (!data.nodes || data.nodes.length === 0)\n        return data;\n    var width = options.width;\n    var height = options.height;\n    var nodeMinGap = options.nodeMinGap;\n    // 2. 网格布局\n    var CELL_W = 10000;\n    var CELL_H = 10000;\n    data.nodes.forEach(function (node) {\n        var nodeWidth = node.size[0] || 50;\n        var nodeHeight = node.size[1] || 50;\n        CELL_W = Math.min(nodeWidth, CELL_W);\n        CELL_H = Math.min(nodeHeight, CELL_H);\n    });\n    var grid = new grid_1.default();\n    grid.init(width, height, {\n        CELL_H: CELL_H,\n        CELL_W: CELL_W,\n    });\n    data.nodes.forEach(function (d) {\n        var gridpoint = grid.occupyNearest(d);\n        if (gridpoint) {\n            gridpoint.node = {\n                id: d.id,\n                size: d.size,\n            };\n            d.x = gridpoint.x;\n            d.y = gridpoint.y;\n            d.dx = gridpoint.dx;\n            d.dy = gridpoint.dy;\n        }\n    });\n    // 加入节点size\n    for (var i = 0; i < data.nodes.length; i++) {\n        //  节点宽度大于网格宽度，则往当前网格的右边插入列\n        var node = data.nodes[i];\n        var result = grid.findGridByNodeId(node.id);\n        if (!result)\n            throw new Error(\"can not find node cell\");\n        var column = result.column, row = result.row;\n        if ((node.size[0] + nodeMinGap) > CELL_W) {\n            var addGridSize = Math.ceil((node.size[0] + nodeMinGap) / CELL_W) - 1;\n            var realAdd = addGridSize;\n            // 优化，假设同一列，不同行存在两个size为2的节点，遍历到第一个节点的时候，会往右插入两列，遍历到第二个节点，又往右插入。就会导致多余的网格\n            for (var j = 0; j < addGridSize; j++) {\n                var hasColumn = grid.additionColumn.indexOf(column + j + 1) > -1;\n                if (hasColumn && !grid.cells[column + j + 1][row].node) {\n                    realAdd--;\n                }\n                else {\n                    break;\n                }\n            }\n            grid.insertColumn(column, realAdd);\n        }\n        // 节点高度大于网格宽度，则往当前网格的下边插入行\n        if ((node.size[1] + nodeMinGap) > CELL_H) {\n            var addGridSize = Math.ceil((node.size[1] + nodeMinGap) / CELL_H) - 1;\n            var realAdd = addGridSize;\n            for (var j = 0; j < addGridSize; j++) {\n                var hasColumn = grid.additionRow.indexOf(row + j + 1) > -1;\n                if (hasColumn && !grid.cells[column][row + j + 1].node) {\n                    realAdd--;\n                }\n                else {\n                    break;\n                }\n            }\n            grid.insertRow(row, realAdd);\n        }\n    }\n    // 同步节点坐标\n    for (var i = 0; i < grid.columnNum; i++) {\n        var _loop_1 = function (j) {\n            var cell = grid.cells[i][j];\n            if (cell.node) {\n                var node = data.nodes.find(function (node) { var _a; return node.id === ((_a = cell === null || cell === void 0 ? void 0 : cell.node) === null || _a === void 0 ? void 0 : _a.id); });\n                if (node) {\n                    node.x = cell.x + node.size[0] / 2;\n                    node.y = cell.y + node.size[1] / 2;\n                }\n            }\n        };\n        for (var j = 0; j < grid.rowNum; j++) {\n            _loop_1(j);\n        }\n    }\n}\nexports.default = layout;\n"},"sourceMaps":{"js":{"version":3,"file":"forceGrid.js","sourceRoot":"","sources":["../../../src/layout/er/forceGrid.ts"],"names":[],"mappings":"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","sourcesContent":["import Grid from './grid';\nimport { INode, IEdgeInfo } from './type';\n\nexport default function layout(data: {\n  nodes: INode[],\n  edges: IEdgeInfo[],\n}, options: any) {\n  if (!data.nodes || data.nodes.length === 0) return data;\n  const width = options.width;\n  const height = options.height;\n  const nodeMinGap = options.nodeMinGap;\n\n  // 2. 网格布局\n  let CELL_W = 10000;\n  let CELL_H = 10000;\n  data.nodes.forEach((node) => {\n    const nodeWidth = node.size[0] || 50;\n    const nodeHeight = node.size[1] || 50;\n\n    CELL_W = Math.min(nodeWidth, CELL_W);\n    CELL_H = Math.min(nodeHeight, CELL_H);\n  });\n\n  const grid = new Grid();\n  grid.init(width, height, {\n    CELL_H,\n    CELL_W,\n  });\n\n  data.nodes.forEach((d) => {\n    const gridpoint = grid.occupyNearest(d);\n    if (gridpoint) {         \n        gridpoint.node = {\n          id: d.id,\n          size: d.size,\n        };\n        d.x = gridpoint.x;\n        d.y = gridpoint.y;\n        d.dx = gridpoint.dx;\n        d.dy = gridpoint.dy;\n      }\n  });\n\n  // 加入节点size\n  for (let i = 0; i < data.nodes.length; i++) {\n    //  节点宽度大于网格宽度，则往当前网格的右边插入列\n    const node = data.nodes[i];\n    const result = grid.findGridByNodeId(node.id);\n    if (!result) throw new Error(\"can not find node cell\");\n    \n    const { column, row } = result;\n    if ((node.size[0] + nodeMinGap) > CELL_W) {\n      const addGridSize = Math.ceil((node.size[0] +nodeMinGap) / CELL_W) - 1;\n      let realAdd = addGridSize;\n      // 优化，假设同一列，不同行存在两个size为2的节点，遍历到第一个节点的时候，会往右插入两列，遍历到第二个节点，又往右插入。就会导致多余的网格\n      for(let j=0; j< addGridSize; j++) {\n        const hasColumn = grid.additionColumn.indexOf(column + j + 1) > -1;\n        if (hasColumn && !grid.cells[column + j + 1][row].node) {\n          realAdd --;\n        } else {\n          break;\n        }\n      }\n      grid.insertColumn(column, realAdd);\n    }\n    // 节点高度大于网格宽度，则往当前网格的下边插入行\n    if ((node.size[1] +nodeMinGap) > CELL_H) {\n      const addGridSize = Math.ceil((node.size[1]+nodeMinGap) / CELL_H) - 1;\n      let realAdd = addGridSize;\n      for(let j=0; j< addGridSize; j++) {\n        const hasColumn = grid.additionRow.indexOf(row + j + 1) > -1;\n        if (hasColumn && !grid.cells[column][row + j + 1].node) {\n          realAdd --;\n        } else {\n          break;\n        }\n      }\n      grid.insertRow(row, realAdd);\n    }\n  }\n \n  // 同步节点坐标\n  for(let i = 0; i < grid.columnNum; i++) {\n    for(let j = 0; j < grid.rowNum; j++) {\n      const cell = grid.cells[i][j];\n      if (cell.node) {\n        const node = data.nodes.find((node) => node.id === cell?.node?.id);\n        if (node) {\n          node.x = cell.x + node.size[0] / 2;\n          node.y = cell.y + node.size[1] / 2;\n        }\n      }\n    }\n  }\n}"]}},"error":null,"hash":"3f8b8a25ac85c447143618246390a8b8","cacheData":{"env":{}}}