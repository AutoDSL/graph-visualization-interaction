{"id":"node_modules/@antv/layout/lib/layout/dagre/src/util.js","dependencies":[{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\util.js.map","includedInParent":true,"mtime":1676178923780},{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\src\\layout\\dagre\\src\\util.ts","includedInParent":true,"mtime":1676178924078},{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\package.json","includedInParent":true,"mtime":1676178924413},{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\package.json","includedInParent":true,"mtime":1676178923486},{"name":"../../../util","loc":{"line":4,"column":21,"index":466},"parent":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\util.js","resolved":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\util\\index.js"},{"name":"../graph","loc":{"line":5,"column":22,"index":506},"parent":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\util.js","resolved":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\graph.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.minBy = exports.notime = exports.time = exports.partition = exports.maxRank = exports.addBorderNode = exports.removeEmptyRanks = exports.normalizeRanks = exports.buildLayerMatrix = exports.intersectRect = exports.predecessorWeights = exports.successorWeights = exports.zipObject = exports.asNonCompoundGraph = exports.simplify = exports.addDummyNode = void 0;\nvar util_1 = require(\"../../../util\");\nvar graph_1 = require(\"../graph\");\nvar safeSort = function (valueA, valueB) {\n    return Number(valueA) - Number(valueB);\n};\n/*\n * Adds a dummy node to the graph and return v.\n */\nvar addDummyNode = function (g, type, attrs, name) {\n    var v;\n    do {\n        v = \"\".concat(name).concat(Math.random());\n    } while (g.hasNode(v));\n    attrs.dummy = type;\n    g.setNode(v, attrs);\n    return v;\n};\nexports.addDummyNode = addDummyNode;\n/*\n * Returns a new graph with only simple edges. Handles aggregation of data\n * associated with multi-edges.\n */\nvar simplify = function (g) {\n    var simplified = new graph_1.Graph().setGraph(g.graph());\n    g.nodes().forEach(function (v) { simplified.setNode(v, g.node(v)); });\n    g.edges().forEach(function (e) {\n        var simpleLabel = simplified.edgeFromArgs(e.v, e.w) || { weight: 0, minlen: 1 };\n        var label = g.edge(e);\n        simplified.setEdge(e.v, e.w, {\n            weight: simpleLabel.weight + label.weight,\n            minlen: Math.max(simpleLabel.minlen, label.minlen)\n        });\n    });\n    return simplified;\n};\nexports.simplify = simplify;\nvar asNonCompoundGraph = function (g) {\n    var simplified = new graph_1.Graph({ multigraph: g.isMultigraph() }).setGraph(g.graph());\n    g.nodes().forEach(function (node) {\n        var _a;\n        if (!((_a = g.children(node)) === null || _a === void 0 ? void 0 : _a.length)) {\n            simplified.setNode(node, g.node(node));\n        }\n    });\n    g.edges().forEach(function (edge) {\n        simplified.setEdgeObj(edge, g.edge(edge));\n    });\n    return simplified;\n};\nexports.asNonCompoundGraph = asNonCompoundGraph;\nvar zipObject = function (keys, values) {\n    return keys === null || keys === void 0 ? void 0 : keys.reduce(function (obj, key, i) {\n        obj[key] = values[i];\n        return obj;\n    }, {});\n};\nexports.zipObject = zipObject;\nvar successorWeights = function (g) {\n    var weightsMap = {};\n    g.nodes().forEach(function (node) {\n        var _a;\n        var sucs = {};\n        (_a = g.outEdges(node)) === null || _a === void 0 ? void 0 : _a.forEach(function (e) {\n            var _a;\n            sucs[e.w] = (sucs[e.w] || 0) + (((_a = g.edge(e)) === null || _a === void 0 ? void 0 : _a.weight) || 0);\n        });\n        weightsMap[node] = sucs;\n    });\n    return weightsMap;\n};\nexports.successorWeights = successorWeights;\nvar predecessorWeights = function (g) {\n    var nodes = g.nodes();\n    var weightMap = nodes.map(function (v) {\n        var _a;\n        var preds = {};\n        (_a = g.inEdges(v)) === null || _a === void 0 ? void 0 : _a.forEach(function (e) {\n            preds[e.v] = (preds[e.v] || 0) + g.edge(e).weight;\n        });\n        return preds;\n    });\n    return (0, exports.zipObject)(nodes, weightMap);\n};\nexports.predecessorWeights = predecessorWeights;\n/*\n * Finds where a line starting at point ({x, y}) would intersect a rectangle\n * ({x, y, width, height}) if it were pointing at the rectangle's center.\n */\nvar intersectRect = function (rect, point) {\n    var x = Number(rect.x);\n    var y = Number(rect.y);\n    // Rectangle intersection algorithm from:\n    // http://math.stackexchange.com/questions/108113/find-edge-between-two-boxes\n    var dx = Number(point.x) - x;\n    var dy = Number(point.y) - y;\n    var w = Number(rect.width) / 2;\n    var h = Number(rect.height) / 2;\n    if (!dx && !dy) {\n        // completely overlapped directly, then return points its self\n        return { x: 0, y: 0 };\n    }\n    var sx;\n    var sy;\n    if (Math.abs(dy) * w > Math.abs(dx) * h) {\n        // Intersection is top or bottom of rect.\n        if (dy < 0) {\n            h = -h;\n        }\n        sx = (h * dx) / dy;\n        sy = h;\n    }\n    else {\n        // Intersection is left or right of rect.\n        if (dx < 0) {\n            w = -w;\n        }\n        sx = w;\n        sy = (w * dy) / dx;\n    }\n    return { x: x + sx, y: y + sy };\n};\nexports.intersectRect = intersectRect;\n/*\n * Given a DAG with each node assigned \"rank\" and \"order\" properties, this\n * const will produce a matrix with the ids of each node.\n */\nvar buildLayerMatrix = function (g) {\n    var layeringNodes = [];\n    var rankMax = (0, exports.maxRank)(g) + 1;\n    for (var i = 0; i < rankMax; i++) {\n        layeringNodes.push([]);\n    }\n    // const layering = _.map(_.range(maxRank(g) + 1), function() { return []; });\n    g.nodes().forEach(function (v) {\n        var node = g.node(v);\n        if (!node)\n            return;\n        var rank = node.rank;\n        if (rank !== undefined && layeringNodes[rank]) {\n            layeringNodes[rank].push(v);\n        }\n    });\n    for (var i = 0; i < rankMax; i++) {\n        layeringNodes[i] = layeringNodes[i].sort(function (va, vb) { var _a, _b; return safeSort((_a = g.node(va)) === null || _a === void 0 ? void 0 : _a.order, (_b = g.node(vb)) === null || _b === void 0 ? void 0 : _b.order); });\n    }\n    return layeringNodes;\n};\nexports.buildLayerMatrix = buildLayerMatrix;\n/*\n * Adjusts the ranks for all nodes in the graph such that all nodes v have\n * rank(v) >= 0 and at least one node w has rank(w) = 0.\n */\nvar normalizeRanks = function (g) {\n    var nodeRanks = g\n        .nodes()\n        .filter(function (v) { var _a; return ((_a = g.node(v)) === null || _a === void 0 ? void 0 : _a.rank) !== undefined; })\n        .map(function (v) { return g.node(v).rank; });\n    var min = Math.min.apply(Math, nodeRanks);\n    g.nodes().forEach(function (v) {\n        var node = g.node(v);\n        if (node.hasOwnProperty(\"rank\") && min !== Infinity) {\n            node.rank -= min;\n        }\n    });\n};\nexports.normalizeRanks = normalizeRanks;\nvar removeEmptyRanks = function (g) {\n    // Ranks may not start at 0, so we need to offset them\n    var nodes = g.nodes();\n    var nodeRanks = nodes\n        .filter(function (v) { var _a; return ((_a = g.node(v)) === null || _a === void 0 ? void 0 : _a.rank) !== undefined; })\n        .map(function (v) { return g.node(v).rank; });\n    var offset = Math.min.apply(Math, nodeRanks);\n    var layers = [];\n    nodes.forEach(function (v) {\n        var _a;\n        var rank = (((_a = g.node(v)) === null || _a === void 0 ? void 0 : _a.rank) || 0) - offset;\n        if (!layers[rank]) {\n            layers[rank] = [];\n        }\n        layers[rank].push(v);\n    });\n    var delta = 0;\n    var nodeRankFactor = g.graph().nodeRankFactor || 0;\n    for (var i = 0; i < layers.length; i++) {\n        var vs = layers[i];\n        if (vs === undefined) {\n            if (i % nodeRankFactor !== 0) {\n                delta -= 1;\n            }\n        }\n        else if (delta) {\n            vs === null || vs === void 0 ? void 0 : vs.forEach(function (v) {\n                var node = g.node(v);\n                if (node) {\n                    node.rank = node.rank || 0;\n                    node.rank += delta;\n                }\n            });\n        }\n    }\n};\nexports.removeEmptyRanks = removeEmptyRanks;\nvar addBorderNode = function (g, prefix, rank, order) {\n    var node = {\n        width: 0,\n        height: 0\n    };\n    if ((0, util_1.isNumber)(rank) && (0, util_1.isNumber)(order)) {\n        node.rank = rank;\n        node.order = order;\n    }\n    return (0, exports.addDummyNode)(g, \"border\", node, prefix);\n};\nexports.addBorderNode = addBorderNode;\nvar maxRank = function (g) {\n    var maxRank;\n    g.nodes().forEach(function (v) {\n        var _a;\n        var rank = (_a = g.node(v)) === null || _a === void 0 ? void 0 : _a.rank;\n        if (rank !== undefined) {\n            if (maxRank === undefined || rank > maxRank) {\n                maxRank = rank;\n            }\n        }\n    });\n    if (!maxRank) {\n        maxRank = 0;\n    }\n    return maxRank;\n};\nexports.maxRank = maxRank;\n/*\n * Partition a collection into two groups: `lhs` and `rhs`. If the supplied\n * const returns true for an entry it goes into `lhs`. Otherwise it goes\n * into `rhs.\n */\nvar partition = function (collection, fn) {\n    var result = { lhs: [], rhs: [] };\n    collection === null || collection === void 0 ? void 0 : collection.forEach(function (value) {\n        if (fn(value)) {\n            result.lhs.push(value);\n        }\n        else {\n            result.rhs.push(value);\n        }\n    });\n    return result;\n};\nexports.partition = partition;\n/*\n * Returns a new const that wraps `fn` with a timer. The wrapper logs the\n * time it takes to execute the function.\n */\nvar time = function (name, fn) {\n    var start = Date.now();\n    try {\n        return fn();\n    }\n    finally {\n        console.log(\"\".concat(name, \" time: \").concat(Date.now() - start, \"ms\"));\n    }\n};\nexports.time = time;\nvar notime = function (name, fn) {\n    return fn();\n};\nexports.notime = notime;\nvar minBy = function (array, func) {\n    return array.reduce(function (a, b) {\n        var valA = func(a);\n        var valB = func(b);\n        return valA > valB ? b : a;\n    });\n};\nexports.minBy = minBy;\n"},"sourceMaps":{"js":{"version":3,"file":"util.js","sourceRoot":"","sources":["../../../../src/layout/dagre/src/util.ts"],"names":[],"mappings":"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","sourcesContent":["import { isNumber } from \"../../../util\";\nimport { Graph, Node } from \"../graph\";\n\nconst safeSort = (valueA?: number, valueB?: number) => {\n  return Number(valueA) - Number(valueB);\n};\n\n/*\n * Adds a dummy node to the graph and return v.\n */\nexport const addDummyNode = (\n  g: Graph,\n  type: string,\n  attrs: Node<Record<string, any>>,\n  name: string\n) => {\n  let v;\n  do {\n    v = `${name}${Math.random()}`;\n  } while (g.hasNode(v));\n\n  attrs.dummy = type;\n  g.setNode(v, attrs);\n\n  return v;\n};\n\n/*\n * Returns a new graph with only simple edges. Handles aggregation of data\n * associated with multi-edges.\n */\nexport const simplify = (g: Graph) => {\n  const simplified = new Graph().setGraph(g.graph());\n  g.nodes().forEach((v) => { simplified.setNode(v, g.node(v)); });\n  g.edges().forEach((e) => {\n    const simpleLabel = simplified.edgeFromArgs(e.v, e.w) || { weight: 0, minlen: 1 };\n    const label = g.edge(e)!;\n    simplified.setEdge(e.v, e.w, {\n      weight: simpleLabel.weight! + label.weight!,\n      minlen: Math.max(simpleLabel.minlen!, label.minlen!)\n    });\n  });\n  return simplified;\n};\n\nexport const asNonCompoundGraph = (g: Graph) => {\n  const simplified = new Graph({ multigraph: g.isMultigraph() }).setGraph(\n    g.graph()\n  );\n  g.nodes().forEach((node) => {\n    if (!g.children(node)?.length) {\n      simplified.setNode(node, g.node(node));\n    }\n  });\n\n  g.edges().forEach((edge) => {\n    simplified.setEdgeObj(edge, g.edge(edge));\n  });\n\n  return simplified;\n};\n\nexport const zipObject = <T = any>(keys: string[], values: T[]) => {\n  return keys?.reduce((obj, key, i) => {\n    obj[key] = values[i];\n    return obj;\n  }, {} as Record<string, T>);\n};\n\nexport const successorWeights = (g: Graph) => {\n  const weightsMap: Record<string, Record<string, number>> = {};\n\n  g.nodes().forEach((node) => {\n    const sucs: Record<string, number> = {};\n    g.outEdges(node)?.forEach((e) => {\n      sucs[e.w] = (sucs[e.w] || 0) + (g.edge(e)?.weight || 0);\n    });\n    weightsMap[node] = sucs;\n  });\n\n  return weightsMap;\n};\n\n\n\nexport const predecessorWeights = (g: Graph) => {\n  const nodes = g.nodes();\n\n  const weightMap = nodes.map((v) => {\n    const preds: Record<string, number> = {};\n    g.inEdges(v)?.forEach((e) => {\n      preds[e.v] = (preds[e.v] || 0) + g.edge(e)!.weight!;\n    });\n    return preds;\n  });\n  return zipObject(nodes, weightMap);\n};\n\n/*\n * Finds where a line starting at point ({x, y}) would intersect a rectangle\n * ({x, y, width, height}) if it were pointing at the rectangle's center.\n */\nexport const intersectRect = (\n  rect: { x?: number; y?: number; width?: number; height?: number },\n  point: { x?: number; y?: number }\n) => {\n  const x = Number(rect.x);\n  const y = Number(rect.y);\n\n  // Rectangle intersection algorithm from:\n  // http://math.stackexchange.com/questions/108113/find-edge-between-two-boxes\n  const dx = Number(point.x) - x;\n  const dy = Number(point.y) - y;\n  let w = Number(rect.width) / 2;\n  let h = Number(rect.height) / 2;\n\n  if (!dx && !dy) {\n    // completely overlapped directly, then return points its self\n    return { x: 0, y: 0 };\n  }\n\n  let sx;\n  let sy;\n\n  if (Math.abs(dy) * w > Math.abs(dx) * h) {\n    // Intersection is top or bottom of rect.\n    if (dy < 0) {\n      h = -h;\n    }\n    sx = (h * dx) / dy;\n    sy = h;\n  } else {\n    // Intersection is left or right of rect.\n    if (dx < 0) {\n      w = -w;\n    }\n    sx = w;\n    sy = (w * dy) / dx;\n  }\n\n  return { x: x + sx, y: y + sy };\n};\n\n/*\n * Given a DAG with each node assigned \"rank\" and \"order\" properties, this\n * const will produce a matrix with the ids of each node.\n */\nexport const buildLayerMatrix = (g: Graph) => {\n  const layeringNodes: string[][] = [];\n  const rankMax = maxRank(g) + 1;\n  for (let i = 0; i < rankMax; i++) {\n    layeringNodes.push([]);\n  }\n  \n  // const layering = _.map(_.range(maxRank(g) + 1), function() { return []; });\n  g.nodes().forEach((v: string) => {\n    const node = g.node(v)!;\n    if (!node) return;\n    const rank = node.rank;\n    if (rank !== undefined && layeringNodes[rank]) {\n      layeringNodes[rank].push(v);\n    }\n  });\n\n  for (let i = 0; i < rankMax; i++) {\n    layeringNodes[i] = layeringNodes[i].sort((va: string, vb: string) =>\n      safeSort(g.node(va)?.order, g.node(vb)?.order)\n    );\n  }\n\n  return layeringNodes;\n};\n\n/*\n * Adjusts the ranks for all nodes in the graph such that all nodes v have\n * rank(v) >= 0 and at least one node w has rank(w) = 0.\n */\nexport const normalizeRanks = (g: Graph) => {\n  const nodeRanks = g\n    .nodes()\n    .filter((v) => g.node(v)?.rank !== undefined)\n    .map((v) => g.node(v)!.rank!);\n  const min = Math.min(...nodeRanks);\n  g.nodes().forEach((v) => {\n    const node = g.node(v)!;\n    if (node.hasOwnProperty(\"rank\") && min !== Infinity) {\n      node.rank! -= min;\n    }\n  });\n};\n\nexport const removeEmptyRanks = (g: Graph) => {\n  // Ranks may not start at 0, so we need to offset them\n  const nodes = g.nodes();\n  const nodeRanks = nodes\n    .filter((v) => g.node(v)?.rank !== undefined)\n    .map((v) => g.node(v)!.rank as number);\n\n  const offset = Math.min(...nodeRanks);\n  const layers: string[][] = [];\n\n  nodes.forEach((v) => {\n    const rank = (g.node(v)?.rank || 0) - offset;\n\n    if (!layers[rank]) {\n      layers[rank] = [];\n    }\n    layers[rank].push(v);\n  });\n\n  let delta = 0;\n  const nodeRankFactor = g.graph().nodeRankFactor || 0;\n\n  for (let i = 0; i < layers.length; i++) {\n    const vs = layers[i];\n    if (vs === undefined) {\n      if (i % nodeRankFactor !== 0) {\n        delta -= 1;\n      }\n    } else if (delta) {\n      vs?.forEach((v: string) => {\n        const node = g.node(v);\n        if (node) {\n          node.rank = node.rank || 0;\n          node.rank += delta;\n        }\n      });\n    }\n  }\n};\n\nexport const addBorderNode = (\n  g: Graph,\n  prefix: string,\n  rank?: number,\n  order?: number\n) => {\n  const node: Node = {\n    width: 0,\n    height: 0\n  };\n  if (isNumber(rank) && isNumber(order)) {\n    node.rank = rank;\n    node.order = order;\n  }\n  return addDummyNode(g, \"border\", node, prefix);\n};\n\nexport const maxRank = (g: Graph) => {\n  let maxRank: number;\n  g.nodes().forEach((v) => {\n    const rank = g.node(v)?.rank;\n    if (rank !== undefined) {\n      if (maxRank === undefined || rank > maxRank) {\n        maxRank = rank;\n      }\n    }\n  });\n\n  if (!maxRank!) {\n    maxRank = 0;\n  }\n  return maxRank;\n};\n\n/*\n * Partition a collection into two groups: `lhs` and `rhs`. If the supplied\n * const returns true for an entry it goes into `lhs`. Otherwise it goes\n * into `rhs.\n */\nexport const partition = <T = any>(\n  collection: T[],\n  fn: (val: T) => boolean\n) => {\n  const result = { lhs: [] as T[], rhs: [] as T[] };\n  collection?.forEach((value) => {\n    if (fn(value)) {\n      result.lhs.push(value);\n    } else {\n      result.rhs.push(value);\n    }\n  });\n  return result;\n};\n\n/*\n * Returns a new const that wraps `fn` with a timer. The wrapper logs the\n * time it takes to execute the function.\n */\nexport const time = (name: string, fn: () => void) => {\n  const start = Date.now();\n  try {\n    return fn();\n  } finally {\n    console.log(`${name} time: ${Date.now() - start}ms`);\n  }\n};\n\nexport const notime = (name: string, fn: () => void) => {\n  return fn();\n};\n\nexport const minBy = <T = any>(array: T[], func: (param: T) => number) => {\n  return array.reduce((a, b) => {\n    const valA = func(a);\n    const valB = func(b);\n    return valA > valB ? b : a;\n  });\n};\n"]}},"error":null,"hash":"4a10addd7a5669166a75f7692f4ff87d","cacheData":{"env":{}}}