{"id":"node_modules/@antv/layout/lib/layout/dagre/src/order/build-layer-graph.js","dependencies":[{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\order\\build-layer-graph.js.map","includedInParent":true,"mtime":1676178923545},{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\src\\layout\\dagre\\src\\order\\build-layer-graph.ts","includedInParent":true,"mtime":1676178923817},{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\package.json","includedInParent":true,"mtime":1676178924413},{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\package.json","includedInParent":true,"mtime":1676178923486},{"name":"../../graph","loc":{"line":3,"column":22,"index":99},"parent":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\order\\build-layer-graph.js","resolved":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\graph.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graph_1 = require(\"../../graph\");\n/*\n * Constructs a graph that can be used to sort a layer of nodes. The graph will\n * contain all base and subgraph nodes from the request layer in their original\n * hierarchy and any edges that are incident on these nodes and are of the type\n * requested by the \"relationship\" parameter.\n *\n * Nodes from the requested rank that do not have parents are assigned a root\n * node in the output graph, which is set in the root graph attribute. This\n * makes it easy to walk the hierarchy of movable nodes during ordering.\n *\n * Pre-conditions:\n *\n *    1. Input graph is a DAG\n *    2. Base nodes in the input graph have a rank attribute\n *    3. Subgraph nodes in the input graph has minRank and maxRank attributes\n *    4. Edges have an assigned weight\n *\n * Post-conditions:\n *\n *    1. Output graph has all nodes in the movable rank with preserved\n *       hierarchy.\n *    2. Root nodes in the movable layer are made children of the node\n *       indicated by the root attribute of the graph.\n *    3. Non-movable nodes incident on movable nodes, selected by the\n *       relationship parameter, are included in the graph (without hierarchy).\n *    4. Edges incident on movable nodes, selected by the relationship\n *       parameter, are added to the output graph.\n *    5. The weights for copied edges are aggregated as need, since the output\n *       graph is not a multi-graph.\n */\nvar buildLayerGraph = function (g, rank, relationship) {\n    var root = createRootNode(g);\n    var result = new graph_1.Graph({ compound: true })\n        .setGraph({ root: root })\n        .setDefaultNodeLabel(function (v) {\n        return g.node(v);\n    });\n    g.nodes().forEach(function (v) {\n        var _a;\n        var node = g.node(v);\n        var parent = g.parent(v);\n        if (node.rank === rank ||\n            (node.minRank <= rank && rank <= node.maxRank)) {\n            result.setNode(v);\n            result.setParent(v, parent || root);\n            // This assumes we have only short edges!\n            (_a = g[relationship](v)) === null || _a === void 0 ? void 0 : _a.forEach(function (e) {\n                var u = e.v === v ? e.w : e.v;\n                var edge = result.edgeFromArgs(u, v);\n                var weight = edge !== undefined ? edge.weight : 0;\n                result.setEdge(u, v, { weight: g.edge(e).weight + weight });\n            });\n            if (node.hasOwnProperty(\"minRank\")) {\n                result.setNode(v, {\n                    borderLeft: node.borderLeft[rank],\n                    borderRight: node.borderRight[rank],\n                });\n            }\n        }\n    });\n    return result;\n};\nvar createRootNode = function (g) {\n    var v;\n    while (g.hasNode((v = \"_root\".concat(Math.random()))))\n        ;\n    return v;\n};\nexports.default = buildLayerGraph;\n"},"sourceMaps":{"js":{"version":3,"file":"build-layer-graph.js","sourceRoot":"","sources":["../../../../../src/layout/dagre/src/order/build-layer-graph.ts"],"names":[],"mappings":";;AAAA,qCAAoC;AAEpC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA6BG;AACH,IAAM,eAAe,GAAG,UACtB,CAAQ,EACR,IAAY,EACZ,YAAoC;IAEpC,IAAM,IAAI,GAAG,cAAc,CAAC,CAAC,CAAC,CAAC;IAC/B,IAAM,MAAM,GAAG,IAAI,aAAK,CAAC,EAAE,QAAQ,EAAE,IAAI,EAAE,CAAC;SACzC,QAAQ,CAAC,EAAE,IAAI,MAAA,EAAE,CAAC;SAClB,mBAAmB,CAAC,UAAC,CAAS;QAC7B,OAAO,CAAC,CAAC,IAAI,CAAC,CAAC,CAAE,CAAC;IACpB,CAAC,CAAC,CAAC;IAEL,CAAC,CAAC,KAAK,EAAE,CAAC,OAAO,CAAC,UAAC,CAAC;;QAClB,IAAM,IAAI,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,CAAE,CAAC;QACxB,IAAM,MAAM,GAAG,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;QAE3B,IACE,IAAI,CAAC,IAAI,KAAK,IAAI;YAClB,CAAE,IAAI,CAAC,OAAkB,IAAI,IAAI,IAAI,IAAI,IAAK,IAAI,CAAC,OAAkB,CAAC,EACtE;YACA,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;YAClB,MAAM,CAAC,SAAS,CAAC,CAAC,EAAE,MAAM,IAAI,IAAI,CAAC,CAAC;YAEpC,yCAAyC;YACzC,MAAA,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,0CAAE,OAAO,CAAC,UAAC,CAAC;gBAC5B,IAAM,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBAChC,IAAM,IAAI,GAAG,MAAM,CAAC,YAAY,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;gBACvC,IAAM,MAAM,GAAG,IAAI,KAAK,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;gBACpD,MAAM,CAAC,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,MAAM,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,CAAE,CAAC,MAAO,GAAG,MAAO,EAAE,CAAC,CAAC;YACjE,CAAC,CAAC,CAAC;YAEH,IAAI,IAAI,CAAC,cAAc,CAAC,SAAS,CAAC,EAAE;gBAClC,MAAM,CAAC,OAAO,CAAC,CAAC,EAAE;oBAChB,UAAU,EAAE,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC;oBACjC,WAAW,EAAE,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC;iBACpC,CAAC,CAAC;aACJ;SACF;IACH,CAAC,CAAC,CAAC;IAEH,OAAO,MAAM,CAAC;AAChB,CAAC,CAAC;AAEF,IAAM,cAAc,GAAG,UAAC,CAAQ;IAC9B,IAAI,CAAC,CAAC;IACN,OAAO,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,GAAG,eAAQ,IAAI,CAAC,MAAM,EAAE,CAAE,CAAC,CAAC;QAAC,CAAC;IACjD,OAAO,CAAC,CAAC;AACX,CAAC,CAAC;AAEF,kBAAe,eAAe,CAAC","sourcesContent":["import { Graph } from \"../../graph\";\n\n/*\n * Constructs a graph that can be used to sort a layer of nodes. The graph will\n * contain all base and subgraph nodes from the request layer in their original\n * hierarchy and any edges that are incident on these nodes and are of the type\n * requested by the \"relationship\" parameter.\n *\n * Nodes from the requested rank that do not have parents are assigned a root\n * node in the output graph, which is set in the root graph attribute. This\n * makes it easy to walk the hierarchy of movable nodes during ordering.\n *\n * Pre-conditions:\n *\n *    1. Input graph is a DAG\n *    2. Base nodes in the input graph have a rank attribute\n *    3. Subgraph nodes in the input graph has minRank and maxRank attributes\n *    4. Edges have an assigned weight\n *\n * Post-conditions:\n *\n *    1. Output graph has all nodes in the movable rank with preserved\n *       hierarchy.\n *    2. Root nodes in the movable layer are made children of the node\n *       indicated by the root attribute of the graph.\n *    3. Non-movable nodes incident on movable nodes, selected by the\n *       relationship parameter, are included in the graph (without hierarchy).\n *    4. Edges incident on movable nodes, selected by the relationship\n *       parameter, are added to the output graph.\n *    5. The weights for copied edges are aggregated as need, since the output\n *       graph is not a multi-graph.\n */\nconst buildLayerGraph = (\n  g: Graph,\n  rank: number,\n  relationship: \"inEdges\" | \"outEdges\"\n) => {\n  const root = createRootNode(g);\n  const result = new Graph({ compound: true })\n    .setGraph({ root })\n    .setDefaultNodeLabel((v: string) => {\n      return g.node(v)!;\n    });\n\n  g.nodes().forEach((v) => {\n    const node = g.node(v)!;\n    const parent = g.parent(v);\n\n    if (\n      node.rank === rank ||\n      ((node.minRank as number) <= rank && rank <= (node.maxRank as number))\n    ) {\n      result.setNode(v);\n      result.setParent(v, parent || root);\n\n      // This assumes we have only short edges!\n      g[relationship](v)?.forEach((e) => {\n        const u = e.v === v ? e.w : e.v;\n        const edge = result.edgeFromArgs(u, v);\n        const weight = edge !== undefined ? edge.weight : 0;\n        result.setEdge(u, v, { weight: g.edge(e)!.weight! + weight! });\n      });\n\n      if (node.hasOwnProperty(\"minRank\")) {\n        result.setNode(v, {\n          borderLeft: node.borderLeft[rank],\n          borderRight: node.borderRight[rank],\n        });\n      }\n    }\n  });\n\n  return result;\n};\n\nconst createRootNode = (g: Graph) => {\n  let v;\n  while (g.hasNode((v = `_root${Math.random()}`)));\n  return v;\n};\n\nexport default buildLayerGraph;\n"]}},"error":null,"hash":"03649b6ff6b7401bdfefd7e232144511","cacheData":{"env":{}}}