{"id":"node_modules/@antv/layout/lib/layout/dagre/src/layout.js","dependencies":[{"name":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\layout.js.map","includedInParent":true,"mtime":499162500000},{"name":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\src\\layout\\dagre\\src\\layout.ts","includedInParent":true,"mtime":499162500000},{"name":"D:\\myData\\前端\\doing\\AutoPL\\package.json","includedInParent":true,"mtime":1674182060254},{"name":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\package.json","includedInParent":true,"mtime":1674179681168},{"name":"./acyclic","loc":{"line":17,"column":40,"index":639},"parent":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\layout.js","resolved":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\acyclic.js"},{"name":"./normalize","loc":{"line":18,"column":42,"index":696},"parent":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\layout.js","resolved":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\normalize.js"},{"name":"./rank","loc":{"line":19,"column":37,"index":750},"parent":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\layout.js","resolved":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\rank\\index.js"},{"name":"./util","loc":{"line":20,"column":21,"index":783},"parent":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\layout.js","resolved":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\util.js"},{"name":"./parent-dummy-chains","loc":{"line":21,"column":52,"index":846},"parent":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\layout.js","resolved":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\parent-dummy-chains.js"},{"name":"./nesting-graph","loc":{"line":22,"column":46,"index":919},"parent":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\layout.js","resolved":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\nesting-graph.js"},{"name":"./add-border-segments","loc":{"line":23,"column":52,"index":992},"parent":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\layout.js","resolved":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\add-border-segments.js"},{"name":"./coordinate-system","loc":{"line":24,"column":50,"index":1069},"parent":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\layout.js","resolved":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\coordinate-system.js"},{"name":"./order","loc":{"line":25,"column":38,"index":1132},"parent":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\layout.js","resolved":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\order\\index.js"},{"name":"./position","loc":{"line":26,"column":41,"index":1186},"parent":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\layout.js","resolved":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\position\\index.js"},{"name":"./order/init-data-order","loc":{"line":27,"column":48,"index":1250},"parent":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\layout.js","resolved":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\order\\init-data-order.js"},{"name":"../graph","loc":{"line":28,"column":22,"index":1301},"parent":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\layout.js","resolved":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\graph.js"}],"generated":{"js":"\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar acyclic_1 = __importDefault(require(\"./acyclic\"));\nvar normalize_1 = __importDefault(require(\"./normalize\"));\nvar rank_1 = __importDefault(require(\"./rank\"));\nvar util_1 = require(\"./util\");\nvar parent_dummy_chains_1 = __importDefault(require(\"./parent-dummy-chains\"));\nvar nesting_graph_1 = __importDefault(require(\"./nesting-graph\"));\nvar add_border_segments_1 = __importDefault(require(\"./add-border-segments\"));\nvar coordinate_system_1 = __importDefault(require(\"./coordinate-system\"));\nvar order_1 = __importDefault(require(\"./order\"));\nvar position_1 = __importDefault(require(\"./position\"));\nvar init_data_order_1 = __importDefault(require(\"./order/init-data-order\"));\nvar graph_1 = require(\"../graph\");\nvar layout = function (g, opts) {\n    var time = opts && opts.debugTiming ? util_1.time : util_1.notime;\n    time(\"layout\", function () {\n        // 如果在原图基础上修改，继承原图的order结果\n        if (opts && !opts.keepNodeOrder && opts.prevGraph) {\n            time(\"  inheritOrder\", function () {\n                inheritOrder(g, opts.prevGraph);\n            });\n        }\n        var layoutGraph = time(\"  buildLayoutGraph\", function () {\n            return buildLayoutGraph(g);\n        });\n        // 控制是否为边的label留位置（这会影响是否在边中间添加dummy node）\n        if (!(opts && opts.edgeLabelSpace === false)) {\n            time(\"  makeSpaceForEdgeLabels\", function () {\n                makeSpaceForEdgeLabels(layoutGraph);\n            });\n        }\n        // TODO: 暂时处理层级设置不正确时的异常报错，提示设置正确的层级\n        try {\n            time(\"  runLayout\", function () {\n                runLayout(layoutGraph, time, opts);\n            });\n        }\n        catch (e) {\n            if (e.message ===\n                \"Not possible to find intersection inside of the rectangle\") {\n                console.error(\"The following error may be caused by improper layer setting, please make sure your manual layer setting does not violate the graph's structure:\\n\", e);\n                return;\n            }\n            throw e;\n        }\n        time(\"  updateInputGraph\", function () {\n            updateInputGraph(g, layoutGraph);\n        });\n    });\n};\nvar runLayout = function (g, time, opts) {\n    time(\"    removeSelfEdges\", function () {\n        removeSelfEdges(g);\n    });\n    time(\"    acyclic\", function () {\n        acyclic_1.default.run(g);\n    });\n    time(\"    nestingGraph.run\", function () {\n        nesting_graph_1.default.run(g);\n    });\n    time(\"    rank\", function () {\n        (0, rank_1.default)((0, util_1.asNonCompoundGraph)(g));\n    });\n    time(\"    injectEdgeLabelProxies\", function () {\n        injectEdgeLabelProxies(g);\n    });\n    time(\"    removeEmptyRanks\", function () {\n        (0, util_1.removeEmptyRanks)(g);\n    });\n    time(\"    nestingGraph.cleanup\", function () {\n        nesting_graph_1.default.cleanup(g);\n    });\n    time(\"    normalizeRanks\", function () {\n        (0, util_1.normalizeRanks)(g);\n    });\n    time(\"    assignRankMinMax\", function () {\n        assignRankMinMax(g);\n    });\n    time(\"    removeEdgeLabelProxies\", function () {\n        removeEdgeLabelProxies(g);\n    });\n    time(\"    normalize.run\", function () {\n        normalize_1.default.run(g);\n    });\n    time(\"    parentDummyChains\", function () {\n        (0, parent_dummy_chains_1.default)(g);\n    });\n    time(\"    addBorderSegments\", function () {\n        (0, add_border_segments_1.default)(g);\n    });\n    if (opts && opts.keepNodeOrder) {\n        time(\"    initDataOrder\", function () {\n            (0, init_data_order_1.default)(g, opts.nodeOrder);\n        });\n    }\n    time(\"    order\", function () {\n        (0, order_1.default)(g);\n    });\n    time(\"    insertSelfEdges\", function () {\n        insertSelfEdges(g);\n    });\n    time(\"    adjustCoordinateSystem\", function () {\n        coordinate_system_1.default.adjust(g);\n    });\n    time(\"    position\", function () {\n        (0, position_1.default)(g);\n    });\n    time(\"    positionSelfEdges\", function () {\n        positionSelfEdges(g);\n    });\n    time(\"    removeBorderNodes\", function () {\n        removeBorderNodes(g);\n    });\n    time(\"    normalize.undo\", function () {\n        normalize_1.default.undo(g);\n    });\n    time(\"    fixupEdgeLabelCoords\", function () {\n        fixupEdgeLabelCoords(g);\n    });\n    time(\"    undoCoordinateSystem\", function () {\n        coordinate_system_1.default.undo(g);\n    });\n    time(\"    translateGraph\", function () {\n        translateGraph(g);\n    });\n    time(\"    assignNodeIntersects\", function () {\n        assignNodeIntersects(g);\n    });\n    time(\"    reversePoints\", function () {\n        reversePointsForReversedEdges(g);\n    });\n    time(\"    acyclic.undo\", function () {\n        acyclic_1.default.undo(g);\n    });\n};\n/**\n * 继承上一个布局中的order，防止翻转\n * TODO: 暂时没有考虑涉及层级变动的布局，只保证原来布局层级和相对顺序不变\n */\nvar inheritOrder = function (currG, prevG) {\n    currG.nodes().forEach(function (n) {\n        var node = currG.node(n);\n        var prevNode = prevG.node(n);\n        if (prevNode !== undefined) {\n            node.fixorder = prevNode._order;\n            delete prevNode._order;\n        }\n        else {\n            delete node.fixorder;\n        }\n    });\n};\n/*\n * Copies final layout information from the layout graph back to the input\n * graph. This process only copies whitelisted attributes from the layout graph\n * to the input graph, so it serves as a good place to determine what\n * attributes can influence layout.\n */\nvar updateInputGraph = function (inputGraph, layoutGraph) {\n    inputGraph.nodes().forEach(function (v) {\n        var _a;\n        var inputLabel = inputGraph.node(v);\n        if (inputLabel) {\n            var layoutLabel = layoutGraph.node(v);\n            inputLabel.x = layoutLabel.x;\n            inputLabel.y = layoutLabel.y;\n            inputLabel._order = layoutLabel.order;\n            inputLabel._rank = layoutLabel.rank;\n            if ((_a = layoutGraph.children(v)) === null || _a === void 0 ? void 0 : _a.length) {\n                inputLabel.width = layoutLabel.width;\n                inputLabel.height = layoutLabel.height;\n            }\n        }\n    });\n    inputGraph.edges().forEach(function (e) {\n        var inputLabel = inputGraph.edge(e);\n        var layoutLabel = layoutGraph.edge(e);\n        inputLabel.points = layoutLabel ? layoutLabel.points : [];\n        if (layoutLabel && layoutLabel.hasOwnProperty(\"x\")) {\n            inputLabel.x = layoutLabel.x;\n            inputLabel.y = layoutLabel.y;\n        }\n    });\n    inputGraph.graph().width = layoutGraph.graph().width;\n    inputGraph.graph().height = layoutGraph.graph().height;\n};\nvar graphNumAttrs = [\"nodesep\", \"edgesep\", \"ranksep\", \"marginx\", \"marginy\"];\nvar graphDefaults = { ranksep: 50, edgesep: 20, nodesep: 50, rankdir: \"tb\" };\nvar graphAttrs = [\"acyclicer\", \"ranker\", \"rankdir\", \"align\"];\nvar nodeNumAttrs = [\"width\", \"height\", \"layer\", \"fixorder\"]; // 需要传入layer, fixOrder作为参数参考\nvar nodeDefaults = { width: 0, height: 0 };\nvar edgeNumAttrs = [\"minlen\", \"weight\", \"width\", \"height\", \"labeloffset\"];\nvar edgeDefaults = {\n    minlen: 1,\n    weight: 1,\n    width: 0,\n    height: 0,\n    labeloffset: 10,\n    labelpos: \"r\",\n};\nvar edgeAttrs = [\"labelpos\"];\n/*\n * Constructs a new graph from the input graph, which can be used for layout.\n * This process copies only whitelisted attributes from the input graph to the\n * layout graph. Thus this function serves as a good place to determine what\n * attributes can influence layout.\n */\nvar buildLayoutGraph = function (inputGraph) {\n    var g = new graph_1.Graph({ multigraph: true, compound: true });\n    var graph = canonicalize(inputGraph.graph());\n    var pickedProperties = {};\n    graphAttrs === null || graphAttrs === void 0 ? void 0 : graphAttrs.forEach(function (key) {\n        if (graph[key] !== undefined)\n            pickedProperties[key] = graph[key];\n    });\n    g.setGraph(Object.assign({}, graphDefaults, selectNumberAttrs(graph, graphNumAttrs), pickedProperties));\n    inputGraph.nodes().forEach(function (v) {\n        var node = canonicalize(inputGraph.node(v));\n        var defaultNode = __assign(__assign({}, nodeDefaults), node);\n        var defaultAttrs = selectNumberAttrs(defaultNode, nodeNumAttrs);\n        g.setNode(v, defaultAttrs);\n        g.setParent(v, inputGraph.parent(v));\n    });\n    inputGraph.edges().forEach(function (e) {\n        var edge = canonicalize(inputGraph.edge(e));\n        var pickedProperties = {};\n        edgeAttrs === null || edgeAttrs === void 0 ? void 0 : edgeAttrs.forEach(function (key) {\n            if (edge[key] !== undefined)\n                pickedProperties[key] = edge[key];\n        });\n        g.setEdgeObj(e, Object.assign({}, edgeDefaults, selectNumberAttrs(edge, edgeNumAttrs), pickedProperties));\n    });\n    return g;\n};\n/*\n * This idea comes from the Gansner paper: to account for edge labels in our\n * layout we split each rank in half by doubling minlen and halving ranksep.\n * Then we can place labels at these mid-points between nodes.\n *\n * We also add some minimal padding to the width to push the label for the edge\n * away from the edge itself a bit.\n */\nvar makeSpaceForEdgeLabels = function (g) {\n    var graph = g.graph();\n    if (!graph.ranksep)\n        graph.ranksep = 0;\n    graph.ranksep /= 2;\n    g.nodes().forEach(function (n) {\n        var node = g.node(n);\n        if (!isNaN(node.layer)) {\n            if (!node.layer)\n                node.layer = 0;\n        }\n    });\n    g.edges().forEach(function (e) {\n        var _a;\n        var edge = g.edge(e);\n        edge.minlen *= 2;\n        if (((_a = edge.labelpos) === null || _a === void 0 ? void 0 : _a.toLowerCase()) !== \"c\") {\n            if (graph.rankdir === \"TB\" || graph.rankdir === \"BT\") {\n                edge.width += edge.labeloffset;\n            }\n            else {\n                edge.height += edge.labeloffset;\n            }\n        }\n    });\n};\n/*\n * Creates temporary dummy nodes that capture the rank in which each edge's\n * label is going to, if it has one of non-zero width and height. We do this\n * so that we can safely remove empty ranks while preserving balance for the\n * label's position.\n */\nvar injectEdgeLabelProxies = function (g) {\n    g.edges().forEach(function (e) {\n        var edge = g.edge(e);\n        if (edge.width && edge.height) {\n            var v = g.node(e.v);\n            var w = g.node(e.w);\n            var label = {\n                e: e,\n                rank: (w.rank - v.rank) / 2 + v.rank,\n            };\n            (0, util_1.addDummyNode)(g, \"edge-proxy\", label, \"_ep\");\n        }\n    });\n};\nvar assignRankMinMax = function (g) {\n    var maxRank = 0;\n    g.nodes().forEach(function (v) {\n        var _a, _b;\n        var node = g.node(v);\n        if (node.borderTop) {\n            node.minRank = (_a = g.node(node.borderTop)) === null || _a === void 0 ? void 0 : _a.rank;\n            node.maxRank = (_b = g.node(node.borderBottom)) === null || _b === void 0 ? void 0 : _b.rank;\n            maxRank = Math.max(maxRank, node.maxRank || -Infinity);\n        }\n    });\n    g.graph().maxRank = maxRank;\n};\nvar removeEdgeLabelProxies = function (g) {\n    g.nodes().forEach(function (v) {\n        var node = g.node(v);\n        if (node.dummy === \"edge-proxy\") {\n            g.edge(node.e).labelRank = node.rank;\n            g.removeNode(v);\n        }\n    });\n};\nvar translateGraph = function (g) {\n    var minX;\n    var maxX = 0;\n    var minY;\n    var maxY = 0;\n    var graphLabel = g.graph();\n    var marginX = graphLabel.marginx || 0;\n    var marginY = graphLabel.marginy || 0;\n    var getExtremes = function (attrs) {\n        if (!attrs)\n            return;\n        var x = attrs.x;\n        var y = attrs.y;\n        var w = attrs.width;\n        var h = attrs.height;\n        if (!isNaN(x) && !isNaN(w)) {\n            if (minX === undefined) {\n                minX = x - w / 2;\n            }\n            minX = Math.min(minX, x - w / 2);\n            maxX = Math.max(maxX, x + w / 2);\n        }\n        if (!isNaN(y) && !isNaN(h)) {\n            if (minY === undefined) {\n                minY = y - h / 2;\n            }\n            minY = Math.min(minY, y - h / 2);\n            maxY = Math.max(maxY, y + h / 2);\n        }\n    };\n    g.nodes().forEach(function (v) {\n        getExtremes(g.node(v));\n    });\n    g.edges().forEach(function (e) {\n        var edge = g.edge(e);\n        if (edge === null || edge === void 0 ? void 0 : edge.hasOwnProperty(\"x\")) {\n            getExtremes(edge);\n        }\n    });\n    minX -= marginX;\n    minY -= marginY;\n    g.nodes().forEach(function (v) {\n        var node = g.node(v);\n        if (node) {\n            node.x -= minX;\n            node.y -= minY;\n        }\n    });\n    g.edges().forEach(function (e) {\n        var _a;\n        var edge = g.edge(e);\n        (_a = edge.points) === null || _a === void 0 ? void 0 : _a.forEach(function (p) {\n            p.x -= minX;\n            p.y -= minY;\n        });\n        if (edge.hasOwnProperty(\"x\")) {\n            edge.x -= minX;\n        }\n        if (edge.hasOwnProperty(\"y\")) {\n            edge.y -= minY;\n        }\n    });\n    graphLabel.width = maxX - minX + marginX;\n    graphLabel.height = maxY - minY + marginY;\n};\nvar assignNodeIntersects = function (g) {\n    g.edges().forEach(function (e) {\n        var edge = g.edge(e);\n        var nodeV = g.node(e.v);\n        var nodeW = g.node(e.w);\n        var p1;\n        var p2;\n        if (!edge.points) {\n            edge.points = [];\n            p1 = nodeW;\n            p2 = nodeV;\n        }\n        else {\n            p1 = edge.points[0];\n            p2 = edge.points[edge.points.length - 1];\n        }\n        edge.points.unshift((0, util_1.intersectRect)(nodeV, p1));\n        edge.points.push((0, util_1.intersectRect)(nodeW, p2));\n    });\n};\nvar fixupEdgeLabelCoords = function (g) {\n    g.edges().forEach(function (e) {\n        var edge = g.edge(e);\n        if (edge === null || edge === void 0 ? void 0 : edge.hasOwnProperty(\"x\")) {\n            if (edge.labelpos === \"l\" || edge.labelpos === \"r\") {\n                edge.width -= edge.labeloffset;\n            }\n            switch (edge.labelpos) {\n                case \"l\":\n                    edge.x -= edge.width / 2 + edge.labeloffset;\n                    break;\n                case \"r\":\n                    edge.x += edge.width / 2 + edge.labeloffset;\n                    break;\n            }\n        }\n    });\n};\nvar reversePointsForReversedEdges = function (g) {\n    g.edges().forEach(function (e) {\n        var _a;\n        var edge = g.edge(e);\n        if (edge.reversed) {\n            (_a = edge.points) === null || _a === void 0 ? void 0 : _a.reverse();\n        }\n    });\n};\nvar removeBorderNodes = function (g) {\n    g.nodes().forEach(function (v) {\n        var _a, _b, _c;\n        if ((_a = g.children(v)) === null || _a === void 0 ? void 0 : _a.length) {\n            var node = g.node(v);\n            var t = g.node(node.borderTop);\n            var b = g.node(node.borderBottom);\n            var l = g.node(node.borderLeft[((_b = node.borderLeft) === null || _b === void 0 ? void 0 : _b.length) - 1]);\n            var r = g.node(node.borderRight[((_c = node.borderRight) === null || _c === void 0 ? void 0 : _c.length) - 1]);\n            node.width = Math.abs((r === null || r === void 0 ? void 0 : r.x) - (l === null || l === void 0 ? void 0 : l.x)) || 10;\n            node.height = Math.abs((b === null || b === void 0 ? void 0 : b.y) - (t === null || t === void 0 ? void 0 : t.y)) || 10;\n            node.x = ((l === null || l === void 0 ? void 0 : l.x) || 0) + node.width / 2;\n            node.y = ((t === null || t === void 0 ? void 0 : t.y) || 0) + node.height / 2;\n        }\n    });\n    g.nodes().forEach(function (v) {\n        var _a;\n        if (((_a = g.node(v)) === null || _a === void 0 ? void 0 : _a.dummy) === \"border\") {\n            g.removeNode(v);\n        }\n    });\n};\nvar removeSelfEdges = function (g) {\n    g.edges().forEach(function (e) {\n        if (e.v === e.w) {\n            var node = g.node(e.v);\n            if (!node.selfEdges) {\n                node.selfEdges = [];\n            }\n            node.selfEdges.push({ e: e, label: g.edge(e) });\n            g.removeEdgeObj(e);\n        }\n    });\n};\nvar insertSelfEdges = function (g) {\n    var layers = (0, util_1.buildLayerMatrix)(g);\n    layers === null || layers === void 0 ? void 0 : layers.forEach(function (layer) {\n        var orderShift = 0;\n        layer === null || layer === void 0 ? void 0 : layer.forEach(function (v, i) {\n            var _a;\n            var node = g.node(v);\n            node.order = i + orderShift;\n            (_a = node.selfEdges) === null || _a === void 0 ? void 0 : _a.forEach(function (selfEdge) {\n                (0, util_1.addDummyNode)(g, \"selfedge\", {\n                    width: selfEdge.label.width,\n                    height: selfEdge.label.height,\n                    rank: node.rank,\n                    order: i + ++orderShift,\n                    e: selfEdge.e,\n                    label: selfEdge.label,\n                }, \"_se\");\n            });\n            delete node.selfEdges;\n        });\n    });\n};\nvar positionSelfEdges = function (g) {\n    g.nodes().forEach(function (v) {\n        var node = g.node(v);\n        if (node.dummy === \"selfedge\") {\n            var selfNode = g.node(node.e.v);\n            var x = selfNode.x + selfNode.width / 2;\n            var y = selfNode.y;\n            var dx = node.x - x;\n            var dy = selfNode.height / 2;\n            g.setEdgeObj(node.e, node.label);\n            g.removeNode(v);\n            node.label.points = [\n                { x: x + (2 * dx) / 3, y: y - dy },\n                { x: x + (5 * dx) / 6, y: y - dy },\n                { y: y, x: x + dx },\n                { x: x + (5 * dx) / 6, y: y + dy },\n                { x: x + (2 * dx) / 3, y: y + dy },\n            ];\n            node.label.x = node.x;\n            node.label.y = node.y;\n        }\n    });\n};\nvar selectNumberAttrs = function (obj, attrs) {\n    var pickedProperties = {};\n    attrs === null || attrs === void 0 ? void 0 : attrs.forEach(function (key) {\n        if (obj[key] === undefined)\n            return;\n        pickedProperties[key] = (+obj[key]);\n    });\n    return pickedProperties;\n};\nvar canonicalize = function (attrs) {\n    if (attrs === void 0) { attrs = {}; }\n    var newAttrs = {};\n    Object.keys(attrs).forEach(function (k) {\n        newAttrs[k.toLowerCase()] = attrs[k];\n    });\n    return newAttrs;\n};\nexports.default = layout;\n"},"sourceMaps":{"js":{"version":3,"file":"layout.js","sourceRoot":"","sources":["../../../../src/layout/dagre/src/layout.ts"],"names":[],"mappings":"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","sourcesContent":["import acyclic from \"./acyclic\";\nimport normalize from \"./normalize\";\nimport rank from \"./rank\";\nimport {\n  normalizeRanks,\n  removeEmptyRanks,\n  time as usetime,\n  notime,\n  asNonCompoundGraph,\n  addDummyNode,\n  intersectRect,\n  buildLayerMatrix,\n} from \"./util\";\nimport parentDummyChains from \"./parent-dummy-chains\";\nimport nestingGraph from \"./nesting-graph\";\nimport addBorderSegments from \"./add-border-segments\";\nimport coordinateSystem from \"./coordinate-system\";\nimport order from \"./order\";\nimport position from \"./position\";\nimport initDataOrder from \"./order/init-data-order\";\nimport { Graph, Node } from \"../graph\";\n\nconst layout = (g: Graph, opts?: any) => {\n  const time = opts && opts.debugTiming ? usetime : notime;\n  time(\"layout\", () => {\n    // 如果在原图基础上修改，继承原图的order结果\n    if (opts && !opts.keepNodeOrder && opts.prevGraph) {\n      time(\"  inheritOrder\", () => {\n        inheritOrder(g, opts.prevGraph);\n      });\n    }\n    const layoutGraph: any = time(\"  buildLayoutGraph\", () => {\n      return buildLayoutGraph(g);\n    });\n    // 控制是否为边的label留位置（这会影响是否在边中间添加dummy node）\n    if (!(opts && opts.edgeLabelSpace === false)) {\n      time(\"  makeSpaceForEdgeLabels\", () => {\n        makeSpaceForEdgeLabels(layoutGraph);\n      });\n    }\n    // TODO: 暂时处理层级设置不正确时的异常报错，提示设置正确的层级\n    try {\n      time(\"  runLayout\", () => {\n        runLayout(layoutGraph, time, opts);\n      });\n    } catch (e) {\n      if (\n        e.message ===\n        \"Not possible to find intersection inside of the rectangle\"\n      ) {\n        console.error(\n          \"The following error may be caused by improper layer setting, please make sure your manual layer setting does not violate the graph's structure:\\n\",\n          e\n        );\n        return;\n      }\n      throw e;\n    }\n    time(\"  updateInputGraph\", () => {\n      updateInputGraph(g, layoutGraph);\n    });\n  });\n};\n\nconst runLayout = (g: Graph, time: any, opts: any) => {\n  time(\"    removeSelfEdges\", () => {\n    removeSelfEdges(g);\n  });\n  time(\"    acyclic\", () => {\n    acyclic.run(g);\n  });\n  time(\"    nestingGraph.run\", () => {\n    nestingGraph.run(g);\n  });\n  time(\"    rank\", () => {\n    rank(asNonCompoundGraph(g));\n  });\n  time(\"    injectEdgeLabelProxies\", () => {\n    injectEdgeLabelProxies(g);\n  });\n  time(\"    removeEmptyRanks\", () => {\n    removeEmptyRanks(g);\n  });\n  time(\"    nestingGraph.cleanup\", () => {\n    nestingGraph.cleanup(g);\n  });\n  time(\"    normalizeRanks\", () => {\n    normalizeRanks(g);\n  });\n  time(\"    assignRankMinMax\", () => {\n    assignRankMinMax(g);\n  });\n  time(\"    removeEdgeLabelProxies\", () => {\n    removeEdgeLabelProxies(g);\n  });\n  time(\"    normalize.run\", () => {\n    normalize.run(g);\n  });\n  time(\"    parentDummyChains\", () => {\n    parentDummyChains(g);\n  });\n  time(\"    addBorderSegments\", () => {\n    addBorderSegments(g);\n  });\n  if (opts && opts.keepNodeOrder) {\n    time(\"    initDataOrder\", () => {\n      initDataOrder(g, opts.nodeOrder);\n    });\n  }\n  time(\"    order\", () => {\n    order(g);\n  });\n  time(\"    insertSelfEdges\", () => {\n    insertSelfEdges(g);\n  });\n  time(\"    adjustCoordinateSystem\", () => {\n    coordinateSystem.adjust(g);\n  });\n  time(\"    position\", () => {\n    position(g);\n  });\n  time(\"    positionSelfEdges\", () => {\n    positionSelfEdges(g);\n  });\n  time(\"    removeBorderNodes\", () => {\n    removeBorderNodes(g);\n  });\n  time(\"    normalize.undo\", () => {\n    normalize.undo(g);\n  });\n  time(\"    fixupEdgeLabelCoords\", () => {\n    fixupEdgeLabelCoords(g);\n  });\n  time(\"    undoCoordinateSystem\", () => {\n    coordinateSystem.undo(g);\n  });\n  time(\"    translateGraph\", () => {\n    translateGraph(g);\n  });\n  time(\"    assignNodeIntersects\", () => {\n    assignNodeIntersects(g);\n  });\n  time(\"    reversePoints\", () => {\n    reversePointsForReversedEdges(g);\n  });\n  time(\"    acyclic.undo\", () => {\n    acyclic.undo(g);\n  });\n};\n\n/**\n * 继承上一个布局中的order，防止翻转\n * TODO: 暂时没有考虑涉及层级变动的布局，只保证原来布局层级和相对顺序不变\n */\nconst inheritOrder = (currG: Graph, prevG: Graph) => {\n  currG.nodes().forEach((n: string) => {\n    const node = currG.node(n)!;\n    const prevNode = prevG.node(n)!;\n    if (prevNode !== undefined) {\n      node.fixorder = prevNode._order;\n      delete prevNode._order;\n    } else {\n      delete node.fixorder;\n    }\n  });\n};\n\n/*\n * Copies final layout information from the layout graph back to the input\n * graph. This process only copies whitelisted attributes from the layout graph\n * to the input graph, so it serves as a good place to determine what\n * attributes can influence layout.\n */\nconst updateInputGraph = (inputGraph: Graph, layoutGraph: Graph) => {\n  inputGraph.nodes().forEach((v) => {\n    const inputLabel = inputGraph.node(v);\n\n    if (inputLabel) {\n      const layoutLabel = layoutGraph.node(v)!;\n      inputLabel.x = layoutLabel.x;\n      inputLabel.y = layoutLabel.y;\n      inputLabel._order = layoutLabel.order;\n      inputLabel._rank = layoutLabel.rank;\n\n      if (layoutGraph.children(v)?.length) {\n        inputLabel.width = layoutLabel.width;\n        inputLabel.height = layoutLabel.height;\n      }\n    }\n  });\n\n  inputGraph.edges().forEach((e) => {\n    const inputLabel = inputGraph.edge(e)!;\n    const layoutLabel = layoutGraph.edge(e)!;\n\n    inputLabel.points = layoutLabel ? layoutLabel.points : [];\n    if (layoutLabel && layoutLabel.hasOwnProperty(\"x\")) {\n      inputLabel.x = layoutLabel.x;\n      inputLabel.y = layoutLabel.y;\n    }\n  });\n\n  inputGraph.graph().width = layoutGraph.graph().width;\n  inputGraph.graph().height = layoutGraph.graph().height;\n};\n\nconst graphNumAttrs = [\"nodesep\", \"edgesep\", \"ranksep\", \"marginx\", \"marginy\"];\nconst graphDefaults = { ranksep: 50, edgesep: 20, nodesep: 50, rankdir: \"tb\" };\nconst graphAttrs = [\"acyclicer\", \"ranker\", \"rankdir\", \"align\"];\nconst nodeNumAttrs = [\"width\", \"height\", \"layer\", \"fixorder\"]; // 需要传入layer, fixOrder作为参数参考\nconst nodeDefaults = { width: 0, height: 0 };\nconst edgeNumAttrs = [\"minlen\", \"weight\", \"width\", \"height\", \"labeloffset\"];\nconst edgeDefaults = {\n  minlen: 1,\n  weight: 1,\n  width: 0,\n  height: 0,\n  labeloffset: 10,\n  labelpos: \"r\",\n};\nconst edgeAttrs = [\"labelpos\"];\n\n/*\n * Constructs a new graph from the input graph, which can be used for layout.\n * This process copies only whitelisted attributes from the input graph to the\n * layout graph. Thus this function serves as a good place to determine what\n * attributes can influence layout.\n */\nconst buildLayoutGraph = (inputGraph: Graph) => {\n  const g = new Graph({ multigraph: true, compound: true });\n  const graph = canonicalize(inputGraph.graph());\n\n  const pickedProperties: any = {};\n  graphAttrs?.forEach((key) => {\n    if (graph[key] !== undefined) pickedProperties[key] = graph[key];\n  });\n\n  g.setGraph(\n    Object.assign(\n      {},\n      graphDefaults,\n      selectNumberAttrs(graph, graphNumAttrs),\n      pickedProperties\n    )\n  );\n\n  inputGraph.nodes().forEach((v) => {\n    const node = canonicalize(inputGraph.node(v));\n    const defaultNode = {\n      ...nodeDefaults,\n      ...node,\n    } as Node;\n    const defaultAttrs = selectNumberAttrs(defaultNode, nodeNumAttrs) as Node;\n\n    g.setNode(v, defaultAttrs);\n    g.setParent(v, inputGraph.parent(v));\n  });\n\n  inputGraph.edges().forEach((e) => {\n    const edge = canonicalize(inputGraph.edge(e));\n\n    const pickedProperties: any = {};\n    edgeAttrs?.forEach((key) => {\n      if (edge[key] !== undefined) pickedProperties[key] = edge[key];\n    });\n\n    g.setEdgeObj(\n      e,\n      Object.assign(\n        {},\n        edgeDefaults,\n        selectNumberAttrs(edge, edgeNumAttrs),\n        pickedProperties\n      )\n    );\n  });\n\n  return g;\n};\n\n/*\n * This idea comes from the Gansner paper: to account for edge labels in our\n * layout we split each rank in half by doubling minlen and halving ranksep.\n * Then we can place labels at these mid-points between nodes.\n *\n * We also add some minimal padding to the width to push the label for the edge\n * away from the edge itself a bit.\n */\nconst makeSpaceForEdgeLabels = (g: Graph) => {\n  const graph = g.graph();\n  if (!graph.ranksep) graph.ranksep = 0;\n  graph.ranksep /= 2;\n  g.nodes().forEach((n) => {\n    const node = g.node(n)!;\n    if (!isNaN(node.layer as any)) {\n      if (!node.layer) node.layer = 0;\n    }\n  });\n  g.edges().forEach((e) => {\n    const edge = g.edge(e)!;\n    edge.minlen! *= 2;\n    if (edge.labelpos?.toLowerCase() !== \"c\") {\n      if (graph.rankdir === \"TB\" || graph.rankdir === \"BT\") {\n        edge.width += edge.labeloffset;\n      } else {\n        edge.height += edge.labeloffset;\n      }\n    }\n  });\n};\n\n/*\n * Creates temporary dummy nodes that capture the rank in which each edge's\n * label is going to, if it has one of non-zero width and height. We do this\n * so that we can safely remove empty ranks while preserving balance for the\n * label's position.\n */\nconst injectEdgeLabelProxies = (g: Graph) => {\n  g.edges().forEach((e) => {\n    const edge = g.edge(e)!;\n    if (edge.width && edge.height) {\n      const v = g.node(e.v)!;\n      const w = g.node(e.w)!;\n      const label = {\n        e,\n        rank:\n          ((w.rank as number) - (v.rank as number)) / 2 + (v.rank as number),\n      };\n      addDummyNode(g, \"edge-proxy\", label, \"_ep\");\n    }\n  });\n};\n\nconst assignRankMinMax = (g: Graph) => {\n  let maxRank = 0;\n  g.nodes().forEach((v) => {\n    const node = g.node(v)!;\n    if (node.borderTop) {\n      node.minRank = g.node(node.borderTop)?.rank;\n      node.maxRank = g.node(node.borderBottom)?.rank;\n      maxRank = Math.max(maxRank, node.maxRank || -Infinity);\n    }\n  });\n  g.graph().maxRank = maxRank;\n};\n\nconst removeEdgeLabelProxies = (g: Graph) => {\n  g.nodes().forEach((v) => {\n    const node = g.node(v)!;\n    if (node.dummy === \"edge-proxy\") {\n      g.edge((node as any).e)!.labelRank = node.rank;\n      g.removeNode(v);\n    }\n  });\n};\n\nconst translateGraph = (g: Graph) => {\n  let minX: number;\n  let maxX = 0;\n  let minY: number;\n  let maxY = 0;\n  const graphLabel = g.graph();\n  const marginX = graphLabel.marginx || 0;\n  const marginY = graphLabel.marginy || 0;\n\n  const getExtremes = (attrs: any) => {\n    if (!attrs) return;\n    const x = attrs.x;\n    const y = attrs.y;\n    const w = attrs.width;\n    const h = attrs.height;\n    if (!isNaN(x) && !isNaN(w)) {\n      if (minX === undefined) {\n        minX = x - w / 2;\n      }\n      minX = Math.min(minX, x - w / 2);\n      maxX = Math.max(maxX, x + w / 2);\n    }\n    if (!isNaN(y) && !isNaN(h)) {\n      if (minY === undefined) {\n        minY = y - h / 2;\n      }\n      minY = Math.min(minY, y - h / 2);\n      maxY = Math.max(maxY, y + h / 2);\n    }\n  };\n\n  g.nodes().forEach((v) => {\n    getExtremes(g.node(v));\n  });\n  g.edges().forEach((e) => {\n    const edge = g.edge(e)!;\n    if (edge?.hasOwnProperty(\"x\")) {\n      getExtremes(edge);\n    }\n  });\n\n  minX! -= marginX;\n  minY! -= marginY;\n\n  g.nodes().forEach((v) => {\n    const node = g.node(v);\n    if (node) {\n      node.x! -= minX;\n      node.y! -= minY;\n    }\n  });\n\n  g.edges().forEach((e) => {\n    const edge = g.edge(e)!;\n    edge.points?.forEach((p) => {\n      p.x -= minX;\n      p.y -= minY;\n    });\n    if (edge.hasOwnProperty(\"x\")) {\n      edge.x -= minX;\n    }\n    if (edge.hasOwnProperty(\"y\")) {\n      edge.y -= minY;\n    }\n  });\n\n  graphLabel.width = maxX - minX! + marginX;\n  graphLabel.height = maxY - minY! + marginY;\n};\n\nconst assignNodeIntersects = (g: Graph) => {\n  g.edges().forEach((e) => {\n    const edge = g.edge(e)!;\n    const nodeV = g.node(e.v)!;\n    const nodeW = g.node(e.w)!;\n    let p1;\n    let p2;\n    if (!edge.points) {\n      edge.points = [];\n      p1 = nodeW;\n      p2 = nodeV;\n    } else {\n      p1 = edge.points[0];\n      p2 = edge.points[edge.points.length - 1];\n    }\n    edge.points.unshift(intersectRect(nodeV, p1));\n    edge.points.push(intersectRect(nodeW, p2));\n  });\n};\n\nconst fixupEdgeLabelCoords = (g: Graph) => {\n  g.edges().forEach((e) => {\n    const edge = g.edge(e)!;\n    if (edge?.hasOwnProperty(\"x\")) {\n      if (edge.labelpos === \"l\" || edge.labelpos === \"r\") {\n        edge.width! -= edge.labeloffset;\n      }\n      switch (edge.labelpos) {\n        case \"l\":\n          edge.x -= edge.width! / 2 + edge.labeloffset;\n          break;\n        case \"r\":\n          edge.x += edge.width! / 2 + edge.labeloffset;\n          break;\n      }\n    }\n  });\n};\n\nconst reversePointsForReversedEdges = (g: Graph) => {\n  g.edges().forEach((e) => {\n    const edge = g.edge(e)!;\n    if (edge.reversed) {\n      edge.points?.reverse();\n    }\n  });\n};\n\nconst removeBorderNodes = (g: Graph) => {\n  g.nodes().forEach((v) => {\n    if (g.children(v)?.length) {\n      const node = g.node(v)!;\n      const t = g.node(node.borderTop);\n      const b = g.node(node.borderBottom);\n      const l = g.node(node.borderLeft[node.borderLeft?.length - 1]);\n      const r = g.node(node.borderRight[node.borderRight?.length - 1]);\n\n      node.width = Math.abs(r?.x! - l?.x!) || 10;\n      node.height = Math.abs(b?.y! - t?.y!) || 10;\n      node.x = (l?.x || 0) + node.width / 2;\n      node.y = (t?.y || 0) + node.height / 2;\n    }\n  });\n\n  g.nodes().forEach((v) => {\n    if (g.node(v)?.dummy === \"border\") {\n      g.removeNode(v);\n    }\n  });\n};\n\nconst removeSelfEdges = (g: Graph) => {\n  g.edges().forEach((e) => {\n    if (e.v === e.w) {\n      const node = g.node(e.v)!;\n      if (!node.selfEdges) {\n        node.selfEdges = [];\n      }\n      node.selfEdges.push({ e, label: g.edge(e) });\n      g.removeEdgeObj(e);\n    }\n  });\n};\n\nconst insertSelfEdges = (g: Graph) => {\n  const layers = buildLayerMatrix(g);\n  layers?.forEach((layer: string[]) => {\n    let orderShift = 0;\n    layer?.forEach((v: string, i: number) => {\n      const node = g.node(v)!;\n      node.order = i + orderShift;\n      node.selfEdges?.forEach((selfEdge: any) => {\n        addDummyNode(\n          g,\n          \"selfedge\",\n          {\n            width: selfEdge.label.width,\n            height: selfEdge.label.height,\n            rank: node.rank,\n            order: i + ++orderShift,\n            e: selfEdge.e,\n            label: selfEdge.label,\n          },\n          \"_se\"\n        );\n      });\n      delete node.selfEdges;\n    });\n  });\n};\n\nconst positionSelfEdges = (g: Graph) => {\n  g.nodes().forEach((v) => {\n    const node = g.node(v)!;\n    if (node.dummy === \"selfedge\") {\n      const selfNode = g.node(node.e.v)!;\n      const x = selfNode.x! + selfNode.width! / 2;\n      const y = selfNode.y!;\n      const dx = node.x! - x;\n      const dy = selfNode.height! / 2;\n      g.setEdgeObj(node.e, node.label);\n      g.removeNode(v);\n      node.label.points = [\n        { x: x + (2 * dx) / 3, y: y - dy },\n        { x: x + (5 * dx) / 6, y: y - dy },\n        { y, x: x + dx },\n        { x: x + (5 * dx) / 6, y: y + dy },\n        { x: x + (2 * dx) / 3, y: y + dy },\n      ];\n      node.label.x = node.x;\n      node.label.y = node.y;\n    }\n  });\n};\n\nconst selectNumberAttrs = (obj: Record<string, any>, attrs: string[]) => {\n  const pickedProperties: Record<string, any> = {};\n  attrs?.forEach((key: string) => {\n    if (obj[key] === undefined) return;\n    pickedProperties[key] = (+obj[key]);\n  });\n  return pickedProperties;\n};\n\nconst canonicalize = (attrs: Record<string, any> = {}) => {\n  const newAttrs: Record<string, any> = {};\n  Object.keys(attrs).forEach((k: string) => {\n    newAttrs[k.toLowerCase()] = attrs[k];\n  });\n  return newAttrs;\n};\n\nexport default layout;\n"]}},"error":null,"hash":"3db375274f7f83d3936591512018eac6","cacheData":{"env":{}}}