{"id":"node_modules/@antv/layout/lib/layout/radial/mds.js","dependencies":[{"name":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\lib\\layout\\radial\\mds.js.map","includedInParent":true,"mtime":499162500000},{"name":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\src\\layout\\radial\\mds.ts","includedInParent":true,"mtime":499162500000},{"name":"D:\\myData\\前端\\doing\\AutoPL\\package.json","includedInParent":true,"mtime":1674182060254},{"name":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\package.json","includedInParent":true,"mtime":1674179681168},{"name":"ml-matrix","loc":{"line":3,"column":26,"index":103},"parent":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\lib\\layout\\radial\\mds.js","resolved":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\ml-matrix\\src\\index.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ml_matrix_1 = require(\"ml-matrix\");\nvar MDS = /** @class */ (function () {\n    function MDS(params) {\n        this.distances = params.distances;\n        this.dimension = params.dimension || 2;\n        this.linkDistance = params.linkDistance;\n    }\n    MDS.prototype.layout = function () {\n        var self = this;\n        var dimension = self.dimension, distances = self.distances, linkDistance = self.linkDistance;\n        try {\n            // square distances\n            var M = ml_matrix_1.Matrix.mul(ml_matrix_1.Matrix.pow(distances, 2), -0.5);\n            // double centre the rows/columns\n            var rowMeans = M.mean('row');\n            var colMeans = M.mean('column');\n            var totalMean = M.mean();\n            M.add(totalMean).subRowVector(rowMeans).subColumnVector(colMeans);\n            // take the SVD of the double centred matrix, and return the\n            // points from it\n            var ret = new ml_matrix_1.SingularValueDecomposition(M);\n            var eigenValues_1 = ml_matrix_1.Matrix.sqrt(ret.diagonalMatrix).diagonal();\n            return ret.leftSingularVectors.toJSON().map(function (row) {\n                return ml_matrix_1.Matrix.mul([row], [eigenValues_1]).toJSON()[0].splice(0, dimension);\n            });\n        }\n        catch (_a) {\n            var res = [];\n            for (var i = 0; i < distances.length; i++) {\n                var x = Math.random() * linkDistance;\n                var y = Math.random() * linkDistance;\n                res.push([x, y]);\n            }\n            return res;\n        }\n    };\n    return MDS;\n}());\nexports.default = MDS;\n"},"sourceMaps":{"js":{"version":3,"file":"mds.js","sourceRoot":"","sources":["../../../src/layout/radial/mds.ts"],"names":[],"mappings":";;AACA,uCAA2E;AAE3E;IAUE,aAAY,MAAyE;QACnF,IAAI,CAAC,SAAS,GAAG,MAAM,CAAC,SAAS,CAAC;QAClC,IAAI,CAAC,SAAS,GAAG,MAAM,CAAC,SAAS,IAAI,CAAC,CAAC;QACvC,IAAI,CAAC,YAAY,GAAG,MAAM,CAAC,YAAY,CAAC;IAC1C,CAAC;IAEM,oBAAM,GAAb;QACE,IAAM,IAAI,GAAG,IAAI,CAAC;QACV,IAAA,SAAS,GAA8B,IAAI,UAAlC,EAAE,SAAS,GAAmB,IAAI,UAAvB,EAAE,YAAY,GAAK,IAAI,aAAT,CAAU;QAEpD,IAAI;YACF,mBAAmB;YACnB,IAAM,CAAC,GAAG,kBAAQ,CAAC,GAAG,CAAC,kBAAQ,CAAC,GAAG,CAAC,SAAS,EAAE,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC;YAEzD,iCAAiC;YACjC,IAAM,QAAQ,GAAG,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YAC/B,IAAM,QAAQ,GAAG,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YAClC,IAAM,SAAS,GAAG,CAAC,CAAC,IAAI,EAAE,CAAC;YAC3B,CAAC,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC,eAAe,CAAC,QAAQ,CAAC,CAAC;YAElE,4DAA4D;YAC5D,iBAAiB;YACjB,IAAM,GAAG,GAAG,IAAI,sCAA0B,CAAC,CAAC,CAAC,CAAC;YAC9C,IAAM,aAAW,GAAG,kBAAQ,CAAC,IAAI,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC,QAAQ,EAAE,CAAC;YACjE,OAAO,GAAG,CAAC,mBAAmB,CAAC,MAAM,EAAE,CAAC,GAAG,CAAC,UAAC,GAAa;gBACxD,OAAO,kBAAQ,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC,aAAW,CAAC,CAAC,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,EAAE,SAAS,CAAe,CAAC;YAC3F,CAAC,CAAC,CAAC;SACJ;QAAC,WAAM;YACN,IAAM,GAAG,GAAiB,EAAE,CAAC;YAC7B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,SAAS,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBACzC,IAAM,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,GAAG,YAAY,CAAC;gBACvC,IAAM,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,GAAG,YAAY,CAAC;gBACvC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;aAClB;YACD,OAAO,GAAG,CAAC;SACZ;IACH,CAAC;IACH,UAAC;AAAD,CAAC,AA/CD,IA+CC","sourcesContent":["import { PointTuple, Matrix } from '../types';\nimport { Matrix as MLMatrix, SingularValueDecomposition } from 'ml-matrix';\n\nexport default class MDS {\n  /** distance matrix */\n  public distances: Matrix[];\n\n  /** dimensions */\n  public dimension: number;\n\n  /** link distance */\n  public linkDistance: number;\n\n  constructor(params: { distances: Matrix[]; dimension?: number; linkDistance: number }) {\n    this.distances = params.distances;\n    this.dimension = params.dimension || 2;\n    this.linkDistance = params.linkDistance;\n  }\n\n  public layout(): PointTuple[] {\n    const self = this;\n    const { dimension, distances, linkDistance } = self;\n\n    try {\n      // square distances\n      const M = MLMatrix.mul(MLMatrix.pow(distances, 2), -0.5);\n\n      // double centre the rows/columns\n      const rowMeans = M.mean('row');\n      const colMeans = M.mean('column');\n      const totalMean = M.mean();\n      M.add(totalMean).subRowVector(rowMeans).subColumnVector(colMeans);\n\n      // take the SVD of the double centred matrix, and return the\n      // points from it\n      const ret = new SingularValueDecomposition(M);\n      const eigenValues = MLMatrix.sqrt(ret.diagonalMatrix).diagonal();\n      return ret.leftSingularVectors.toJSON().map((row: number[]) => {\n        return MLMatrix.mul([row], [eigenValues]).toJSON()[0].splice(0, dimension) as PointTuple;\n      });\n    } catch {\n      const res: PointTuple[] = [];\n      for (let i = 0; i < distances.length; i++) {\n        const x = Math.random() * linkDistance;\n        const y = Math.random() * linkDistance;\n        res.push([x, y]);\n      }\n      return res;\n    }\n  }\n}\n"]}},"error":null,"hash":"ed14654058384e068f0fe011657e04a9","cacheData":{"env":{}}}