{"id":"node_modules/@antv/layout/lib/layout/dagre/src/rank/index.js","dependencies":[{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\rank\\index.js.map","includedInParent":true,"mtime":1676178923687},{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\src\\layout\\dagre\\src\\rank\\index.ts","includedInParent":true,"mtime":1676178923968},{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\package.json","includedInParent":true,"mtime":1676178924413},{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\package.json","includedInParent":true,"mtime":1676178923486},{"name":"./util","loc":{"line":11,"column":21,"index":469},"parent":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\rank\\index.js","resolved":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\rank\\util.js"},{"name":"./feasible-tree","loc":{"line":12,"column":30,"index":510},"parent":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\rank\\index.js","resolved":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\rank\\feasible-tree.js"},{"name":"./network-simplex","loc":{"line":13,"column":48,"index":578},"parent":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\rank\\index.js","resolved":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\rank\\network-simplex.js"}],"generated":{"js":"\"use strict\";\n// \"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// var rankUtil = require(\"./util\");\n// var longestPath = rankUtil.longestPathWithLayer;\n// var feasibleTree = require(\"./feasible-tree\").feasibleTreeWithLayer;\n// var networkSimplex = require(\"./network-simplex\");\nvar util_1 = require(\"./util\");\nvar feasible_tree_1 = require(\"./feasible-tree\");\nvar network_simplex_1 = __importDefault(require(\"./network-simplex\"));\n/*\n * Assigns a rank to each node in the input graph that respects the \"minlen\"\n * constraint specified on edges between nodes.\n *\n * This basic structure is derived from Gansner, et al., \"A Technique for\n * Drawing Directed Graphs.\"\n *\n * Pre-conditions:\n *\n *    1. Graph must be a connected DAG\n *    2. Graph nodes must be objects\n *    3. Graph edges must have \"weight\" and \"minlen\" attributes\n *\n * Post-conditions:\n *\n *    1. Graph nodes will have a \"rank\" attribute based on the results of the\n *       algorithm. Ranks can start at any index (including negative), we'll\n *       fix them up later.\n */\nvar rank = function (g) {\n    switch (g.graph().ranker) {\n        case \"network-simplex\":\n            networkSimplexRanker(g);\n            break;\n        case \"tight-tree\":\n            tightTreeRanker(g);\n            break;\n        case \"longest-path\":\n            longestPathRanker(g);\n            break;\n        // default: networkSimplexRanker(g);\n        default: tightTreeRanker(g);\n    }\n};\n// A fast and simple ranker, but results are far from optimal.\nvar longestPathRanker = util_1.longestPath;\nvar tightTreeRanker = function (g) {\n    (0, util_1.longestPathWithLayer)(g);\n    (0, feasible_tree_1.feasibleTreeWithLayer)(g);\n};\nvar networkSimplexRanker = function (g) {\n    (0, network_simplex_1.default)(g);\n};\nexports.default = rank;\n"},"sourceMaps":{"js":{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../../../src/layout/dagre/src/rank/index.ts"],"names":[],"mappings":";AAAA,gBAAgB;;;;;AAEhB,oCAAoC;AACpC,mDAAmD;AACnD,uEAAuE;AACvE,qDAAqD;AAErD,+BAA2D;AAC3D,iDAAwE;AACxE,sEAA+C;AAG/C;;;;;;;;;;;;;;;;;;GAkBG;AACH,IAAM,IAAI,GAAG,UAAC,CAAQ;IACpB,QAAO,CAAC,CAAC,KAAK,EAAE,CAAC,MAAM,EAAE;QACzB,KAAK,iBAAiB;YAAE,oBAAoB,CAAC,CAAC,CAAC,CAAC;YAAC,MAAM;QACvD,KAAK,YAAY;YAAE,eAAe,CAAC,CAAC,CAAC,CAAC;YAAC,MAAM;QAC7C,KAAK,cAAc;YAAE,iBAAiB,CAAC,CAAC,CAAC,CAAC;YAAC,MAAM;QACjD,oCAAoC;QACpC,OAAO,CAAC,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC;KAC3B;AACH,CAAC,CAAC;AAEF,8DAA8D;AAC9D,IAAM,iBAAiB,GAAG,kBAAW,CAAC;AAEtC,IAAM,eAAe,GAAG,UAAC,CAAQ;IAC/B,IAAA,2BAAoB,EAAC,CAAC,CAAC,CAAC;IACxB,IAAA,qCAAY,EAAC,CAAC,CAAC,CAAC;AAClB,CAAC,CAAC;AAEF,IAAM,oBAAoB,GAAG,UAAC,CAAQ;IACpC,IAAA,yBAAc,EAAC,CAAC,CAAC,CAAC;AACpB,CAAC,CAAC;AAEF,kBAAe,IAAI,CAAC","sourcesContent":["// \"use strict\";\n\n// var rankUtil = require(\"./util\");\n// var longestPath = rankUtil.longestPathWithLayer;\n// var feasibleTree = require(\"./feasible-tree\").feasibleTreeWithLayer;\n// var networkSimplex = require(\"./network-simplex\");\n\nimport { longestPath, longestPathWithLayer } from './util';\nimport { feasibleTreeWithLayer as feasibleTree } from './feasible-tree';\nimport networkSimplex from './network-simplex';\nimport { Graph } from '../../graph';\n\n/*\n * Assigns a rank to each node in the input graph that respects the \"minlen\"\n * constraint specified on edges between nodes.\n *\n * This basic structure is derived from Gansner, et al., \"A Technique for\n * Drawing Directed Graphs.\"\n *\n * Pre-conditions:\n *\n *    1. Graph must be a connected DAG\n *    2. Graph nodes must be objects\n *    3. Graph edges must have \"weight\" and \"minlen\" attributes\n *\n * Post-conditions:\n *\n *    1. Graph nodes will have a \"rank\" attribute based on the results of the\n *       algorithm. Ranks can start at any index (including negative), we'll\n *       fix them up later.\n */\nconst rank = (g: Graph) => {\n  switch(g.graph().ranker) {\n  case \"network-simplex\": networkSimplexRanker(g); break;\n  case \"tight-tree\": tightTreeRanker(g); break;\n  case \"longest-path\": longestPathRanker(g); break;\n  // default: networkSimplexRanker(g);\n  default: tightTreeRanker(g);\n  }\n};\n\n// A fast and simple ranker, but results are far from optimal.\nconst longestPathRanker = longestPath;\n\nconst tightTreeRanker = (g: Graph) => {\n  longestPathWithLayer(g);\n  feasibleTree(g);\n};\n\nconst networkSimplexRanker = (g: Graph) => {\n  networkSimplex(g);\n};\n\nexport default rank;"]}},"error":null,"hash":"1e6183222af3ef9cef525ba4c811e84e","cacheData":{"env":{}}}