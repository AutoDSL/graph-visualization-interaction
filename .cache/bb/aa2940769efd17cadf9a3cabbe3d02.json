{"id":"node_modules/@antv/layout/lib/layout/dagre/src/parent-dummy-chains.js","dependencies":[{"name":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\parent-dummy-chains.js.map","includedInParent":true,"mtime":499162500000},{"name":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\src\\layout\\dagre\\src\\parent-dummy-chains.ts","includedInParent":true,"mtime":499162500000},{"name":"D:\\myData\\前端\\doing\\AutoPL\\package.json","includedInParent":true,"mtime":1674182060254},{"name":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\package.json","includedInParent":true,"mtime":1674179681168}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// deep first search with both order low for pre, lim for post\nvar dfsBothOrder = function (g) {\n    var _a;\n    var result = {};\n    var lim = 0;\n    var dfs = function (v) {\n        var _a;\n        var low = lim;\n        (_a = g.children(v)) === null || _a === void 0 ? void 0 : _a.forEach(dfs);\n        result[v] = { low: low, lim: lim++ };\n    };\n    (_a = g.children()) === null || _a === void 0 ? void 0 : _a.forEach(dfs);\n    return result;\n};\n// Find a path from v to w through the lowest common ancestor (LCA). Return the\n// full path and the LCA.\nvar findPath = function (g, postorderNums, v, w) {\n    var vPath = [];\n    var wPath = [];\n    var low = Math.min(postorderNums[v].low, postorderNums[w].low);\n    var lim = Math.max(postorderNums[v].lim, postorderNums[w].lim);\n    var parent;\n    var lca;\n    // Traverse up from v to find the LCA\n    parent = v;\n    do {\n        parent = g.parent(parent);\n        vPath.push(parent);\n    } while (parent &&\n        (postorderNums[parent].low > low || lim > postorderNums[parent].lim));\n    lca = parent;\n    // Traverse from w to LCA\n    parent = w;\n    while (parent && parent !== lca) {\n        wPath.push(parent);\n        parent = g.parent(parent);\n    }\n    return { lca: lca, path: vPath.concat(wPath.reverse()) };\n};\nvar parentDummyChains = function (g) {\n    var _a;\n    var postorderNums = dfsBothOrder(g);\n    (_a = g.graph().dummyChains) === null || _a === void 0 ? void 0 : _a.forEach(function (startV) {\n        var _a, _b;\n        var v = startV;\n        var node = g.node(v);\n        var edgeObj = node.edgeObj;\n        if (!edgeObj)\n            return;\n        var pathData = findPath(g, postorderNums, edgeObj.v, edgeObj.w);\n        var path = pathData.path;\n        var lca = pathData.lca;\n        var pathIdx = 0;\n        var pathV = path[pathIdx];\n        var ascending = true;\n        while (v !== edgeObj.w) {\n            node = g.node(v);\n            if (ascending) {\n                while (pathV !== lca && ((_a = g.node(pathV)) === null || _a === void 0 ? void 0 : _a.maxRank) < node.rank) {\n                    pathIdx++;\n                    pathV = path[pathIdx];\n                }\n                if (pathV === lca) {\n                    ascending = false;\n                }\n            }\n            if (!ascending) {\n                while (pathIdx < path.length - 1 &&\n                    ((_b = g.node(path[pathIdx + 1])) === null || _b === void 0 ? void 0 : _b.minRank) <=\n                        node.rank) {\n                    pathIdx++;\n                }\n                pathV = path[pathIdx];\n            }\n            g.setParent(v, pathV);\n            v = g.successors(v)[0];\n        }\n    });\n};\nexports.default = parentDummyChains;\n"},"sourceMaps":{"js":{"version":3,"file":"parent-dummy-chains.js","sourceRoot":"","sources":["../../../../src/layout/dagre/src/parent-dummy-chains.ts"],"names":[],"mappings":"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","sourcesContent":["import { Graph } from \"../graph\";\n\ntype OrderItem = { low: number; lim: number };\n\n// deep first search with both order low for pre, lim for post\nconst dfsBothOrder = (g: Graph) => {\n  const result: Record<string, OrderItem> = {};\n  let lim = 0;\n\n  const dfs = (v: string) => {\n    const low = lim;\n    g.children(v)?.forEach(dfs);\n    result[v] = { low, lim: lim++ };\n  };\n  g.children()?.forEach(dfs);\n\n  return result;\n};\n\n// Find a path from v to w through the lowest common ancestor (LCA). Return the\n// full path and the LCA.\nconst findPath = (\n  g: Graph,\n  postorderNums: Record<string, OrderItem>,\n  v: string,\n  w: string\n) => {\n  const vPath = [];\n  const wPath = [];\n  const low = Math.min(postorderNums[v].low, postorderNums[w].low);\n  const lim = Math.max(postorderNums[v].lim, postorderNums[w].lim);\n  let parent: string | undefined;\n  let lca: string | undefined;\n\n  // Traverse up from v to find the LCA\n  parent = v;\n  do {\n    parent = g.parent(parent);\n    vPath.push(parent);\n  } while (\n    parent &&\n    (postorderNums[parent].low > low || lim > postorderNums[parent].lim)\n  );\n  lca = parent;\n\n  // Traverse from w to LCA\n  parent = w;\n  while (parent && parent !== lca) {\n    wPath.push(parent);\n    parent = g.parent(parent);\n  }\n\n  return { lca, path: vPath.concat(wPath.reverse()) };\n};\n\nconst parentDummyChains = (g: Graph) => {\n  const postorderNums = dfsBothOrder(g);\n\n  g.graph().dummyChains?.forEach((startV) => {\n    let v = startV; \n    let node = g.node(v)!;\n    const edgeObj = node.edgeObj;\n    if (!edgeObj) return;\n    const pathData = findPath(g, postorderNums, edgeObj.v, edgeObj.w);\n    const path = pathData.path;\n    const lca = pathData.lca;\n    let pathIdx = 0;\n    let pathV = path[pathIdx]!;\n    let ascending = true;\n\n    while (v !== edgeObj.w) {\n      node = g.node(v)!;\n\n      if (ascending) {\n        while (pathV !== lca && g.node(pathV)?.maxRank! < node.rank!) {\n          pathIdx++;\n          pathV = path[pathIdx]!;\n        }\n\n        if (pathV === lca) {\n          ascending = false;\n        }\n      }\n\n      if (!ascending) {\n        while (\n          pathIdx < path.length - 1 &&\n          (g.node(path[pathIdx + 1]!)?.minRank as number) <=\n            (node.rank as number)\n        ) {\n          pathIdx++;\n        }\n        pathV = path[pathIdx]!;\n      }\n\n      g.setParent(v, pathV);\n      v = g.successors(v)![0];\n    }\n  });\n};\n\nexport default parentDummyChains;\n"]}},"error":null,"hash":"36bdec67fb6f2198f35587e7b002aaec","cacheData":{"env":{}}}