{"id":"node_modules/@antv/layout/lib/layout/dagre/src/rank/feasible-tree.js","dependencies":[{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\rank\\feasible-tree.js.map","includedInParent":true,"mtime":1676178923615},{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\src\\layout\\dagre\\src\\rank\\feasible-tree.ts","includedInParent":true,"mtime":1676178923866},{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\package.json","includedInParent":true,"mtime":1676178924413},{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\package.json","includedInParent":true,"mtime":1676178923486},{"name":"./util","loc":{"line":4,"column":21,"index":161},"parent":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\rank\\feasible-tree.js","resolved":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\rank\\util.js"},{"name":"../util","loc":{"line":5,"column":21,"index":193},"parent":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\rank\\feasible-tree.js","resolved":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\util.js"},{"name":"../../graph","loc":{"line":6,"column":22,"index":227},"parent":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\rank\\feasible-tree.js","resolved":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\graph.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.feasibleTreeWithLayer = exports.feasibleTree = void 0;\nvar util_1 = require(\"./util\");\nvar util_2 = require(\"../util\");\nvar graph_1 = require(\"../../graph\");\n/*\n * Constructs a spanning tree with tight edges and adjusted the input node's\n * ranks to achieve this. A tight edge is one that is has a length that matches\n * its \"minlen\" attribute.\n *\n * The basic structure for this function is derived from Gansner, et al., \"A\n * Technique for Drawing Directed Graphs.\"\n *\n * Pre-conditions:\n *\n *    1. Graph must be a DAG.\n *    2. Graph must be connected.\n *    3. Graph must have at least one node.\n *    5. Graph nodes must have been previously assigned a \"rank\" property that\n *       respects the \"minlen\" property of incident edges.\n *    6. Graph edges must have a \"minlen\" property.\n *\n * Post-conditions:\n *\n *    - Graph nodes will have their rank adjusted to ensure that all edges are\n *      tight.\n *\n * Returns a tree (undirected graph) that is constructed using only \"tight\"\n * edges.\n */\nvar feasibleTree = function (g) {\n    var t = new graph_1.Graph({ directed: false });\n    // Choose arbitrary node from which to start our tree\n    var start = g.nodes()[0];\n    var size = g.nodeCount();\n    t.setNode(start, {});\n    var edge;\n    var delta;\n    while (tightTree(t, g) < size) {\n        edge = findMinSlackEdge(t, g);\n        delta = t.hasNode(edge.v) ? (0, util_1.slack)(g, edge) : -(0, util_1.slack)(g, edge);\n        shiftRanks(t, g, delta);\n    }\n    return t;\n};\nexports.feasibleTree = feasibleTree;\n/*\n * Finds a maximal tree of tight edges and returns the number of nodes in the\n * tree.\n */\nvar tightTree = function (t, g) {\n    var dfs = function (v) {\n        g.nodeEdges(v).forEach(function (e) {\n            var edgeV = e.v;\n            var w = (v === edgeV) ? e.w : edgeV;\n            if (!t.hasNode(w) && !(0, util_1.slack)(g, e)) {\n                t.setNode(w, {});\n                t.setEdge(v, w, {});\n                dfs(w);\n            }\n        });\n    };\n    t.nodes().forEach(dfs);\n    return t.nodeCount();\n};\n/*\n * Constructs a spanning tree with tight edges and adjusted the input node's\n * ranks to achieve this. A tight edge is one that is has a length that matches\n * its \"minlen\" attribute.\n *\n * The basic structure for this function is derived from Gansner, et al., \"A\n * Technique for Drawing Directed Graphs.\"\n *\n * Pre-conditions:\n *\n *    1. Graph must be a DAG.\n *    2. Graph must be connected.\n *    3. Graph must have at least one node.\n *    5. Graph nodes must have been previously assigned a \"rank\" property that\n *       respects the \"minlen\" property of incident edges.\n *    6. Graph edges must have a \"minlen\" property.\n *\n * Post-conditions:\n *\n *    - Graph nodes will have their rank adjusted to ensure that all edges are\n *      tight.\n *\n * Returns a tree (undirected graph) that is constructed using only \"tight\"\n * edges.\n */\nvar feasibleTreeWithLayer = function (g) {\n    var t = new graph_1.Graph({ directed: false });\n    // Choose arbitrary node from which to start our tree\n    var start = g.nodes()[0];\n    var size = g.nodes().filter(function (n) { return !!g.node(n); }).length;\n    t.setNode(start, {});\n    var edge;\n    var delta;\n    while (tightTreeWithLayer(t, g) < size) {\n        edge = findMinSlackEdge(t, g);\n        delta = t.hasNode(edge.v) ? (0, util_1.slack)(g, edge) : -(0, util_1.slack)(g, edge);\n        shiftRanks(t, g, delta);\n    }\n    return t;\n};\nexports.feasibleTreeWithLayer = feasibleTreeWithLayer;\n/*\n * Finds a maximal tree of tight edges and returns the number of nodes in the\n * tree.\n */\nvar tightTreeWithLayer = function (t, g) {\n    var dfs = function (v) {\n        var _a;\n        (_a = g.nodeEdges(v)) === null || _a === void 0 ? void 0 : _a.forEach(function (e) {\n            var edgeV = e.v;\n            var w = (v === edgeV) ? e.w : edgeV;\n            // 对于指定layer的，直接加入tight-tree，不参与调整\n            if (!t.hasNode(w) && (g.node(w).layer !== undefined || !(0, util_1.slack)(g, e))) {\n                t.setNode(w, {});\n                t.setEdge(v, w, {});\n                dfs(w);\n            }\n        });\n    };\n    t.nodes().forEach(dfs);\n    return t.nodeCount();\n};\n/*\n * Finds the edge with the smallest slack that is incident on tree and returns\n * it.\n */\nvar findMinSlackEdge = function (t, g) {\n    return (0, util_2.minBy)(g.edges(), function (e) {\n        if (t.hasNode(e.v) !== t.hasNode(e.w)) {\n            return (0, util_1.slack)(g, e);\n        }\n        return Infinity;\n    });\n};\nvar shiftRanks = function (t, g, delta) {\n    t.nodes().forEach(function (v) {\n        if (!g.node(v).rank)\n            g.node(v).rank = 0;\n        g.node(v).rank += delta;\n    });\n};\nexports.default = {\n    feasibleTree: feasibleTree,\n    feasibleTreeWithLayer: feasibleTreeWithLayer\n};\n"},"sourceMaps":{"js":{"version":3,"file":"feasible-tree.js","sourceRoot":"","sources":["../../../../../src/layout/dagre/src/rank/feasible-tree.ts"],"names":[],"mappings":"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","sourcesContent":["import { slack } from './util';\nimport { minBy } from '../util';\nimport { Graph } from '../../graph';\n\n/*\n * Constructs a spanning tree with tight edges and adjusted the input node's\n * ranks to achieve this. A tight edge is one that is has a length that matches\n * its \"minlen\" attribute.\n *\n * The basic structure for this function is derived from Gansner, et al., \"A\n * Technique for Drawing Directed Graphs.\"\n *\n * Pre-conditions:\n *\n *    1. Graph must be a DAG.\n *    2. Graph must be connected.\n *    3. Graph must have at least one node.\n *    5. Graph nodes must have been previously assigned a \"rank\" property that\n *       respects the \"minlen\" property of incident edges.\n *    6. Graph edges must have a \"minlen\" property.\n *\n * Post-conditions:\n *\n *    - Graph nodes will have their rank adjusted to ensure that all edges are\n *      tight.\n *\n * Returns a tree (undirected graph) that is constructed using only \"tight\"\n * edges.\n */\nconst feasibleTree = (g: Graph) => {\n  const t = new Graph({ directed: false });\n\n  // Choose arbitrary node from which to start our tree\n  const start = g.nodes()[0];\n  const size = g.nodeCount();\n  t.setNode(start, {});\n\n  let edge: any;\n  let delta: number;\n  while (tightTree(t, g) < size) {\n    edge = findMinSlackEdge(t, g);\n    delta = t.hasNode(edge.v) ? slack(g, edge) : -slack(g, edge);\n    shiftRanks(t, g, delta);\n  }\n\n  return t;\n};\n\n/*\n * Finds a maximal tree of tight edges and returns the number of nodes in the\n * tree.\n */\nconst tightTree = (t: Graph, g: Graph) => {\n  const dfs = (v: string) => {\n    g.nodeEdges(v)!.forEach((e) => {\n      const edgeV = e.v;\n      const w = (v === edgeV) ? e.w : edgeV;\n      if (!t.hasNode(w) && !slack(g, e)) {\n        t.setNode(w, {});\n        t.setEdge(v, w, {});\n        dfs(w);\n      }\n    });\n  };\n\n  t.nodes().forEach(dfs);\n  return t.nodeCount();\n};\n\n/*\n * Constructs a spanning tree with tight edges and adjusted the input node's\n * ranks to achieve this. A tight edge is one that is has a length that matches\n * its \"minlen\" attribute.\n *\n * The basic structure for this function is derived from Gansner, et al., \"A\n * Technique for Drawing Directed Graphs.\"\n *\n * Pre-conditions:\n *\n *    1. Graph must be a DAG.\n *    2. Graph must be connected.\n *    3. Graph must have at least one node.\n *    5. Graph nodes must have been previously assigned a \"rank\" property that\n *       respects the \"minlen\" property of incident edges.\n *    6. Graph edges must have a \"minlen\" property.\n *\n * Post-conditions:\n *\n *    - Graph nodes will have their rank adjusted to ensure that all edges are\n *      tight.\n *\n * Returns a tree (undirected graph) that is constructed using only \"tight\"\n * edges.\n */\nconst feasibleTreeWithLayer = (g: Graph) => {\n  const t = new Graph({ directed: false }) as any;\n\n  // Choose arbitrary node from which to start our tree\n  const start = g.nodes()[0];\n  const size = g.nodes().filter(n => !!g.node(n)).length;\n  t.setNode(start, {});\n\n  let edge: any;\n  let delta: number;\n  while (tightTreeWithLayer(t, g)! < size) {\n    edge = findMinSlackEdge(t, g);\n    delta = t.hasNode(edge.v) ? slack(g, edge) : -slack(g, edge);\n    shiftRanks(t, g, delta);\n  }\n\n  return t;\n};\n\n\n/*\n * Finds a maximal tree of tight edges and returns the number of nodes in the\n * tree.\n */\nconst tightTreeWithLayer = (t: Graph, g: Graph) => {\n  const dfs = (v: string) => {\n    g.nodeEdges(v)?.forEach((e) => {\n      const edgeV = e.v;\n      const w = (v === edgeV) ? e.w : edgeV;\n      // 对于指定layer的，直接加入tight-tree，不参与调整\n      if (!t.hasNode(w) && (g.node(w)!.layer !== undefined || !slack(g, e))) {\n        t.setNode(w, {});\n        t.setEdge(v, w, {});\n        dfs(w);\n      }\n    });\n  };\n\n  t.nodes().forEach(dfs);\n  return t.nodeCount();\n};\n\n/*\n * Finds the edge with the smallest slack that is incident on tree and returns\n * it.\n */\nconst findMinSlackEdge = (t: Graph, g: Graph) => {\n  return minBy(g.edges(), (e: any) => {\n    if (t.hasNode(e.v) !== t.hasNode(e.w)) {\n      return slack(g, e);\n    }\n    return Infinity;\n  });\n};\n\nconst shiftRanks = (t: Graph, g: Graph, delta: number) => {\n  t.nodes().forEach((v: string) => {\n    if (!g.node(v)!.rank) g.node(v)!.rank = 0;\n    (g.node(v)!.rank as number) += delta;\n  });\n};\n\nexport {\n  feasibleTree,\n  feasibleTreeWithLayer\n};\n\nexport default {\n  feasibleTree,\n  feasibleTreeWithLayer\n};"]}},"error":null,"hash":"b24a2f994f5c667f37f0470e61db3348","cacheData":{"env":{}}}