{"id":"node_modules/@antv/layout/lib/layout/dagreCompound.js","dependencies":[{"name":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\lib\\layout\\dagreCompound.js.map","includedInParent":true,"mtime":499162500000},{"name":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\src\\layout\\dagreCompound.ts","includedInParent":true,"mtime":499162500000},{"name":"D:\\myData\\前端\\doing\\AutoPL\\package.json","includedInParent":true,"mtime":1674182060254},{"name":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\package.json","includedInParent":true,"mtime":1674179681168},{"name":"./base","loc":{"line":39,"column":21,"index":1663},"parent":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\lib\\layout\\dagreCompound.js","resolved":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\lib\\layout\\base.js"},{"name":"dagre-compound","loc":{"line":40,"column":31,"index":1705},"parent":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\lib\\layout\\dagreCompound.js","resolved":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\dagre-compound\\dist\\dagre-compound.es5.js"},{"name":"../util","loc":{"line":41,"column":21,"index":1745},"parent":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\lib\\layout\\dagreCompound.js","resolved":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\lib\\util\\index.js"}],"generated":{"js":"\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DagreCompoundLayout = void 0;\nvar base_1 = require(\"./base\");\nvar dagre_compound_1 = require(\"dagre-compound\");\nvar util_1 = require(\"../util\");\nvar DagreCompoundLayout = /** @class */ (function (_super) {\n    __extends(DagreCompoundLayout, _super);\n    function DagreCompoundLayout(options) {\n        var _this = _super.call(this) || this;\n        /** layout 方向, 可选 TB, BT, LR, RL */\n        _this.rankdir = 'TB';\n        /** 节点水平间距(px) */\n        _this.nodesep = 50;\n        /** 边水平间距(px) */\n        _this.edgesep = 5;\n        /** 每一层节点之间间距 */\n        _this.ranksep = 50;\n        /** 是否保留布局连线的控制点 */\n        _this.controlPoints = true;\n        /** 是否保留使用布局计算的锚点 */\n        _this.anchorPoint = true;\n        _this.nodes = [];\n        _this.edges = [];\n        _this.combos = [];\n        /** 迭代结束的回调函数 */\n        _this.onLayoutEnd = function () { };\n        _this.updateCfg(options);\n        return _this;\n    }\n    DagreCompoundLayout.prototype.getDefaultCfg = function () {\n        return {\n            rankdir: 'TB',\n            align: undefined,\n            begin: undefined,\n            nodeSize: undefined,\n            nodesep: 50,\n            ranksep: 50,\n            controlPoints: true,\n            anchorPoint: true // 是否使用布局计算的锚点\n        };\n    };\n    DagreCompoundLayout.prototype.init = function (data) {\n        var hiddenNodes = data.hiddenNodes || []; // 被隐藏的节点\n        var hiddenEdges = data.hiddenEdges || []; // 被隐藏的边\n        var hiddenCombos = data.hiddenCombos || []; // 赋值 hiddenCombos\n        // 确保此次排序按照用户输入顺序\n        this.nodes = this.getDataByOrder((data.nodes || []).concat(hiddenNodes));\n        this.edges = this.getDataByOrder((data.edges || []).concat(hiddenEdges));\n        this.combos = (data.combos || []).concat(hiddenCombos.map(function (hc) { return (__assign(__assign({}, hc), { collapsed: true })); }));\n    };\n    DagreCompoundLayout.prototype.execute = function () {\n        var self = this;\n        var nodes = self.nodes, edges = self.edges;\n        if (!nodes)\n            return;\n        var _a = self.getLayoutConfig(), graphDef = _a.graphDef, graphOption = _a.graphOption, graphSettings = _a.graphSettings;\n        var renderInfo = (0, dagre_compound_1.buildGraph)(graphDef, graphOption, graphSettings);\n        var flattenedRenderInfo = (0, dagre_compound_1.flatGraph)(renderInfo, true); // 打平数据进行遍历\n        this.updatePosition(flattenedRenderInfo);\n        if (self.onLayoutEnd)\n            self.onLayoutEnd();\n        return {\n            nodes: nodes,\n            edges: edges\n        };\n    };\n    /**\n     * combo 模式下查找节点完整路径\n     * @param nodeId\n     * @private\n     */\n    DagreCompoundLayout.prototype.getNodePath = function (nodeId) {\n        var self = this;\n        var nodes = self.nodes, combos = self.combos;\n        var targetNode = nodes.find(function (n) { return n.id === nodeId; });\n        var findPath = function (comboId, fullPath) {\n            if (fullPath === void 0) { fullPath = []; }\n            var combo = combos.find(function (c) { return c.id === comboId; });\n            if (combo) {\n                fullPath.unshift(comboId);\n                if (combo.parentId) {\n                    return findPath(combo.parentId, fullPath);\n                }\n                return fullPath;\n            }\n            return fullPath;\n        };\n        if (targetNode && targetNode.comboId) {\n            return findPath(targetNode.comboId, [nodeId]);\n        }\n        return [nodeId];\n    };\n    /** 准备 dagre-compound 布局参数 */\n    DagreCompoundLayout.prototype.getLayoutConfig = function () {\n        var _a, _b, _c;\n        var self = this;\n        var nodes = self.nodes, edges = self.edges, combos = self.combos, nodeSize = self.nodeSize, rankdir = self.rankdir, align = self.align, edgesep = self.edgesep, nodesep = self.nodesep, ranksep = self.ranksep, settings = self.settings;\n        var compound = (combos || []).reduce(function (pre, cur) {\n            var matchedNodes = nodes.filter(function (n) { return n.comboId === cur.id; }).map(function (n) { return n.id; });\n            var matchedCombos = (combos || []).filter(function (n) { return n.parentId === cur.id; }).map(function (n) { return n.id; });\n            if (matchedNodes.length || matchedCombos.length) {\n                pre[cur.id] = __spreadArray(__spreadArray([], matchedNodes, true), matchedCombos, true);\n            }\n            return pre;\n        }, {});\n        /** 计算 nodeSize */\n        var nodeSizeFunc;\n        if (!nodeSize) {\n            nodeSizeFunc = function (d) {\n                if (d && d.size) {\n                    if ((0, util_1.isArray)(d.size)) {\n                        return d.size;\n                    }\n                    if ((0, util_1.isObject)(d.size)) {\n                        return [d.size.width || 40, d.size.height || 40];\n                    }\n                    return [d.size, d.size];\n                }\n                return [40, 40];\n            };\n        }\n        else if ((0, util_1.isArray)(nodeSize)) {\n            nodeSizeFunc = function () { return nodeSize; };\n        }\n        else {\n            nodeSizeFunc = function () { return [nodeSize, nodeSize]; };\n        }\n        /** 计算 comboSize */\n        var comboSizeFunc = function (d) {\n            if (d && d.size) {\n                if ((0, util_1.isArray)(d.size)) {\n                    return d.size;\n                }\n                return [d.size, d.size];\n            }\n            return [80, 40];\n        };\n        // 接受 defaultCombo 设置的 size\n        var _d = comboSizeFunc(combos === null || combos === void 0 ? void 0 : combos[0]), metaWidth = _d[0], metaHeight = _d[1];\n        // 初始化 padding\n        var subSceneMeta = (_b = (_a = self.graphSettings) === null || _a === void 0 ? void 0 : _a.subScene) === null || _b === void 0 ? void 0 : _b.meta;\n        var _e = ((_c = combos.find(function (c) { return !c.collapsed; })) === null || _c === void 0 ? void 0 : _c.padding) || [20, 20, 20, 20], paddingTop = _e[0], paddingRight = _e[1], paddingBottom = _e[2], paddingLeft = _e[3];\n        var graphDef = {\n            compound: compound,\n            nodes: __spreadArray([], (nodes || []).map(function (n) {\n                var size = nodeSizeFunc(n);\n                var width = size[0];\n                var height = size[1];\n                return __assign(__assign({}, n), { width: width, height: height });\n            }), true),\n            edges: __spreadArray([], (edges || []).map(function (e) { return (__assign(__assign({}, e), { v: e.source, w: e.target })); }), true)\n        };\n        // 需要展开的节点\n        var graphOption = {\n            expanded: (combos || []).filter(function (c) { return !c.collapsed; }).map(function (c) { return c.id; })\n        };\n        // dagre-compound 布局参数\n        var graphMetaConfig = {\n            graph: {\n                meta: {\n                    align: align,\n                    rankDir: rankdir,\n                    nodeSep: nodesep,\n                    edgeSep: edgesep,\n                    rankSep: ranksep\n                }\n            },\n            subScene: {\n                meta: {\n                    paddingTop: paddingTop || (subSceneMeta === null || subSceneMeta === void 0 ? void 0 : subSceneMeta.paddingTop) || 20,\n                    paddingRight: paddingRight || (subSceneMeta === null || subSceneMeta === void 0 ? void 0 : subSceneMeta.paddingRight) || 20,\n                    paddingBottom: paddingBottom || (subSceneMeta === null || subSceneMeta === void 0 ? void 0 : subSceneMeta.paddingBottom) || 20,\n                    paddingLeft: paddingLeft || (subSceneMeta === null || subSceneMeta === void 0 ? void 0 : subSceneMeta.paddingLeft) || 20,\n                    labelHeight: 0\n                }\n            },\n            nodeSize: {\n                meta: {\n                    width: metaWidth,\n                    height: metaHeight\n                }\n            }\n        };\n        // 合并用户输入的内容\n        var graphSettings = (0, dagre_compound_1.mergeConfig)(settings, __assign({}, (0, dagre_compound_1.mergeConfig)(graphMetaConfig, dagre_compound_1.LAYOUT_CONFIG)));\n        self.graphSettings = graphSettings;\n        return {\n            graphDef: graphDef,\n            graphOption: graphOption,\n            graphSettings: graphSettings\n        };\n    };\n    /** 更新节点与边位置 */\n    DagreCompoundLayout.prototype.updatePosition = function (flattenedGraph) {\n        var nodes = flattenedGraph.nodes, edges = flattenedGraph.edges;\n        this.updateNodePosition(nodes, edges);\n        this.updateEdgePosition(nodes, edges);\n    };\n    DagreCompoundLayout.prototype.getBegin = function (flattenedNodes, flattenedEdges) {\n        var self = this;\n        var begin = self.begin;\n        var dBegin = [0, 0];\n        if (begin) {\n            var minX_1 = Infinity;\n            var minY_1 = Infinity;\n            flattenedNodes.forEach(function (node) {\n                if (minX_1 > node.x)\n                    minX_1 = node.x;\n                if (minY_1 > node.y)\n                    minY_1 = node.y;\n            });\n            flattenedEdges.forEach(function (edge) {\n                edge.points.forEach(function (point) {\n                    if (minX_1 > point.x)\n                        minX_1 = point.x;\n                    if (minY_1 > point.y)\n                        minY_1 = point.y;\n                });\n            });\n            dBegin[0] = begin[0] - minX_1;\n            dBegin[1] = begin[1] - minY_1;\n        }\n        return dBegin;\n    };\n    DagreCompoundLayout.prototype.updateNodePosition = function (flattenedNodes, flattenedEdges) {\n        var self = this;\n        var combos = self.combos, nodes = self.nodes, edges = self.edges, anchorPoint = self.anchorPoint, graphSettings = self.graphSettings;\n        var dBegin = this.getBegin(flattenedNodes, flattenedEdges);\n        flattenedNodes.forEach(function (node) {\n            var _a;\n            var x = node.x, y = node.y, id = node.id, type = node.type, coreBox = node.coreBox;\n            if (type === dagre_compound_1.HierarchyNodeType.META && id !== dagre_compound_1.ROOT_NAME) {\n                var i = combos.findIndex(function (item) { return item.id === id; });\n                var subSceneMeta = (_a = graphSettings === null || graphSettings === void 0 ? void 0 : graphSettings.subScene) === null || _a === void 0 ? void 0 : _a.meta;\n                // 将布局生成的 combo 位置暂存至 offsetX offsetY\n                combos[i].offsetX = x + dBegin[0];\n                combos[i].offsetY = y + dBegin[1];\n                combos[i].fixSize = [coreBox.width, coreBox.height];\n                combos[i].fixCollapseSize = [coreBox.width, coreBox.height];\n                // 如果设置了收起时隐藏 padding，则手动优化 combo padding 信息，展开的话则恢复\n                if (!node.expanded) {\n                    combos[i].padding = [0, 0, 0, 0];\n                }\n                else {\n                    combos[i].padding = [\n                        subSceneMeta === null || subSceneMeta === void 0 ? void 0 : subSceneMeta.paddingTop,\n                        subSceneMeta === null || subSceneMeta === void 0 ? void 0 : subSceneMeta.paddingRight,\n                        subSceneMeta === null || subSceneMeta === void 0 ? void 0 : subSceneMeta.paddingBottom,\n                        subSceneMeta === null || subSceneMeta === void 0 ? void 0 : subSceneMeta.paddingLeft\n                    ];\n                }\n            }\n            else if (type === dagre_compound_1.HierarchyNodeType.OP) {\n                var i = nodes.findIndex(function (item) { return item.id === id; });\n                nodes[i].x = x + dBegin[0];\n                nodes[i].y = y + dBegin[1];\n                if (anchorPoint) {\n                    var anchorPoints_1 = [];\n                    var outEdges = flattenedEdges.filter(function (e) { return e.v === id; });\n                    var inEdges = flattenedEdges.filter(function (e) { return e.w === id; });\n                    // 指定出边锚点，锚点中心点为 [0.5, 0.5]\n                    if (outEdges.length > 0) {\n                        outEdges.forEach(function (outEdge) {\n                            var firstPoint = outEdge.points[0];\n                            var anchorPointX = (firstPoint.x - x) / node.width + 0.5;\n                            var anchorPointY = (firstPoint.y - y) / node.height + 0.5;\n                            anchorPoints_1.push([anchorPointX, anchorPointY]);\n                            // 出边对应 source 边锚点\n                            outEdge.baseEdgeList.forEach(function (baseEdge) {\n                                var edge = edges.find(function (e) { return e.source === baseEdge.v && e.target === baseEdge.w; });\n                                if (edge) {\n                                    edge.sourceAnchor = anchorPoints_1.length - 1;\n                                }\n                            });\n                        });\n                    }\n                    // 指定入边锚点\n                    if (inEdges.length > 0) {\n                        inEdges.forEach(function (inEdge) {\n                            var lastPoint = inEdge.points[inEdge.points.length - 1];\n                            var anchorPointX = (lastPoint.x - x) / node.width + 0.5;\n                            var anchorPointY = (lastPoint.y - y) / node.height + 0.5;\n                            anchorPoints_1.push([anchorPointX, anchorPointY]);\n                            // 出边对应 source 锚点\n                            inEdge.baseEdgeList.forEach(function (baseEdge) {\n                                var edge = edges.find(function (e) { return e.source === baseEdge.v && e.target === baseEdge.w; });\n                                if (edge) {\n                                    edge.targetAnchor = anchorPoints_1.length - 1;\n                                }\n                            });\n                        });\n                    }\n                    nodes[i].anchorPoints = anchorPoints_1.length > 0 ? anchorPoints_1 : nodes[i].anchorPoints || [];\n                }\n            }\n        });\n    };\n    DagreCompoundLayout.prototype.updateEdgePosition = function (flattenedNodes, flattenedEdges) {\n        var self = this;\n        var combos = self.combos, edges = self.edges, controlPoints = self.controlPoints;\n        var dBegin = this.getBegin(flattenedNodes, flattenedEdges);\n        if (controlPoints) {\n            combos.forEach(function (combo) {\n                combo.inEdges = [];\n                combo.outEdges = [];\n            });\n            edges.forEach(function (sourceEdge) {\n                var _a, _b, _c, _d;\n                var sourceNode = flattenedNodes.find(function (v) { return v.id === sourceEdge.source; });\n                var targetNode = flattenedNodes.find(function (v) { return v.id === sourceEdge.target; });\n                // Combo 收起状态，dagre-compound 不会渲染该节点，边需要使用到 group 的边作为补充\n                var points = [];\n                var sortedEdges = [];\n                if (sourceNode && targetNode) {\n                    sortedEdges = (0, dagre_compound_1.getEdges)(sourceNode === null || sourceNode === void 0 ? void 0 : sourceNode.id, targetNode === null || targetNode === void 0 ? void 0 : targetNode.id, flattenedNodes);\n                }\n                else if (!sourceNode || !targetNode) {\n                    /** 存在收起节点时，需要重新计算边的 controlPoints，确保线正常 */\n                    // 情况1：目标节点被收起了，向上寻找该节点最近一个存在的父节点\n                    var sourceNodePath = self.getNodePath(sourceEdge.source);\n                    var targetNodePath = self.getNodePath(sourceEdge.target);\n                    var lastExistingSource_1 = sourceNodePath\n                        .reverse()\n                        .slice(!sourceNode ? 1 : 0)\n                        .find(function (parentId) { return flattenedNodes.find(function (fNode) { return fNode.id === parentId; }); });\n                    var lastExistingTarget_1 = targetNodePath\n                        .reverse()\n                        .slice(!targetNode ? 1 : 0)\n                        .find(function (parentId) { return flattenedNodes.find(function (fNode) { return fNode.id === parentId; }); });\n                    sourceNode = flattenedNodes.find(function (v) { return v.id === lastExistingSource_1; });\n                    targetNode = flattenedNodes.find(function (v) { return v.id === lastExistingTarget_1; });\n                    sortedEdges = (0, dagre_compound_1.getEdges)(sourceNode === null || sourceNode === void 0 ? void 0 : sourceNode.id, targetNode === null || targetNode === void 0 ? void 0 : targetNode.id, flattenedNodes, { v: sourceEdge.source, w: sourceEdge.target });\n                }\n                points = sortedEdges.reduce(function (pre, cur) {\n                    return __spreadArray(__spreadArray([], pre, true), cur.points.map(function (p) {\n                        return __assign(__assign({}, p), { x: p.x + dBegin[0], y: p.y + dBegin[1] });\n                    }), true);\n                }, []);\n                // 取消首尾节点\n                points = points.slice(1, -1);\n                sourceEdge.controlPoints = points;\n                if ((targetNode === null || targetNode === void 0 ? void 0 : targetNode.type) === dagre_compound_1.NodeType.META) {\n                    // combo 节点控制点\n                    var i = combos.findIndex(function (item) { return item.id === (targetNode === null || targetNode === void 0 ? void 0 : targetNode.id); });\n                    if (!combos[i] || ((_a = combos[i].inEdges) === null || _a === void 0 ? void 0 : _a.some(function (inEdge) { return inEdge.source === sourceNode.id && inEdge.target === targetNode.id; }))) {\n                        return;\n                    }\n                    (_b = combos[i].inEdges) === null || _b === void 0 ? void 0 : _b.push({\n                        source: sourceNode.id,\n                        target: targetNode.id,\n                        controlPoints: points\n                    });\n                }\n                if ((sourceNode === null || sourceNode === void 0 ? void 0 : sourceNode.type) === dagre_compound_1.NodeType.META) {\n                    var i = combos.findIndex(function (item) { return item.id === (sourceNode === null || sourceNode === void 0 ? void 0 : sourceNode.id); });\n                    if (!combos[i] || ((_c = combos[i].outEdges) === null || _c === void 0 ? void 0 : _c.some(function (oedge) { return oedge.source === sourceNode.id && oedge.target === targetNode.id; }))) {\n                        return;\n                    }\n                    (_d = combos[i].outEdges) === null || _d === void 0 ? void 0 : _d.push({\n                        source: sourceNode.id,\n                        target: targetNode.id,\n                        controlPoints: points\n                    });\n                }\n            });\n        }\n    };\n    DagreCompoundLayout.prototype.getType = function () {\n        return 'dagreCompound';\n    };\n    /**\n     * 确保布局使用的数据与用户输入数据顺序一致\n     * 通过 layoutOrder 排序 节点 与 边\n     * @param list\n     * @private\n     */\n    DagreCompoundLayout.prototype.getDataByOrder = function (list) {\n        if (list.every(function (n) { return n.layoutOrder !== undefined; })) {\n            // 所有数据均设置过索引，表示仅布局，数据未变化，无需处理\n        }\n        else {\n            // 首次布局或动态添加删减节点时重新赋值\n            list.forEach(function (n, i) {\n                n.layoutOrder = i;\n            });\n        }\n        // 按照 layoutOrder 排序\n        return list.sort(function (pre, cur) { return pre.layoutOrder - cur.layoutOrder; });\n    };\n    return DagreCompoundLayout;\n}(base_1.Base));\nexports.DagreCompoundLayout = DagreCompoundLayout;\n"},"sourceMaps":{"js":{"version":3,"file":"dagreCompound.js","sourceRoot":"","sources":["../../src/layout/dagreCompound.ts"],"names":[],"mappings":"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","sourcesContent":["import { Base } from './base';\nimport { Combo, DagreCompoundLayoutOptions, OutNode, Point, PointTuple } from './types';\nimport {\n    buildGraph,\n    DeepPartial,\n    flatGraph,\n    getEdges,\n    HierarchyBaseEdgeInfo,\n    HierarchyBaseNodeInfo,\n    HierarchyFlattenedGraphInfo,\n    HierarchyGraphCompoundDef,\n    HierarchyGraphDef,\n    HierarchyGraphNodeInfo,\n    HierarchyGraphOption,\n    HierarchyNodeType,\n    LAYOUT_CONFIG,\n    LayoutConfig,\n    mergeConfig,\n    NodeType,\n    ROOT_NAME\n} from 'dagre-compound';\nimport { isArray, isObject } from '../util';\n\ninterface IPoint {\n    x: number;\n    y: number;\n    anchorIndex?: number;\n    [key: string]: number | undefined;\n}\n\ninterface Edge {\n    source: string;\n    target: string;\n    type?: string;\n    startPoint?: IPoint;\n    endPoint?: IPoint;\n    controlPoints?: IPoint[];\n    sourceAnchor?: number;\n    targetAnchor?: number;\n    layoutOrder?: number; // 用于描述用户输入数据顺序，确保按照用户原始数据顺序排序\n    [key: string]: unknown;\n}\n\ntype ComboType = Combo & {\n    x?: number;\n    y?: number;\n    label?: string;\n    type: string;\n    size?: number | number[] | undefined;\n    fixSize?: number[];\n    fixCollapseSize?: number[];\n    // combo 入边与出边，收起时优化连线\n    inEdges?: Edge[];\n    outEdges?: Edge[];\n    padding?: number[];\n    collapsed?: boolean;\n    // 手动指定偏移量\n    offsetX?: number;\n    offsetY?: number;\n    [key: string]: unknown;\n};\n\ntype Node = OutNode & {\n    label?: string;\n    width?: number;\n    height?: number;\n    type?: string;\n    anchorPoints?: [number, number][];\n    layoutOrder?: number; // 用于描述用户输入数据顺序，确保按照用户原始数据顺序排序\n};\n\ntype ModelType = {\n    nodes?: Node[];\n    edges?: Edge[];\n    comboEdges?: Edge[];\n    combos?: ComboType[];\n    hiddenNodes?: Node[];\n    hiddenEdges?: Edge[];\n    hiddenCombos?: ComboType[];\n};\n\nexport class DagreCompoundLayout extends Base {\n    /** layout 方向, 可选 TB, BT, LR, RL */\n    public rankdir: 'TB' | 'BT' | 'LR' | 'RL' = 'TB';\n\n    /** 节点对齐方式，可选 UL, UR, DL, DR */\n    public align: undefined | 'UL' | 'UR' | 'DL' | 'DR';\n\n    /** 布局的起始（左上角）位置 */\n    public begin: PointTuple | undefined;\n\n    /** 节点大小 */\n    public nodeSize: number | number[] | undefined;\n\n    /** 节点水平间距(px) */\n    public nodesep: number = 50;\n\n    /** 边水平间距(px) */\n    public edgesep: number = 5;\n\n    /** 每一层节点之间间距 */\n    public ranksep: number = 50;\n\n    /** 是否保留布局连线的控制点 */\n    public controlPoints: boolean = true;\n\n    /** 是否保留使用布局计算的锚点 */\n    public anchorPoint: boolean = true;\n\n    /** 全局布局配置，优先级最高 */\n    public settings?: DeepPartial<LayoutConfig>;\n\n    public nodes: Node[] = [];\n    public edges: Edge[] = [];\n    public combos: ComboType[] = [];\n\n    /** 当前生命周期内布局配置信息 */\n    private graphSettings: DeepPartial<LayoutConfig> | undefined;\n\n    /** 迭代结束的回调函数 */\n    public onLayoutEnd: () => void = () => {};\n    constructor(options?: DagreCompoundLayoutOptions) {\n        super();\n        this.updateCfg(options);\n    }\n\n    public getDefaultCfg() {\n        return {\n            rankdir: 'TB', // layout 方向, 可选 TB, BT, LR, RL\n            align: undefined, // 节点对齐方式，可选 UL, UR, DL, DR\n            begin: undefined, // 布局的起始（左上角）位置\n            nodeSize: undefined, // 节点大小\n            nodesep: 50, // 节点水平间距(px)\n            ranksep: 50, // 每一层节点之间间距\n            controlPoints: true, // 是否保留布局连线的控制点\n            anchorPoint: true // 是否使用布局计算的锚点\n        };\n    }\n\n    public init(data: ModelType) {\n        const hiddenNodes = data.hiddenNodes || []; // 被隐藏的节点\n        const hiddenEdges = data.hiddenEdges || []; // 被隐藏的边\n        const hiddenCombos = data.hiddenCombos || []; // 赋值 hiddenCombos\n        // 确保此次排序按照用户输入顺序\n        this.nodes = this.getDataByOrder((data.nodes || []).concat(hiddenNodes));\n        this.edges = this.getDataByOrder((data.edges || []).concat(hiddenEdges));\n        this.combos = (data.combos || []).concat(hiddenCombos.map((hc) => ({ ...hc, collapsed: true })));\n    }\n\n    public execute() {\n        const self = this;\n        const { nodes, edges } = self;\n        if (!nodes) return;\n\n        const { graphDef, graphOption, graphSettings } = self.getLayoutConfig();\n        const renderInfo = buildGraph(graphDef, graphOption, graphSettings);\n        const flattenedRenderInfo = flatGraph(renderInfo, true); // 打平数据进行遍历\n        this.updatePosition(flattenedRenderInfo);\n\n        if (self.onLayoutEnd) self.onLayoutEnd();\n\n        return {\n            nodes,\n            edges\n        };\n    }\n\n    /**\n     * combo 模式下查找节点完整路径\n     * @param nodeId\n     * @private\n     */\n    private getNodePath(nodeId: string): string[] {\n        const self = this;\n        const { nodes, combos } = self;\n        const targetNode = nodes.find((n) => n.id === nodeId);\n        const findPath = (comboId: string, fullPath: string[] = []): string[] => {\n            const combo = combos.find((c) => c.id === comboId);\n            if (combo) {\n                fullPath.unshift(comboId);\n                if (combo.parentId) {\n                    return findPath(combo.parentId, fullPath);\n                }\n                return fullPath;\n            }\n            return fullPath;\n        };\n        if (targetNode && targetNode.comboId) {\n            return findPath(targetNode.comboId, [nodeId]);\n        }\n        return [nodeId];\n    }\n\n    /** 准备 dagre-compound 布局参数 */\n    private getLayoutConfig(): { graphDef: HierarchyGraphDef; graphOption: HierarchyGraphOption; graphSettings: DeepPartial<LayoutConfig> } {\n        const self = this;\n        const { nodes, edges, combos, nodeSize, rankdir, align, edgesep, nodesep, ranksep, settings } = self;\n        const compound = (combos || []).reduce((pre: HierarchyGraphCompoundDef, cur) => {\n            const matchedNodes = nodes.filter((n) => n.comboId === cur.id).map((n) => n.id);\n            const matchedCombos = (combos || []).filter((n) => n.parentId === cur.id).map((n) => n.id);\n            if (matchedNodes.length || matchedCombos.length) {\n                pre[cur.id] = [...matchedNodes, ...matchedCombos];\n            }\n            return pre;\n        }, {});\n\n        /** 计算 nodeSize */\n        let nodeSizeFunc: (d?: Node) => number[];\n        if (!nodeSize) {\n            nodeSizeFunc = (d?: Node) => {\n                if (d && d.size) {\n                    if (isArray(d.size)) {\n                        return d.size;\n                    }\n                    if (isObject(d.size)) {\n                        return [d.size.width || 40, d.size.height || 40];\n                    }\n                    return [d.size, d.size];\n                }\n                return [40, 40];\n            };\n        } else if (isArray(nodeSize)) {\n            nodeSizeFunc = () => nodeSize;\n        } else {\n            nodeSizeFunc = () => [nodeSize, nodeSize];\n        }\n\n        /** 计算 comboSize */\n        const comboSizeFunc: (d?: ComboType) => number[] = (d?: ComboType): number[] => {\n            if (d && d.size) {\n                if (isArray(d.size)) {\n                    return d.size;\n                }\n                return [d.size, d.size];\n            }\n            return [80, 40];\n        };\n\n        // 接受 defaultCombo 设置的 size\n        const [metaWidth, metaHeight] = comboSizeFunc(combos?.[0]);\n        // 初始化 padding\n        const subSceneMeta = self.graphSettings?.subScene?.meta;\n        const [paddingTop, paddingRight, paddingBottom, paddingLeft] = combos.find((c) => !c.collapsed)?.padding || [20, 20, 20, 20];\n        const graphDef = {\n            compound,\n            nodes: [\n                ...(nodes || []).map((n) => {\n                    const size = nodeSizeFunc(n);\n                    const width = size[0];\n                    const height = size[1];\n                    return { ...n, width, height };\n                })\n            ],\n            edges: [...(edges || []).map((e) => ({ ...e, v: e.source, w: e.target }))]\n        };\n\n        // 需要展开的节点\n        const graphOption = {\n            expanded: (combos || []).filter((c) => !c.collapsed).map((c) => c.id)\n        };\n\n        // dagre-compound 布局参数\n        const graphMetaConfig: DeepPartial<LayoutConfig> = {\n            graph: {\n                meta: {\n                    align,\n                    rankDir: rankdir,\n                    nodeSep: nodesep,\n                    edgeSep: edgesep,\n                    rankSep: ranksep\n                }\n            },\n            subScene: {\n                meta: {\n                    paddingTop: paddingTop || subSceneMeta?.paddingTop || 20,\n                    paddingRight: paddingRight || subSceneMeta?.paddingRight || 20,\n                    paddingBottom: paddingBottom || subSceneMeta?.paddingBottom || 20,\n                    paddingLeft: paddingLeft || subSceneMeta?.paddingLeft || 20,\n                    labelHeight: 0\n                }\n            },\n            nodeSize: {\n                meta: {\n                    width: metaWidth,\n                    height: metaHeight\n                }\n            }\n        };\n\n        // 合并用户输入的内容\n        const graphSettings = mergeConfig(settings, {\n            ...mergeConfig(graphMetaConfig, LAYOUT_CONFIG)\n        });\n        self.graphSettings = graphSettings;\n\n        return {\n            graphDef,\n            graphOption,\n            graphSettings\n        };\n    }\n\n    /** 更新节点与边位置 */\n    private updatePosition(flattenedGraph: HierarchyFlattenedGraphInfo): void {\n        const { nodes, edges } = flattenedGraph;\n        this.updateNodePosition(nodes, edges);\n        this.updateEdgePosition(nodes, edges);\n    }\n\n    private getBegin(\n        flattenedNodes: (HierarchyBaseNodeInfo | HierarchyGraphNodeInfo)[],\n        flattenedEdges: HierarchyBaseEdgeInfo[]\n    ): PointTuple {\n        const self = this;\n        const { begin } = self;\n\n        const dBegin: PointTuple = [0, 0];\n        if (begin) {\n            let minX = Infinity;\n            let minY = Infinity;\n            flattenedNodes.forEach((node) => {\n                if (minX > node.x) minX = node.x;\n                if (minY > node.y) minY = node.y;\n            });\n            flattenedEdges.forEach((edge) => {\n                edge.points.forEach((point) => {\n                    if (minX > point.x) minX = point.x;\n                    if (minY > point.y) minY = point.y;\n                });\n            });\n            dBegin[0] = begin[0] - minX;\n            dBegin[1] = begin[1] - minY;\n        }\n        return dBegin;\n    }\n\n    private updateNodePosition(\n        flattenedNodes: (HierarchyBaseNodeInfo | HierarchyGraphNodeInfo)[],\n        flattenedEdges: HierarchyBaseEdgeInfo[]\n    ): void {\n        const self = this;\n        const { combos, nodes, edges, anchorPoint, graphSettings } = self;\n        const dBegin = this.getBegin(flattenedNodes, flattenedEdges);\n\n        flattenedNodes.forEach((node) => {\n            const { x, y, id, type, coreBox } = node;\n            if (type === HierarchyNodeType.META && id !== ROOT_NAME) {\n                const i = combos.findIndex((item) => item.id === id);\n                const subSceneMeta = graphSettings?.subScene?.meta;\n                // 将布局生成的 combo 位置暂存至 offsetX offsetY\n                combos[i].offsetX = x + dBegin[0];\n                combos[i].offsetY = y + dBegin[1];\n                combos[i].fixSize = [coreBox.width, coreBox.height];\n                combos[i].fixCollapseSize = [coreBox.width, coreBox.height];\n                // 如果设置了收起时隐藏 padding，则手动优化 combo padding 信息，展开的话则恢复\n                if (!node.expanded) {\n                    combos[i].padding = [0, 0, 0, 0];\n                } else {\n                    combos[i].padding = [\n                        subSceneMeta?.paddingTop!,\n                        subSceneMeta?.paddingRight!,\n                        subSceneMeta?.paddingBottom!,\n                        subSceneMeta?.paddingLeft!\n                    ];\n                }\n            } else if (type === HierarchyNodeType.OP) {\n                const i = nodes.findIndex((item) => item.id === id);\n                nodes[i].x = x + dBegin[0];\n                nodes[i].y = y + dBegin[1];\n\n                if (anchorPoint) {\n                    const anchorPoints: [number, number][] = [];\n                    const outEdges = flattenedEdges.filter((e) => e.v === id);\n                    const inEdges = flattenedEdges.filter((e) => e.w === id);\n                    // 指定出边锚点，锚点中心点为 [0.5, 0.5]\n                    if (outEdges.length > 0) {\n                        outEdges.forEach((outEdge) => {\n                            const firstPoint = outEdge.points[0];\n                            const anchorPointX = (firstPoint.x - x) / node.width + 0.5;\n                            const anchorPointY = (firstPoint.y - y) / node.height + 0.5;\n                            anchorPoints.push([anchorPointX, anchorPointY]);\n                            // 出边对应 source 边锚点\n                            outEdge.baseEdgeList.forEach((baseEdge) => {\n                                const edge = edges.find((e) => e.source === baseEdge.v && e.target === baseEdge.w);\n                                if (edge) {\n                                    edge.sourceAnchor = anchorPoints.length - 1;\n                                }\n                            });\n                        });\n                    }\n                    // 指定入边锚点\n                    if (inEdges.length > 0) {\n                        inEdges.forEach((inEdge) => {\n                            const lastPoint = inEdge.points[inEdge.points.length - 1];\n                            const anchorPointX = (lastPoint.x - x) / node.width + 0.5;\n                            const anchorPointY = (lastPoint.y - y) / node.height + 0.5;\n                            anchorPoints.push([anchorPointX, anchorPointY]);\n                            // 出边对应 source 锚点\n                            inEdge.baseEdgeList.forEach((baseEdge) => {\n                                const edge = edges.find((e) => e.source === baseEdge.v && e.target === baseEdge.w);\n                                if (edge) {\n                                    edge.targetAnchor = anchorPoints.length - 1;\n                                }\n                            });\n                        });\n                    }\n                    nodes[i].anchorPoints = anchorPoints.length > 0 ? anchorPoints : nodes[i].anchorPoints || [];\n                }\n            }\n        });\n    }\n\n    private updateEdgePosition(\n        flattenedNodes: (HierarchyBaseNodeInfo | HierarchyGraphNodeInfo)[],\n        flattenedEdges: HierarchyBaseEdgeInfo[]\n    ): void {\n        const self = this;\n        const { combos, edges, controlPoints } = self;\n        const dBegin = this.getBegin(flattenedNodes, flattenedEdges);\n\n        if (controlPoints) {\n            combos.forEach((combo) => {\n                combo.inEdges = [];\n                combo.outEdges = [];\n            });\n            edges.forEach((sourceEdge) => {\n                let sourceNode = flattenedNodes.find((v) => v.id === sourceEdge.source);\n                let targetNode = flattenedNodes.find((v) => v.id === sourceEdge.target);\n                // Combo 收起状态，dagre-compound 不会渲染该节点，边需要使用到 group 的边作为补充\n                let points: Point[] = [];\n                let sortedEdges: HierarchyBaseEdgeInfo[] = [];\n                if (sourceNode && targetNode) {\n                    sortedEdges = getEdges(sourceNode?.id, targetNode?.id, flattenedNodes);\n                } else if (!sourceNode || !targetNode) {\n                    /** 存在收起节点时，需要重新计算边的 controlPoints，确保线正常 */\n                        // 情况1：目标节点被收起了，向上寻找该节点最近一个存在的父节点\n                    const sourceNodePath = self.getNodePath(sourceEdge.source);\n                    const targetNodePath = self.getNodePath(sourceEdge.target);\n\n                    const lastExistingSource = sourceNodePath\n                        .reverse()\n                        .slice(!sourceNode ? 1 : 0)\n                        .find((parentId) => flattenedNodes.find((fNode) => fNode.id === parentId));\n                    const lastExistingTarget = targetNodePath\n                        .reverse()\n                        .slice(!targetNode ? 1 : 0)\n                        .find((parentId) => flattenedNodes.find((fNode) => fNode.id === parentId));\n                    sourceNode = flattenedNodes.find((v) => v.id === lastExistingSource);\n                    targetNode = flattenedNodes.find((v) => v.id === lastExistingTarget);\n                    sortedEdges = getEdges(sourceNode?.id, targetNode?.id, flattenedNodes, { v: sourceEdge.source, w: sourceEdge.target });\n                }\n\n                points = sortedEdges.reduce((pre, cur) => {\n                    return [\n                        ...pre,\n                        ...cur.points.map((p) => {\n                            return {\n                                ...p,\n                                x: p.x + dBegin[0],\n                                y: p.y + dBegin[1]\n                            };\n                        })\n                    ];\n                }, [] as IPoint[]);\n                // 取消首尾节点\n                points = points.slice(1, -1);\n                sourceEdge.controlPoints = points;\n\n                if (targetNode?.type === NodeType.META) {\n                    // combo 节点控制点\n                    const i = combos.findIndex((item) => item.id === targetNode?.id);\n                    if (!combos[i] || combos[i].inEdges?.some((inEdge) => inEdge.source === sourceNode!.id && inEdge.target === targetNode!.id)) {\n                        return;\n                    }\n                    combos[i].inEdges?.push({\n                        source: sourceNode!.id,\n                        target: targetNode!.id,\n                        controlPoints: points\n                    });\n                }\n                if (sourceNode?.type === NodeType.META) {\n                    const i = combos.findIndex((item) => item.id === sourceNode?.id);\n                    if (!combos[i] || combos[i].outEdges?.some((oedge) => oedge.source === sourceNode!.id && oedge.target === targetNode!.id)) {\n                        return;\n                    }\n                    combos[i].outEdges?.push({\n                        source: sourceNode!.id,\n                        target: targetNode!.id,\n                        controlPoints: points\n                    });\n                }\n            });\n        }\n    }\n\n    public getType() {\n        return 'dagreCompound';\n    }\n\n    /**\n     * 确保布局使用的数据与用户输入数据顺序一致\n     * 通过 layoutOrder 排序 节点 与 边\n     * @param list\n     * @private\n     */\n    private getDataByOrder(list: any[]):  any[] {\n        if (list.every((n) => n.layoutOrder !== undefined)) {\n            // 所有数据均设置过索引，表示仅布局，数据未变化，无需处理\n        } else {\n            // 首次布局或动态添加删减节点时重新赋值\n            list.forEach((n, i) => {\n                n.layoutOrder = i;\n            });\n        }\n        // 按照 layoutOrder 排序\n        return list.sort((pre, cur) => pre.layoutOrder - cur.layoutOrder);\n    }\n}\n"]}},"error":null,"hash":"882b3b9440fc4b9392d202a15b805f7a","cacheData":{"env":{}}}