{"id":"node_modules/@antv/layout/lib/layout/forceAtlas2/index.js","dependencies":[{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\forceAtlas2\\index.js.map","includedInParent":true,"mtime":1676178923693},{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\src\\layout\\forceAtlas2\\index.ts","includedInParent":true,"mtime":1676178923974},{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\package.json","includedInParent":true,"mtime":1676178924413},{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\package.json","includedInParent":true,"mtime":1676178923486},{"name":"../base","loc":{"line":22,"column":21,"index":1036},"parent":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\forceAtlas2\\index.js","resolved":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\base.js"},{"name":"../../util","loc":{"line":23,"column":21,"index":1069},"parent":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\forceAtlas2\\index.js","resolved":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\util\\index.js"},{"name":"./body","loc":{"line":24,"column":37,"index":1121},"parent":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\forceAtlas2\\index.js","resolved":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\forceAtlas2\\body.js"},{"name":"./quad","loc":{"line":25,"column":37,"index":1170},"parent":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\forceAtlas2\\index.js","resolved":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\forceAtlas2\\quad.js"},{"name":"./quadTree","loc":{"line":26,"column":41,"index":1223},"parent":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\forceAtlas2\\index.js","resolved":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\forceAtlas2\\quadTree.js"}],"generated":{"js":"\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ForceAtlas2Layout = void 0;\nvar base_1 = require(\"../base\");\nvar util_1 = require(\"../../util\");\nvar body_1 = __importDefault(require(\"./body\"));\nvar quad_1 = __importDefault(require(\"./quad\"));\nvar quadTree_1 = __importDefault(require(\"./quadTree\"));\nvar ForceAtlas2Layout = /** @class */ (function (_super) {\n    __extends(ForceAtlas2Layout, _super);\n    function ForceAtlas2Layout(options) {\n        var _this = _super.call(this) || this;\n        /** 布局中心 */\n        _this.center = [0, 0];\n        /** 宽度 */\n        _this.width = 300;\n        /** 高度 */\n        _this.height = 300;\n        _this.nodes = [];\n        _this.edges = [];\n        /**\n         * the parameter for repulsive forces,\n         * it will scale the layout but won't change the layout\n         * larger the kr, looser the layout\n         * @type  {number}\n         */\n        _this.kr = 5;\n        /**\n         * the parameter for gravity forces\n         * @type  {number}\n         */\n        _this.kg = 1;\n        /**\n         * modes:\n         * 'normal' for normal using\n         * 'linlog' for compact clusters.\n         * @type  {string}\n         */\n        _this.mode = 'normal';\n        /**\n         * whether preventing the node overlapping\n         * @type  {boolean}\n         */\n        _this.preventOverlap = false;\n        /**\n         * whether active the dissuade hub mode\n         * true: grant authorities (nodes with a high indegree)\n         * a more central position than hubs (nodes with a high outdegree)\n         * @type  {boolean}\n         */\n        _this.dissuadeHubs = false;\n        /**\n         * whether active the barnes hut optimization on computing repulsive forces\n         * @type  {boolean}\n         */\n        _this.barnesHut = undefined;\n        /**\n         * the max iteration number\n         * @type  {number}\n         */\n        _this.maxIteration = 0;\n        /**\n         * control the global velocity\n         * defualt: 0.1(gephi)\n         * @type  {number}\n         */\n        _this.ks = 0.1;\n        /**\n         * the max global velocity\n         * @type  {number}\n         */\n        _this.ksmax = 10;\n        /**\n         * the tolerance for the global swinging\n         * @type  {number}\n         */\n        _this.tao = 0.1;\n        /**\n         * the function of layout complete listener, display the legend and minimap after layout\n         * @type  {function}\n         */\n        _this.onLayoutEnd = function () { };\n        /**\n         * activate prune or not.\n         * prune the leaves during most iterations, layout the leaves in the last 50 iteraitons.\n         * if prune === '', it will be activated when the nodes number > 100\n         * note that it will reduce the quality of the layout\n         * @type  {boolean}\n         */\n        _this.prune = undefined;\n        _this.updateCfg(options);\n        return _this;\n    }\n    ForceAtlas2Layout.prototype.getDefaultCfg = function () {\n        return {};\n    };\n    // execute the layout\n    ForceAtlas2Layout.prototype.execute = function () {\n        var self = this;\n        var nodes = self.nodes, onLayoutEnd = self.onLayoutEnd, prune = self.prune;\n        var maxIteration = self.maxIteration;\n        if (!self.width && typeof window !== \"undefined\") {\n            self.width = window.innerWidth;\n        }\n        if (!self.height && typeof window !== \"undefined\") {\n            self.height = window.innerHeight;\n        }\n        // the whidth of each nodes\n        var sizes = [];\n        var nodeNum = nodes.length;\n        for (var i = 0; i < nodeNum; i += 1) {\n            var node = nodes[i];\n            var nodeWidth = 10;\n            var nodeHeight = 10;\n            if ((0, util_1.isNumber)(node.size)) {\n                nodeWidth = node.size;\n                nodeHeight = node.size;\n            }\n            if ((0, util_1.isArray)(node.size)) {\n                if (!isNaN(node.size[0]))\n                    nodeWidth = node.size[0];\n                if (!isNaN(node.size[1]))\n                    nodeHeight = node.size[1];\n            }\n            else if ((0, util_1.isObject)(node.size)) {\n                nodeWidth = node.size.width;\n                nodeHeight = node.size.height;\n            }\n            if (self.getWidth && !isNaN(self.getWidth(node)))\n                nodeHeight = self.getWidth(node);\n            if (self.getHeight && !isNaN(self.getHeight(node)))\n                nodeWidth = self.getHeight(node);\n            var maxSize = Math.max(nodeWidth, nodeHeight);\n            sizes.push(maxSize);\n        }\n        if (self.barnesHut === undefined && nodeNum > 250)\n            self.barnesHut = true;\n        if (self.prune === undefined && nodeNum > 100)\n            self.prune = true;\n        if (this.maxIteration === 0 && !self.prune) {\n            maxIteration = 250;\n            if (nodeNum <= 200 && nodeNum > 100)\n                maxIteration = 1000;\n            else if (nodeNum > 200)\n                maxIteration = 1200;\n            this.maxIteration = maxIteration;\n        }\n        else if (this.maxIteration === 0 && prune) {\n            maxIteration = 100;\n            if (nodeNum <= 200 && nodeNum > 100)\n                maxIteration = 500;\n            else if (nodeNum > 200)\n                maxIteration = 950;\n            this.maxIteration = maxIteration;\n        }\n        if (!self.kr) {\n            self.kr = 50;\n            if (nodeNum > 100 && nodeNum <= 500)\n                self.kr = 20;\n            else if (nodeNum > 500)\n                self.kr = 1;\n        }\n        if (!self.kg) {\n            self.kg = 20;\n            if (nodeNum > 100 && nodeNum <= 500)\n                self.kg = 10;\n            else if (nodeNum > 500)\n                self.kg = 1;\n        }\n        this.nodes = self.updateNodesByForces(sizes);\n        onLayoutEnd();\n    };\n    ForceAtlas2Layout.prototype.updateNodesByForces = function (sizes) {\n        var self = this;\n        var edges = self.edges, maxIteration = self.maxIteration;\n        var nodes = self.nodes;\n        var nonLoopEdges = edges.filter(function (edge) {\n            var source = (0, util_1.getEdgeTerminal)(edge, 'source');\n            var target = (0, util_1.getEdgeTerminal)(edge, 'target');\n            return source !== target;\n        });\n        var size = nodes.length;\n        var esize = nonLoopEdges.length;\n        var degrees = [];\n        var idMap = {};\n        var edgeEndsIdMap = {};\n        // tslint:disable-next-line\n        var Es = [];\n        for (var i = 0; i < size; i += 1) {\n            idMap[nodes[i].id] = i;\n            degrees[i] = 0;\n            if (nodes[i].x === undefined || isNaN(nodes[i].x)) {\n                nodes[i].x = Math.random() * 1000;\n            }\n            if (nodes[i].y === undefined || isNaN(nodes[i].y)) {\n                nodes[i].y = Math.random() * 1000;\n            }\n            Es.push({ x: nodes[i].x, y: nodes[i].y });\n        }\n        for (var i = 0; i < esize; i += 1) {\n            var node1 = void 0;\n            var node2 = void 0;\n            var sIdx = 0;\n            var tIdx = 0;\n            for (var j = 0; j < size; j += 1) {\n                var source = (0, util_1.getEdgeTerminal)(nonLoopEdges[i], 'source');\n                var target = (0, util_1.getEdgeTerminal)(nonLoopEdges[i], 'target');\n                if (nodes[j].id === source) {\n                    node1 = nodes[j];\n                    sIdx = j;\n                }\n                else if (nodes[j].id === target) {\n                    node2 = nodes[j];\n                    tIdx = j;\n                }\n                edgeEndsIdMap[i] = { sourceIdx: sIdx, targetIdx: tIdx };\n            }\n            if (node1)\n                degrees[idMap[node1.id]] += 1;\n            if (node2)\n                degrees[idMap[node2.id]] += 1;\n        }\n        var iteration = maxIteration;\n        nodes = this.iterate(iteration, idMap, edgeEndsIdMap, esize, degrees, sizes);\n        // if prune, place the leaves around their parents, and then re-layout for several iterations.\n        if (self.prune) {\n            for (var j = 0; j < esize; j += 1) {\n                if (degrees[edgeEndsIdMap[j].sourceIdx] <= 1) {\n                    nodes[edgeEndsIdMap[j].sourceIdx].x = nodes[edgeEndsIdMap[j].targetIdx].x;\n                    nodes[edgeEndsIdMap[j].sourceIdx].y = nodes[edgeEndsIdMap[j].targetIdx].y;\n                }\n                else if (degrees[edgeEndsIdMap[j].targetIdx] <= 1) {\n                    nodes[edgeEndsIdMap[j].targetIdx].x = nodes[edgeEndsIdMap[j].sourceIdx].x;\n                    nodes[edgeEndsIdMap[j].targetIdx].y = nodes[edgeEndsIdMap[j].sourceIdx].y;\n                }\n            }\n            self.prune = false;\n            self.barnesHut = false;\n            iteration = 100;\n            nodes = this.iterate(iteration, idMap, edgeEndsIdMap, esize, degrees, sizes);\n        }\n        return nodes;\n    };\n    ForceAtlas2Layout.prototype.iterate = function (iteration, idMap, edgeEndsIdMap, esize, degrees, sizes) {\n        var self = this;\n        var nodes = self.nodes;\n        var kr = self.kr, preventOverlap = self.preventOverlap;\n        var barnesHut = self.barnesHut;\n        var nodeNum = nodes.length;\n        var sg = 0;\n        var krPrime = 100;\n        var iter = iteration;\n        var prevoIter = 50;\n        var forces = [];\n        var preForces = [];\n        var bodies = [];\n        for (var i = 0; i < nodeNum; i += 1) {\n            forces[2 * i] = 0;\n            forces[2 * i + 1] = 0;\n            if (barnesHut) {\n                var params = {\n                    id: i,\n                    rx: nodes[i].x,\n                    ry: nodes[i].y,\n                    mass: 1,\n                    g: kr,\n                    degree: degrees[i]\n                };\n                bodies[i] = new body_1.default(params);\n            }\n        }\n        while (iter > 0) {\n            for (var i = 0; i < nodeNum; i += 1) {\n                preForces[2 * i] = forces[2 * i];\n                preForces[2 * i + 1] = forces[2 * i + 1];\n                forces[2 * i] = 0;\n                forces[2 * i + 1] = 0;\n            }\n            // attractive forces, existing on every actual edge\n            forces = this.getAttrForces(iter, prevoIter, esize, idMap, edgeEndsIdMap, degrees, sizes, forces);\n            // repulsive forces and Gravity, existing on every node pair\n            // if preventOverlap, using the no-optimized method in the last prevoIter instead.\n            if (barnesHut && ((preventOverlap && iter > prevoIter) || !preventOverlap)) {\n                forces = this.getOptRepGraForces(forces, bodies, degrees);\n            }\n            else {\n                forces = this.getRepGraForces(iter, prevoIter, forces, krPrime, sizes, degrees);\n            }\n            // update the positions\n            var res = this.updatePos(forces, preForces, sg, degrees);\n            nodes = res.nodes;\n            sg = res.sg;\n            iter--;\n            if (self.tick)\n                self.tick();\n        }\n        return nodes;\n    };\n    ForceAtlas2Layout.prototype.getAttrForces = function (iter, prevoIter, esize, idMap, edgeEndsIdMap, degrees, sizes, forces) {\n        var self = this;\n        var nodes = self.nodes, preventOverlap = self.preventOverlap, dissuadeHubs = self.dissuadeHubs, mode = self.mode, prune = self.prune;\n        for (var i = 0; i < esize; i += 1) {\n            var sourceNode = nodes[edgeEndsIdMap[i].sourceIdx];\n            var sourceIdx = edgeEndsIdMap[i].sourceIdx;\n            var targetNode = nodes[edgeEndsIdMap[i].targetIdx];\n            var targetIdx = edgeEndsIdMap[i].targetIdx;\n            if (prune && (degrees[sourceIdx] <= 1 || degrees[targetIdx] <= 1))\n                continue;\n            var dir = [targetNode.x - sourceNode.x, targetNode.y - sourceNode.y];\n            var eucliDis = Math.hypot(dir[0], dir[1]);\n            eucliDis = eucliDis < 0.0001 ? 0.0001 : eucliDis;\n            dir[0] = dir[0] / eucliDis;\n            dir[1] = dir[1] / eucliDis;\n            if (preventOverlap && iter < prevoIter)\n                eucliDis = eucliDis - sizes[sourceIdx] - sizes[targetIdx];\n            var Fa1 = eucliDis; // tslint:disable-line\n            var Fa2 = Fa1; // tslint:disable-line\n            if (mode === 'linlog') {\n                Fa1 = Math.log(1 + eucliDis);\n                Fa2 = Fa1;\n            }\n            if (dissuadeHubs) {\n                Fa1 = eucliDis / degrees[sourceIdx];\n                Fa2 = eucliDis / degrees[targetIdx];\n            }\n            if (preventOverlap && iter < prevoIter && eucliDis <= 0) {\n                Fa1 = 0;\n                Fa2 = 0;\n            }\n            else if (preventOverlap && iter < prevoIter && eucliDis > 0) {\n                Fa1 = eucliDis;\n                Fa2 = eucliDis;\n            }\n            forces[2 * idMap[sourceNode.id]] += Fa1 * dir[0];\n            forces[2 * idMap[targetNode.id]] -= Fa2 * dir[0];\n            forces[2 * idMap[sourceNode.id] + 1] += Fa1 * dir[1];\n            forces[2 * idMap[targetNode.id] + 1] -= Fa2 * dir[1];\n        }\n        return forces;\n    };\n    ForceAtlas2Layout.prototype.getRepGraForces = function (iter, prevoIter, forces, krPrime, sizes, degrees) {\n        var self = this;\n        var nodes = self.nodes, preventOverlap = self.preventOverlap, kr = self.kr, kg = self.kg, center = self.center, prune = self.prune;\n        var nodeNum = nodes.length;\n        for (var i = 0; i < nodeNum; i += 1) {\n            for (var j = i + 1; j < nodeNum; j += 1) {\n                if (prune && (degrees[i] <= 1 || degrees[j] <= 1))\n                    continue;\n                var dir_1 = [nodes[j].x - nodes[i].x, nodes[j].y - nodes[i].y];\n                var eucliDis_1 = Math.hypot(dir_1[0], dir_1[1]);\n                eucliDis_1 = eucliDis_1 < 0.0001 ? 0.0001 : eucliDis_1;\n                dir_1[0] = dir_1[0] / eucliDis_1;\n                dir_1[1] = dir_1[1] / eucliDis_1;\n                if (preventOverlap && iter < prevoIter)\n                    eucliDis_1 = eucliDis_1 - sizes[i] - sizes[j];\n                var Fr = kr * (degrees[i] + 1) * (degrees[j] + 1) / eucliDis_1; // tslint:disable-line\n                if (preventOverlap && iter < prevoIter && eucliDis_1 < 0) {\n                    Fr = krPrime * (degrees[i] + 1) * (degrees[j] + 1);\n                }\n                else if (preventOverlap && iter < prevoIter && eucliDis_1 === 0) {\n                    Fr = 0;\n                }\n                else if (preventOverlap && iter < prevoIter && eucliDis_1 > 0) {\n                    Fr = kr * (degrees[i] + 1) * (degrees[j] + 1) / eucliDis_1;\n                }\n                forces[2 * i] -= Fr * dir_1[0];\n                forces[2 * j] += Fr * dir_1[0];\n                forces[2 * i + 1] -= Fr * dir_1[1];\n                forces[2 * j + 1] += Fr * dir_1[1];\n            }\n            // gravity\n            var dir = [nodes[i].x - center[0], nodes[i].y - center[1]];\n            var eucliDis = Math.hypot(dir[0], dir[1]);\n            dir[0] = dir[0] / eucliDis;\n            dir[1] = dir[1] / eucliDis;\n            var Fg = kg * (degrees[i] + 1); // tslint:disable-line\n            forces[2 * i] -= Fg * dir[0];\n            forces[2 * i + 1] -= Fg * dir[1];\n        }\n        return forces;\n    };\n    ForceAtlas2Layout.prototype.getOptRepGraForces = function (forces, bodies, degrees) {\n        var self = this;\n        var nodes = self.nodes, kg = self.kg, center = self.center, prune = self.prune;\n        var nodeNum = nodes.length;\n        var minx = 9e10;\n        var maxx = -9e10;\n        var miny = 9e10;\n        var maxy = -9e10;\n        for (var i = 0; i < nodeNum; i += 1) {\n            if (prune && (degrees[i] <= 1))\n                continue;\n            bodies[i].setPos(nodes[i].x, nodes[i].y);\n            if (nodes[i].x >= maxx)\n                maxx = nodes[i].x;\n            if (nodes[i].x <= minx)\n                minx = nodes[i].x;\n            if (nodes[i].y >= maxy)\n                maxy = nodes[i].y;\n            if (nodes[i].y <= miny)\n                miny = nodes[i].y;\n        }\n        var width = Math.max(maxx - minx, maxy - miny);\n        var quadParams = {\n            xmid: (maxx + minx) / 2,\n            ymid: (maxy + miny) / 2,\n            length: width,\n            massCenter: center,\n            mass: nodeNum\n        };\n        var quad = new quad_1.default(quadParams);\n        var quadTree = new quadTree_1.default(quad);\n        // build the tree, insert the nodes(quads) into the tree\n        for (var i = 0; i < nodeNum; i += 1) {\n            if (prune && (degrees[i] <= 1))\n                continue;\n            if (bodies[i].in(quad))\n                quadTree.insert(bodies[i]);\n        }\n        // update the repulsive forces and the gravity.\n        for (var i = 0; i < nodeNum; i += 1) {\n            if (prune && (degrees[i] <= 1))\n                continue;\n            bodies[i].resetForce();\n            quadTree.updateForce(bodies[i]);\n            forces[2 * i] -= bodies[i].fx;\n            forces[2 * i + 1] -= bodies[i].fy;\n            // gravity\n            var dir = [nodes[i].x - center[0], nodes[i].y - center[1]];\n            var eucliDis = Math.hypot(dir[0], dir[1]);\n            eucliDis = eucliDis < 0.0001 ? 0.0001 : eucliDis;\n            dir[0] = dir[0] / eucliDis;\n            dir[1] = dir[1] / eucliDis;\n            var Fg = kg * (degrees[i] + 1); // tslint:disable-line\n            forces[2 * i] -= Fg * dir[0];\n            forces[2 * i + 1] -= Fg * dir[1];\n        }\n        return forces;\n    };\n    ForceAtlas2Layout.prototype.updatePos = function (forces, preForces, sg, degrees) {\n        var self = this;\n        var nodes = self.nodes, ks = self.ks, tao = self.tao, prune = self.prune, ksmax = self.ksmax;\n        var nodeNum = nodes.length;\n        var swgns = [];\n        var trans = [];\n        // swg(G) and tra(G)\n        var swgG = 0;\n        var traG = 0;\n        for (var i = 0; i < nodeNum; i += 1) {\n            if (prune && (degrees[i] <= 1))\n                continue;\n            var minus = [forces[2 * i] - preForces[2 * i],\n                forces[2 * i + 1] - preForces[2 * i + 1]\n            ];\n            var minusNorm = Math.hypot(minus[0], minus[1]);\n            var add = [forces[2 * i] + preForces[2 * i],\n                forces[2 * i + 1] + preForces[2 * i + 1]\n            ];\n            var addNorm = Math.hypot(add[0], add[1]);\n            swgns[i] = minusNorm;\n            trans[i] = addNorm / 2;\n            swgG += (degrees[i] + 1) * swgns[i];\n            traG += (degrees[i] + 1) * trans[i];\n        }\n        var preSG = sg;\n        sg = tao * traG / swgG; // tslint:disable-line\n        if (preSG !== 0) {\n            sg = sg > (1.5 * preSG) ? (1.5 * preSG) : sg; // tslint:disable-line\n        }\n        // update the node positions\n        for (var i = 0; i < nodeNum; i += 1) {\n            if (prune && (degrees[i] <= 1))\n                continue;\n            if ((0, util_1.isNumber)(nodes[i].fx) && (0, util_1.isNumber)(nodes[i].fy))\n                continue;\n            var sn = ks * sg / (1 + sg * Math.sqrt(swgns[i]));\n            var absForce = Math.hypot(forces[2 * i], forces[2 * i + 1]);\n            absForce = absForce < 0.0001 ? 0.0001 : absForce;\n            var max = ksmax / absForce;\n            sn = sn > max ? max : sn;\n            var dnx = sn * forces[2 * i];\n            var dny = sn * forces[2 * i + 1];\n            nodes[i].x += dnx;\n            nodes[i].y += dny;\n        }\n        return { nodes: nodes, sg: sg };\n    };\n    return ForceAtlas2Layout;\n}(base_1.Base));\nexports.ForceAtlas2Layout = ForceAtlas2Layout;\n"},"sourceMaps":{"js":{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../src/layout/forceAtlas2/index.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @fileOverview force atlas 2\n * @author shiwu.wyy@antfin.com\n */\nimport { PointTuple, OutNode, Edge, ForceAtlas2LayoutOptions } from \"../types\";\nimport { Base } from \"../base\";\nimport { getEdgeTerminal, isArray, isNumber, isObject } from \"../../util\";\nimport Body from './body';\nimport Quad from './quad';\nimport QuadTree from './quadTree';\n\nexport class ForceAtlas2Layout extends Base {\n  /** 布局中心 */\n  public center: PointTuple = [0, 0];\n\n  /** 宽度 */\n  public width: number = 300;\n\n  /** 高度 */\n  public height: number = 300;\n\n  public nodes: OutNode[] = [];\n\n  public edges: Edge[] = [];\n\n  /**\n   * the parameter for repulsive forces,\n   * it will scale the layout but won't change the layout\n   * larger the kr, looser the layout\n   * @type  {number}\n   */\n  public kr: number = 5;\n\n  /**\n   * the parameter for gravity forces\n   * @type  {number}\n   */\n  public kg: number = 1;\n\n  /**\n   * modes:\n   * 'normal' for normal using\n   * 'linlog' for compact clusters.\n   * @type  {string}\n   */\n  public mode: 'normal' | 'linlog' = 'normal';\n\n  /**\n   * whether preventing the node overlapping\n   * @type  {boolean}\n   */\n  public preventOverlap: boolean = false;\n\n  /**\n   * whether active the dissuade hub mode\n   * true: grant authorities (nodes with a high indegree)\n   * a more central position than hubs (nodes with a high outdegree)\n   * @type  {boolean}\n   */\n  public dissuadeHubs: boolean = false;\n\n  /**\n   * whether active the barnes hut optimization on computing repulsive forces\n   * @type  {boolean}\n   */\n  public barnesHut: boolean | undefined = undefined;\n\n  /**\n   * the max iteration number\n   * @type  {number}\n   */\n  public maxIteration: number = 0;\n\n  /**\n   * control the global velocity\n   * defualt: 0.1(gephi)\n   * @type  {number}\n   */\n  public ks: number = 0.1;\n\n  /**\n   * the max global velocity\n   * @type  {number}\n   */\n  public ksmax: number = 10;\n\n  /**\n   * the tolerance for the global swinging\n   * @type  {number}\n   */\n  public tao: number = 0.1;\n\n  /**\n   * the function of layout complete listener, display the legend and minimap after layout\n   * @type  {function}\n   */\n  public onLayoutEnd: () => void = () => {};\n\n  public tick: () => void;\n\n  /**\n   * activate prune or not.\n   * prune the leaves during most iterations, layout the leaves in the last 50 iteraitons.\n   * if prune === '', it will be activated when the nodes number > 100\n   * note that it will reduce the quality of the layout\n   * @type  {boolean}\n   */\n  public prune: boolean | undefined = undefined;\n\n  public getWidth: (node: any) => number;\n  public getHeight: (node: any) => number;\n\n  constructor(options?: ForceAtlas2LayoutOptions) {\n    super();\n    this.updateCfg(options);\n  }\n\n  public getDefaultCfg() {\n    return {};\n  }\n\n  // execute the layout\n  public execute() {\n    const self = this;\n    const {\n      nodes,\n      onLayoutEnd,\n      prune,\n    } = self;\n    let maxIteration = self.maxIteration;\n\n    if (!self.width && typeof window !== \"undefined\") {\n      self.width = window.innerWidth;\n    }\n    if (!self.height && typeof window !== \"undefined\") {\n      self.height = window.innerHeight;\n    }\n\n    // the whidth of each nodes\n    const sizes = [];\n    const nodeNum = nodes.length;\n    for (let i = 0; i < nodeNum; i += 1) {\n      const node = nodes[i] as any;\n      let nodeWidth = 10;\n      let nodeHeight = 10;\n      if (isNumber(node.size)) {\n        nodeWidth = node.size;\n        nodeHeight = node.size;\n      }\n      if (isArray(node.size))  {\n        if (!isNaN(node.size[0])) nodeWidth = node.size[0];\n        if (!isNaN(node.size[1])) nodeHeight = node.size[1];\n      } else if (isObject(node.size)) {\n        nodeWidth = node.size.width;\n        nodeHeight = node.size.height;\n      }\n      if (self.getWidth && !isNaN(self.getWidth(node))) nodeHeight = self.getWidth(node);\n      if (self.getHeight && !isNaN(self.getHeight(node))) nodeWidth = self.getHeight(node);\n\n      const maxSize = Math.max(nodeWidth, nodeHeight);\n      sizes.push(maxSize);\n    }\n\n    if (self.barnesHut === undefined && nodeNum > 250) self.barnesHut = true;\n    if (self.prune === undefined && nodeNum > 100) self.prune = true;\n    if (this.maxIteration === 0 && !self.prune) {\n      maxIteration = 250;\n      if (nodeNum <= 200 && nodeNum > 100) maxIteration = 1000;\n      else if (nodeNum > 200) maxIteration = 1200;\n      this.maxIteration = maxIteration;\n    } else if (this.maxIteration === 0 && prune) {\n      maxIteration = 100;\n      if (nodeNum <= 200 && nodeNum > 100) maxIteration = 500;\n      else if (nodeNum > 200) maxIteration = 950;\n      this.maxIteration = maxIteration;\n    }\n\n    if (!self.kr) {\n      self.kr = 50;\n      if (nodeNum > 100 && nodeNum <= 500) self.kr = 20;\n      else if (nodeNum > 500) self.kr = 1;\n    }\n    if (!self.kg) {\n      self.kg = 20;\n      if (nodeNum > 100 && nodeNum <= 500) self.kg = 10;\n      else if (nodeNum > 500) self.kg = 1;\n    }\n    this.nodes = self.updateNodesByForces(sizes);\n    onLayoutEnd();\n  }\n\n\n  updateNodesByForces(sizes: number[]) {\n    const self = this;\n    const { edges, maxIteration } = self;\n    let nodes = self.nodes;\n\n    const nonLoopEdges = edges.filter((edge: any) => {\n      const source = getEdgeTerminal(edge, 'source');\n      const target = getEdgeTerminal(edge, 'target');\n      return source !== target;\n    });\n    const size = nodes.length;\n    const esize = nonLoopEdges.length;\n\n    const degrees = [];\n    const idMap: {[key: string]: number} = {};\n    const edgeEndsIdMap: {[key: number]: {sourceIdx: number, targetIdx: number}} = {};\n\n    // tslint:disable-next-line\n    const Es = []\n    for (let i = 0; i < size; i += 1) {\n      idMap[nodes[i].id] = i;\n      degrees[i] = 0;\n      if (nodes[i].x === undefined || isNaN(nodes[i].x)) { nodes[i].x = Math.random() * 1000; }\n      if (nodes[i].y === undefined || isNaN(nodes[i].y)) { nodes[i].y = Math.random() * 1000; }\n      Es.push({ x: nodes[i].x, y: nodes[i].y });\n    }\n    for (let i = 0; i < esize; i += 1) {\n      let node1;\n      let node2;\n      let sIdx = 0;\n      let tIdx = 0;\n\n      for (let j = 0; j < size; j += 1) {\n        const source = getEdgeTerminal(nonLoopEdges[i], 'source');\n        const target = getEdgeTerminal(nonLoopEdges[i], 'target');\n        if (nodes[j].id === source) {\n          node1 = nodes[j];\n          sIdx = j;\n        } else if (nodes[j].id === target) {\n          node2 = nodes[j];\n          tIdx = j;\n        }\n        edgeEndsIdMap[i] = { sourceIdx: sIdx, targetIdx: tIdx };\n      }\n      if (node1) degrees[idMap[node1.id]] += 1;\n      if (node2) degrees[idMap[node2.id]] += 1;\n    }\n\n    let iteration = maxIteration;\n    nodes = this.iterate(iteration, idMap, edgeEndsIdMap, esize, degrees, sizes);\n\n    // if prune, place the leaves around their parents, and then re-layout for several iterations.\n    if (self.prune) {\n      for (let j = 0; j < esize; j += 1) {\n        if (degrees[edgeEndsIdMap[j].sourceIdx] <= 1) {\n          nodes[edgeEndsIdMap[j].sourceIdx].x = nodes[edgeEndsIdMap[j].targetIdx].x;\n          nodes[edgeEndsIdMap[j].sourceIdx].y = nodes[edgeEndsIdMap[j].targetIdx].y;\n\n        } else if (degrees[edgeEndsIdMap[j].targetIdx] <= 1) {\n          nodes[edgeEndsIdMap[j].targetIdx].x = nodes[edgeEndsIdMap[j].sourceIdx].x;\n          nodes[edgeEndsIdMap[j].targetIdx].y = nodes[edgeEndsIdMap[j].sourceIdx].y;\n        }\n      }\n      self.prune = false;\n      self.barnesHut = false;\n      iteration = 100;\n      nodes = this.iterate(\n        iteration,\n        idMap,\n        edgeEndsIdMap,\n        esize,\n        degrees,\n        sizes\n        );\n    }\n    return nodes;\n  }\n  iterate(\n    iteration: number,\n    idMap: {[key: string]: number},\n    edgeEndsIdMap: {[key: number]: {sourceIdx: number, targetIdx: number}},\n    esize: number,\n    degrees: number[],\n    sizes: number[],\n  ) {\n\n    const self = this;\n    let { nodes } = self;\n    const { kr, preventOverlap } = self;\n    const { barnesHut } = self;\n\n    const nodeNum = nodes.length;\n    let sg = 0;\n    const krPrime = 100;\n    let iter = iteration;\n    const prevoIter = 50;\n    let forces = [];\n    const preForces = [];\n    const bodies = [];\n\n    for (let i = 0; i < nodeNum; i += 1) {\n      forces[2 * i] = 0;\n      forces[2 * i + 1] = 0;\n\n      if (barnesHut) {\n        const params = {\n          id: i,\n          rx: nodes[i].x,\n          ry: nodes[i].y,\n          mass: 1,\n          g: kr,\n          degree: degrees[i]\n        };\n        bodies[i] = new Body(params);\n      }\n    }\n\n    while (iter > 0) {\n      for (let i = 0; i < nodeNum; i += 1) {\n        preForces[2 * i] = forces[2 * i];\n        preForces[2 * i + 1] = forces[2 * i + 1];\n        forces[2 * i] = 0;\n        forces[2 * i + 1] = 0;\n      }\n        // attractive forces, existing on every actual edge\n      forces = this.getAttrForces(\n        iter,\n        prevoIter,\n        esize, \n        idMap,\n        edgeEndsIdMap,\n        degrees,\n        sizes,\n        forces\n      );\n\n      // repulsive forces and Gravity, existing on every node pair\n      // if preventOverlap, using the no-optimized method in the last prevoIter instead.\n      if (barnesHut && ((preventOverlap && iter > prevoIter) || !preventOverlap)) {\n        forces = this.getOptRepGraForces(forces, bodies, degrees);\n      } else {\n        forces = this.getRepGraForces(iter, prevoIter, forces, krPrime, sizes, degrees);\n      }\n      // update the positions\n      const res = this.updatePos(forces, preForces, sg, degrees);\n      nodes = res.nodes;\n      sg = res.sg;\n      iter --;\n      if (self.tick) self.tick();\n    }\n\n    return nodes;\n  }\n  getAttrForces(\n    iter: number,\n    prevoIter: number,\n    esize: number, \n    idMap: {[key: string]: number},\n    edgeEndsIdMap: {[key: number]: {sourceIdx: number, targetIdx: number}},\n    degrees: number[],\n    sizes: number[],\n    forces: number[],\n  ): number[] {\n    const self = this;\n    const { nodes, preventOverlap, dissuadeHubs, mode, prune } = self;\n    for (let i = 0; i < esize; i += 1) {\n      const sourceNode = nodes[edgeEndsIdMap[i].sourceIdx];\n      const sourceIdx = edgeEndsIdMap[i].sourceIdx;\n      const targetNode = nodes[edgeEndsIdMap[i].targetIdx];\n      const targetIdx = edgeEndsIdMap[i].targetIdx;\n\n      if (prune && (degrees[sourceIdx] <= 1 || degrees[targetIdx] <= 1)) continue;\n\n      const dir = [ targetNode.x - sourceNode.x, targetNode.y - sourceNode.y ];\n      let eucliDis = Math.hypot(dir[0], dir[1]);\n      eucliDis = eucliDis < 0.0001 ? 0.0001 : eucliDis;\n      dir[0] = dir[0] / eucliDis;\n      dir[1] = dir[1] / eucliDis;\n\n      if (preventOverlap && iter < prevoIter) eucliDis = eucliDis - sizes[sourceIdx] - sizes[targetIdx];\n      let Fa1 = eucliDis // tslint:disable-line\n      let Fa2 = Fa1 // tslint:disable-line\n      if (mode === 'linlog') {\n        Fa1 = Math.log(1 + eucliDis);\n        Fa2 = Fa1;\n      }\n      if (dissuadeHubs) {\n        Fa1 = eucliDis / degrees[sourceIdx];\n        Fa2 = eucliDis / degrees[targetIdx];\n      }\n      if (preventOverlap && iter < prevoIter && eucliDis <= 0) {\n        Fa1 = 0;\n        Fa2 = 0;\n      } else if (preventOverlap && iter < prevoIter && eucliDis > 0) {\n        Fa1 = eucliDis;\n        Fa2 = eucliDis;\n      }\n      forces[2 * idMap[sourceNode.id]] += Fa1 * dir[0];\n      forces[2 * idMap[targetNode.id]] -= Fa2 * dir[0];\n      forces[2 * idMap[sourceNode.id] + 1] += Fa1 * dir[1];\n      forces[2 * idMap[targetNode.id] + 1] -= Fa2 * dir[1];\n    }\n    return forces;\n  }\n  getRepGraForces(iter: number, prevoIter: number, forces: number[], krPrime: number, sizes: number[], degrees: number[]) {\n    const self = this;\n    const { nodes, preventOverlap, kr, kg, center, prune } = self;\n    const nodeNum = nodes.length;\n    for (let i = 0; i < nodeNum; i += 1) {\n      for (let j = i + 1; j < nodeNum; j += 1) {\n\n        if (prune && (degrees[i] <= 1 || degrees[j] <= 1)) continue;\n\n        const dir = [ nodes[j].x - nodes[i].x, nodes[j].y - nodes[i].y ];\n        let eucliDis = Math.hypot(dir[0], dir[1]);\n        eucliDis = eucliDis < 0.0001 ? 0.0001 : eucliDis;\n        dir[0] = dir[0] / eucliDis;\n        dir[1] = dir[1] / eucliDis;\n\n        if (preventOverlap && iter < prevoIter) eucliDis = eucliDis - sizes[i] - sizes[j];\n\n        let Fr = kr * (degrees[i] + 1) * (degrees[j] + 1) / eucliDis // tslint:disable-line\n\n        if (preventOverlap && iter < prevoIter && eucliDis < 0) {\n          Fr = krPrime * (degrees[i] + 1) * (degrees[j] + 1);\n        } else if (preventOverlap && iter < prevoIter && eucliDis === 0) {\n          Fr = 0;\n        } else if (preventOverlap && iter < prevoIter && eucliDis > 0) {\n          Fr = kr * (degrees[i] + 1) * (degrees[j] + 1) / eucliDis;\n        }\n        forces[2 * i] -= Fr * dir[0];\n        forces[2 * j] += Fr * dir[0];\n        forces[2 * i + 1] -= Fr * dir[1];\n        forces[2 * j + 1] += Fr * dir[1];\n      }\n\n    // gravity\n      const dir = [ nodes[i].x - center[0], nodes[i].y - center[1] ];\n      const eucliDis = Math.hypot(dir[0], dir[1]);\n      dir[0] = dir[0] / eucliDis;\n      dir[1] = dir[1] / eucliDis;\n      const Fg = kg * (degrees[i] + 1) // tslint:disable-line\n      forces[2 * i] -= Fg * dir[0];\n      forces[2 * i + 1] -= Fg * dir[1];\n    }\n    return forces;\n  }\n\n  getOptRepGraForces(forces: number[], bodies: any, degrees: number[]) {\n    const self = this;\n    const { nodes, kg, center, prune } = self;\n    const nodeNum = nodes.length;\n    let minx = 9e10;\n    let maxx = -9e10;\n    let miny = 9e10;\n    let maxy = -9e10;\n    for (let i = 0; i < nodeNum; i += 1) {\n      if (prune && (degrees[i] <= 1)) continue;\n      bodies[i].setPos(nodes[i].x, nodes[i].y);\n      if (nodes[i].x >= maxx) maxx = nodes[i].x;\n      if (nodes[i].x <= minx) minx = nodes[i].x;\n      if (nodes[i].y >= maxy) maxy = nodes[i].y;\n      if (nodes[i].y <= miny) miny = nodes[i].y;\n    }\n\n    const width = Math.max(maxx - minx, maxy - miny);\n\n    const quadParams = {\n      xmid: (maxx + minx) / 2,\n      ymid: (maxy + miny) / 2,\n      length: width,\n      massCenter: center,\n      mass: nodeNum\n    };\n    const quad = new Quad(quadParams);\n    const quadTree = new QuadTree(quad);\n\n  // build the tree, insert the nodes(quads) into the tree\n    for (let i = 0; i < nodeNum; i += 1) {\n\n      if (prune && (degrees[i] <= 1)) continue;\n\n      if (bodies[i].in(quad)) quadTree.insert(bodies[i]);\n    }\n  // update the repulsive forces and the gravity.\n    for (let i = 0; i < nodeNum; i += 1) {\n\n      if (prune && (degrees[i] <= 1)) continue;\n\n      bodies[i].resetForce();\n      quadTree.updateForce(bodies[i]);\n      forces[2 * i] -= bodies[i].fx;\n      forces[2 * i + 1] -= bodies[i].fy;\n\n    // gravity\n      const dir = [ nodes[i].x - center[0], nodes[i].y - center[1] ];\n      let eucliDis = Math.hypot(dir[0], dir[1]);\n      eucliDis = eucliDis < 0.0001 ? 0.0001 : eucliDis;\n      dir[0] = dir[0] / eucliDis;\n      dir[1] = dir[1] / eucliDis;\n      const Fg = kg * (degrees[i] + 1) // tslint:disable-line\n      forces[2 * i] -= Fg * dir[0];\n      forces[2 * i + 1] -= Fg * dir[1];\n    }\n    return forces;\n  }\n\n  updatePos(\n    forces: number[],\n    preForces: number[],\n    sg: number,\n    degrees: number[]\n  ): { nodes: any, sg: number } {\n    const self = this;\n    const { nodes, ks, tao, prune, ksmax } = self;\n    const nodeNum = nodes.length;\n    const swgns = [];\n    const trans = [];\n  // swg(G) and tra(G)\n    let swgG = 0;\n    let traG = 0;\n    for (let i = 0; i < nodeNum; i += 1) {\n\n      if (prune && (degrees[i] <= 1)) continue;\n\n      const minus = [ forces[2 * i] - preForces[2 * i],\n        forces[2 * i + 1] - preForces[2 * i + 1]\n      ];\n      const minusNorm = Math.hypot(minus[0], minus[1]);\n      const add = [ forces[2 * i] + preForces[2 * i],\n        forces[2 * i + 1] + preForces[2 * i + 1]\n      ];\n      const addNorm = Math.hypot(add[0], add[1]);\n\n      swgns[i] = minusNorm;\n      trans[i] = addNorm / 2;\n\n      swgG += (degrees[i] + 1) * swgns[i];\n      traG += (degrees[i] + 1) * trans[i];\n    }\n\n    const preSG = sg;\n    sg = tao * traG / swgG // tslint:disable-line\n    if (preSG !== 0) {\n      sg = sg > (1.5 * preSG) ? (1.5 * preSG) : sg // tslint:disable-line\n    }\n    // update the node positions\n    for (let i = 0; i < nodeNum; i += 1) {\n      if (prune && (degrees[i] <= 1)) continue;\n      if (isNumber(nodes[i].fx) && isNumber(nodes[i].fy)) continue;\n\n      let sn = ks * sg / (1 + sg * Math.sqrt(swgns[i]));\n      let absForce = Math.hypot(forces[2 * i], forces[2 * i + 1]);\n      absForce = absForce < 0.0001 ? 0.0001 : absForce;\n      const max = ksmax / absForce;\n      sn = sn > max ? max : sn;\n      const dnx = sn * forces[2 * i];\n      const dny = sn * forces[2 * i + 1];\n      nodes[i].x += dnx;\n      nodes[i].y += dny;\n    }\n    return { nodes, sg };\n  }\n}\n"]}},"error":null,"hash":"124696851b41cabf74c8bf0e8a59f570","cacheData":{"env":{}}}