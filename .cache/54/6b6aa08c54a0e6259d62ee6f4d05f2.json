{"id":"node_modules/@antv/layout/lib/layout/fruchterman.js","dependencies":[{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\fruchterman.js.map","includedInParent":true,"mtime":1676178923635},{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\src\\layout\\fruchterman.ts","includedInParent":true,"mtime":1676178923893},{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\package.json","includedInParent":true,"mtime":1676178924413},{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\package.json","includedInParent":true,"mtime":1676178923486},{"name":"./base","loc":{"line":23,"column":21,"index":973},"parent":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\fruchterman.js","resolved":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\base.js"},{"name":"../util","loc":{"line":24,"column":21,"index":1005},"parent":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\fruchterman.js","resolved":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\util\\index.js"}],"generated":{"js":"\"use strict\";\n/**\n * @fileOverview fruchterman layout\n * @author shiwu.wyy@antfin.com\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FruchtermanLayout = void 0;\nvar base_1 = require(\"./base\");\nvar util_1 = require(\"../util\");\nvar SPEED_DIVISOR = 800;\n/**\n * fruchterman 布局\n */\nvar FruchtermanLayout = /** @class */ (function (_super) {\n    __extends(FruchtermanLayout, _super);\n    function FruchtermanLayout(options) {\n        var _this = _super.call(this) || this;\n        /** 停止迭代的最大迭代数 */\n        _this.maxIteration = 1000;\n        /** 是否启动 worker */\n        _this.workerEnabled = false;\n        /** 重力大小，影响图的紧凑程度 */\n        _this.gravity = 10;\n        /** 速度 */\n        _this.speed = 5;\n        /** 是否产生聚类力 */\n        _this.clustering = false;\n        /** 聚类力大小 */\n        _this.clusterGravity = 10;\n        _this.nodes = [];\n        _this.edges = [];\n        _this.width = 300;\n        _this.height = 300;\n        _this.nodeMap = {};\n        _this.nodeIdxMap = {};\n        /** 迭代结束的回调函数 */\n        _this.onLayoutEnd = function () { };\n        /** 每次迭代结束的回调函数 */\n        _this.tick = function () { };\n        /** 是否使用 window.setInterval 运行迭代 */\n        _this.animate = true;\n        _this.updateCfg(options);\n        return _this;\n    }\n    FruchtermanLayout.prototype.getDefaultCfg = function () {\n        return {\n            maxIteration: 1000,\n            gravity: 10,\n            speed: 1,\n            clustering: false,\n            clusterGravity: 10,\n            animate: true\n        };\n    };\n    /**\n     * 执行布局\n     */\n    FruchtermanLayout.prototype.execute = function () {\n        var _this = this;\n        var _a, _b;\n        var self = this;\n        var nodes = self.nodes;\n        if (self.timeInterval !== undefined && typeof window !== \"undefined\") {\n            window.clearInterval(self.timeInterval);\n        }\n        if (!nodes || nodes.length === 0) {\n            (_a = self.onLayoutEnd) === null || _a === void 0 ? void 0 : _a.call(self);\n            return;\n        }\n        if (!self.width && typeof window !== \"undefined\") {\n            self.width = window.innerWidth;\n        }\n        if (!self.height && typeof window !== \"undefined\") {\n            self.height = window.innerHeight;\n        }\n        if (!self.center) {\n            self.center = [self.width / 2, self.height / 2];\n        }\n        var center = self.center;\n        if (nodes.length === 1) {\n            nodes[0].x = center[0];\n            nodes[0].y = center[1];\n            (_b = self.onLayoutEnd) === null || _b === void 0 ? void 0 : _b.call(self);\n            return;\n        }\n        var nodeMap = {};\n        var nodeIdxMap = {};\n        nodes.forEach(function (node, i) {\n            if (!(0, util_1.isNumber)(node.x))\n                node.x = Math.random() * _this.width;\n            if (!(0, util_1.isNumber)(node.y))\n                node.y = Math.random() * _this.height;\n            nodeMap[node.id] = node;\n            nodeIdxMap[node.id] = i;\n        });\n        self.nodeMap = nodeMap;\n        self.nodeIdxMap = nodeIdxMap;\n        // layout\n        return self.run();\n    };\n    FruchtermanLayout.prototype.run = function () {\n        var _a;\n        var self = this;\n        var nodes = self.nodes;\n        if (!nodes)\n            return;\n        var edges = self.edges, maxIteration = self.maxIteration, workerEnabled = self.workerEnabled, clustering = self.clustering, animate = self.animate;\n        var clusterMap = {};\n        if (clustering) {\n            nodes.forEach(function (n) {\n                if (clusterMap[n.cluster] === undefined) {\n                    clusterMap[n.cluster] = {\n                        name: n.cluster,\n                        cx: 0,\n                        cy: 0,\n                        count: 0\n                    };\n                }\n            });\n        }\n        if (workerEnabled || !animate) {\n            for (var i = 0; i < maxIteration; i++) {\n                self.runOneStep(clusterMap);\n            }\n            (_a = self.onLayoutEnd) === null || _a === void 0 ? void 0 : _a.call(self);\n        }\n        else {\n            if (typeof window === \"undefined\")\n                return;\n            var iter_1 = 0;\n            // interval for render the result after each iteration\n            this.timeInterval = window.setInterval(function () {\n                var _a;\n                self.runOneStep(clusterMap);\n                iter_1++;\n                if (iter_1 >= maxIteration) {\n                    (_a = self.onLayoutEnd) === null || _a === void 0 ? void 0 : _a.call(self);\n                    window.clearInterval(self.timeInterval);\n                }\n            }, 0);\n        }\n        return {\n            nodes: nodes,\n            edges: edges\n        };\n    };\n    FruchtermanLayout.prototype.runOneStep = function (clusterMap) {\n        var _a;\n        var self = this;\n        var nodes = self.nodes;\n        if (!nodes)\n            return;\n        var edges = self.edges, center = self.center, gravity = self.gravity, speed = self.speed, clustering = self.clustering;\n        var area = self.height * self.width;\n        var maxDisplace = Math.sqrt(area) / 10;\n        var k2 = area / (nodes.length + 1);\n        var k = Math.sqrt(k2);\n        var displacements = [];\n        nodes.forEach(function (_, j) {\n            displacements[j] = { x: 0, y: 0 };\n        });\n        self.applyCalculate(nodes, edges, displacements, k, k2);\n        // gravity for clusters\n        if (clustering) {\n            // re-compute the clustering centers\n            for (var key in clusterMap) {\n                clusterMap[key].cx = 0;\n                clusterMap[key].cy = 0;\n                clusterMap[key].count = 0;\n            }\n            nodes.forEach(function (n) {\n                var c = clusterMap[n.cluster];\n                if ((0, util_1.isNumber)(n.x)) {\n                    c.cx += n.x;\n                }\n                if ((0, util_1.isNumber)(n.y)) {\n                    c.cy += n.y;\n                }\n                c.count++;\n            });\n            for (var key in clusterMap) {\n                clusterMap[key].cx /= clusterMap[key].count;\n                clusterMap[key].cy /= clusterMap[key].count;\n            }\n            // compute the cluster gravity forces\n            var clusterGravity_1 = self.clusterGravity || gravity;\n            nodes.forEach(function (n, j) {\n                if (!(0, util_1.isNumber)(n.x) || !(0, util_1.isNumber)(n.y))\n                    return;\n                var c = clusterMap[n.cluster];\n                var distLength = Math.sqrt((n.x - c.cx) * (n.x - c.cx) + (n.y - c.cy) * (n.y - c.cy));\n                var gravityForce = k * clusterGravity_1;\n                displacements[j].x -= (gravityForce * (n.x - c.cx)) / distLength;\n                displacements[j].y -= (gravityForce * (n.y - c.cy)) / distLength;\n            });\n        }\n        // gravity\n        nodes.forEach(function (n, j) {\n            if (!(0, util_1.isNumber)(n.x) || !(0, util_1.isNumber)(n.y))\n                return;\n            var gravityForce = 0.01 * k * gravity;\n            displacements[j].x -= gravityForce * (n.x - center[0]);\n            displacements[j].y -= gravityForce * (n.y - center[1]);\n        });\n        // move\n        nodes.forEach(function (n, j) {\n            if ((0, util_1.isNumber)(n.fx) && (0, util_1.isNumber)(n.fy)) {\n                n.x = n.fx;\n                n.y = n.fy;\n                return;\n            }\n            if (!(0, util_1.isNumber)(n.x) || !(0, util_1.isNumber)(n.y))\n                return;\n            var distLength = Math.sqrt(displacements[j].x * displacements[j].x +\n                displacements[j].y * displacements[j].y);\n            if (distLength > 0) {\n                // && !n.isFixed()\n                var limitedDist = Math.min(maxDisplace * (speed / SPEED_DIVISOR), distLength);\n                n.x += (displacements[j].x / distLength) * limitedDist;\n                n.y += (displacements[j].y / distLength) * limitedDist;\n            }\n        });\n        (_a = self.tick) === null || _a === void 0 ? void 0 : _a.call(self);\n    };\n    FruchtermanLayout.prototype.applyCalculate = function (nodes, edges, displacements, k, k2) {\n        var self = this;\n        self.calRepulsive(nodes, displacements, k2);\n        if (edges)\n            self.calAttractive(edges, displacements, k);\n    };\n    FruchtermanLayout.prototype.calRepulsive = function (nodes, displacements, k2) {\n        nodes.forEach(function (v, i) {\n            displacements[i] = { x: 0, y: 0 };\n            nodes.forEach(function (u, j) {\n                if (i === j) {\n                    return;\n                }\n                if (!(0, util_1.isNumber)(v.x) ||\n                    !(0, util_1.isNumber)(u.x) ||\n                    !(0, util_1.isNumber)(v.y) ||\n                    !(0, util_1.isNumber)(u.y)) {\n                    return;\n                }\n                var vecX = v.x - u.x;\n                var vecY = v.y - u.y;\n                var vecLengthSqr = vecX * vecX + vecY * vecY;\n                if (vecLengthSqr === 0) {\n                    vecLengthSqr = 1;\n                    var sign = i > j ? 1 : -1;\n                    vecX = 0.01 * sign;\n                    vecY = 0.01 * sign;\n                }\n                var common = k2 / vecLengthSqr;\n                displacements[i].x += vecX * common;\n                displacements[i].y += vecY * common;\n            });\n        });\n    };\n    FruchtermanLayout.prototype.calAttractive = function (edges, displacements, k) {\n        var _this = this;\n        edges.forEach(function (e) {\n            var source = (0, util_1.getEdgeTerminal)(e, 'source');\n            var target = (0, util_1.getEdgeTerminal)(e, 'target');\n            if (!source || !target)\n                return;\n            var uIndex = _this.nodeIdxMap[source];\n            var vIndex = _this.nodeIdxMap[target];\n            if (uIndex === vIndex) {\n                return;\n            }\n            var u = _this.nodeMap[source];\n            var v = _this.nodeMap[target];\n            if (!(0, util_1.isNumber)(v.x) || !(0, util_1.isNumber)(u.x) || !(0, util_1.isNumber)(v.y) || !(0, util_1.isNumber)(u.y)) {\n                return;\n            }\n            var vecX = v.x - u.x;\n            var vecY = v.y - u.y;\n            var vecLength = Math.sqrt(vecX * vecX + vecY * vecY);\n            var common = (vecLength * vecLength) / k;\n            displacements[vIndex].x -= (vecX / vecLength) * common;\n            displacements[vIndex].y -= (vecY / vecLength) * common;\n            displacements[uIndex].x += (vecX / vecLength) * common;\n            displacements[uIndex].y += (vecY / vecLength) * common;\n        });\n    };\n    FruchtermanLayout.prototype.stop = function () {\n        if (this.timeInterval && typeof window !== \"undefined\") {\n            window.clearInterval(this.timeInterval);\n        }\n    };\n    FruchtermanLayout.prototype.destroy = function () {\n        var self = this;\n        self.stop();\n        self.tick = null;\n        self.nodes = null;\n        self.edges = null;\n        self.destroyed = true;\n    };\n    FruchtermanLayout.prototype.getType = function () {\n        return \"fruchterman\";\n    };\n    return FruchtermanLayout;\n}(base_1.Base));\nexports.FruchtermanLayout = FruchtermanLayout;\n"},"sourceMaps":{"js":{"version":3,"file":"fruchterman.js","sourceRoot":"","sources":["../../src/layout/fruchterman.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @fileOverview fruchterman layout\n * @author shiwu.wyy@antfin.com\n */\n\nimport {\n  OutNode,\n  Edge,\n  PointTuple,\n  IndexMap,\n  Point,\n  FruchtermanLayoutOptions\n} from \"./types\";\nimport { Base } from \"./base\";\nimport { getEdgeTerminal, isNumber } from \"../util\";\n\ntype NodeMap = {\n  [key: string]: INode;\n};\n\ntype INode = OutNode & {\n  cluster: string;\n};\n\nconst SPEED_DIVISOR = 800;\n\n/**\n * fruchterman 布局\n */\nexport class FruchtermanLayout extends Base {\n  /** 布局中心 */\n  public center: PointTuple;\n\n  /** 停止迭代的最大迭代数 */\n  public maxIteration: number = 1000;\n\n  /** 是否启动 worker */\n  public workerEnabled: boolean = false;\n\n  /** 重力大小，影响图的紧凑程度 */\n  public gravity: number = 10;\n\n  /** 速度 */\n  public speed: number = 5;\n\n  /** 是否产生聚类力 */\n  public clustering: boolean = false;\n\n  /** 聚类力大小 */\n  public clusterGravity: number = 10;\n\n  public nodes: INode[] | null = [];\n\n  public edges: Edge[] | null = [];\n\n  public width: number = 300;\n\n  public height: number = 300;\n\n  public nodeMap: NodeMap = {};\n\n  public nodeIdxMap: IndexMap = {};\n\n  /** 迭代结束的回调函数 */\n  public onLayoutEnd: () => void = () => {};\n\n  /** 每次迭代结束的回调函数 */\n  public tick: (() => void) | null = () => {};\n\n  /** 是否使用 window.setInterval 运行迭代 */\n  public animate: boolean = true;\n\n  /** 迭代中的标识 */\n  private timeInterval: number;\n\n  constructor(options?: FruchtermanLayoutOptions) {\n    super();\n    this.updateCfg(options);\n  }\n\n  public getDefaultCfg() {\n    return {\n      maxIteration: 1000,\n      gravity: 10,\n      speed: 1,\n      clustering: false,\n      clusterGravity: 10,\n      animate: true\n    };\n  }\n\n  /**\n   * 执行布局\n   */\n  public execute() {\n    const self = this;\n    const nodes = self.nodes;\n\n    if (self.timeInterval !== undefined && typeof window !== \"undefined\") {\n      window.clearInterval(self.timeInterval);\n    }\n\n    if (!nodes || nodes.length === 0) {\n      self.onLayoutEnd?.();\n      return;\n    }\n\n    if (!self.width && typeof window !== \"undefined\") {\n      self.width = window.innerWidth;\n    }\n    if (!self.height && typeof window !== \"undefined\") {\n      self.height = window.innerHeight;\n    }\n    if (!self.center) {\n      self.center = [self.width / 2, self.height / 2];\n    }\n    const center = self.center;\n\n    if (nodes.length === 1) {\n      nodes[0].x = center[0];\n      nodes[0].y = center[1];\n      self.onLayoutEnd?.();\n      return;\n    }\n    const nodeMap: NodeMap = {};\n    const nodeIdxMap: IndexMap = {};\n    nodes.forEach((node, i) => {\n      if (!isNumber(node.x)) node.x = Math.random() * this.width;\n      if (!isNumber(node.y)) node.y = Math.random() * this.height;\n      nodeMap[node.id] = node;\n      nodeIdxMap[node.id] = i;\n    });\n    self.nodeMap = nodeMap;\n    self.nodeIdxMap = nodeIdxMap;\n    // layout\n    return self.run();\n  }\n\n  public run() {\n    const self = this;\n    const nodes = self.nodes;\n    if (!nodes) return;\n    const { edges, maxIteration, workerEnabled, clustering, animate } = self;\n    const clusterMap: {\n      [key: string]: {\n        name: string | number;\n        cx: number;\n        cy: number;\n        count: number;\n      };\n    } = {};\n    if (clustering) {\n      nodes.forEach((n) => {\n        if (clusterMap[n.cluster] === undefined) {\n          clusterMap[n.cluster] = {\n            name: n.cluster,\n            cx: 0,\n            cy: 0,\n            count: 0\n          };\n        }\n      });\n    }\n    if (workerEnabled || !animate) {\n      for (let i = 0; i < maxIteration; i++) {\n        self.runOneStep(clusterMap);\n      }\n      self.onLayoutEnd?.();\n    } else {\n      if (typeof window === \"undefined\") return;\n      let iter = 0;\n      // interval for render the result after each iteration\n      this.timeInterval = window.setInterval(() => {\n        self.runOneStep(clusterMap);\n        iter++;\n        if (iter >= maxIteration) {\n          self.onLayoutEnd?.();\n          window.clearInterval(self.timeInterval);\n        }\n      }, 0);\n    }\n    return {\n      nodes,\n      edges\n    };\n  }\n\n  private runOneStep(clusterMap: any) {\n    const self = this;\n    const nodes = self.nodes;\n    if (!nodes) return;\n    const { edges, center, gravity, speed, clustering } = self;\n    const area = self.height * self.width;\n    const maxDisplace = Math.sqrt(area) / 10;\n    const k2 = area / (nodes.length + 1);\n    const k = Math.sqrt(k2);\n    const displacements: Point[] = [];\n    nodes.forEach((_, j) => {\n      displacements[j] = { x: 0, y: 0 };\n    });\n    self.applyCalculate(nodes, edges, displacements, k, k2);\n\n    // gravity for clusters\n    if (clustering) {\n      // re-compute the clustering centers\n      for (const key in clusterMap) {\n        clusterMap[key].cx = 0;\n        clusterMap[key].cy = 0;\n        clusterMap[key].count = 0;\n      }\n      nodes.forEach((n) => {\n        const c = clusterMap[n.cluster];\n        if (isNumber(n.x)) {\n          c.cx += n.x;\n        }\n        if (isNumber(n.y)) {\n          c.cy += n.y;\n        }\n        c.count++;\n      });\n      for (const key in clusterMap) {\n        clusterMap[key].cx /= clusterMap[key].count;\n        clusterMap[key].cy /= clusterMap[key].count;\n      }\n\n      // compute the cluster gravity forces\n      const clusterGravity = self.clusterGravity || gravity;\n      nodes.forEach((n, j) => {\n        if (!isNumber(n.x) || !isNumber(n.y)) return;\n        const c = clusterMap[n.cluster];\n        const distLength = Math.sqrt(\n          (n.x - c.cx) * (n.x - c.cx) + (n.y - c.cy) * (n.y - c.cy)\n        );\n        const gravityForce = k * clusterGravity;\n        displacements[j].x -= (gravityForce * (n.x - c.cx)) / distLength;\n        displacements[j].y -= (gravityForce * (n.y - c.cy)) / distLength;\n      });\n    }\n\n    // gravity\n    nodes.forEach((n, j) => {\n      if (!isNumber(n.x) || !isNumber(n.y)) return;\n      const gravityForce = 0.01 * k * gravity;\n      displacements[j].x -= gravityForce * (n.x - center[0]);\n      displacements[j].y -= gravityForce * (n.y - center[1]);\n    });\n\n    // move\n    nodes.forEach((n: any, j) => {\n      if (isNumber(n.fx) && isNumber(n.fy)) {\n        n.x = n.fx;\n        n.y = n.fy;\n        return;\n      }\n      if (!isNumber(n.x) || !isNumber(n.y)) return;  \n      const distLength = Math.sqrt(\n        displacements[j].x * displacements[j].x +\n          displacements[j].y * displacements[j].y\n      );\n      if (distLength > 0) {\n        // && !n.isFixed()\n        const limitedDist = Math.min(\n          maxDisplace * (speed / SPEED_DIVISOR),\n          distLength\n        );\n        n.x += (displacements[j].x / distLength) * limitedDist;\n        n.y += (displacements[j].y / distLength) * limitedDist;\n      }\n    });\n\n    self.tick?.();\n  }\n\n  private applyCalculate(\n    nodes: INode[],\n    edges: Edge[] | null,\n    displacements: Point[],\n    k: number,\n    k2: number\n  ) {\n    const self = this;\n    self.calRepulsive(nodes, displacements, k2);\n    if (edges) self.calAttractive(edges, displacements, k);\n  }\n\n  private calRepulsive(nodes: INode[], displacements: Point[], k2: number) {\n    nodes.forEach((v, i) => {\n      displacements[i] = { x: 0, y: 0 };\n      nodes.forEach((u, j) => {\n        if (i === j) {\n          return;\n        }\n        if (\n          !isNumber(v.x) ||\n          !isNumber(u.x) ||\n          !isNumber(v.y) ||\n          !isNumber(u.y)\n        ) {\n          return;\n        }\n        let vecX = v.x - u.x;\n        let vecY = v.y - u.y;\n        let vecLengthSqr = vecX * vecX + vecY * vecY;\n        if (vecLengthSqr === 0) {\n          vecLengthSqr = 1;\n          const sign = i > j ? 1 : -1;\n          vecX = 0.01 * sign;\n          vecY = 0.01 * sign;\n        }\n        const common = k2 / vecLengthSqr;\n        displacements[i].x += vecX * common;\n        displacements[i].y += vecY * common;\n      });\n    });\n  }\n\n  private calAttractive(edges: Edge[], displacements: Point[], k: number) {\n    edges.forEach((e) => {\n      const source = getEdgeTerminal(e, 'source');\n      const target = getEdgeTerminal(e, 'target');\n      if (!source || !target) return;\n      const uIndex = this.nodeIdxMap[source];\n      const vIndex = this.nodeIdxMap[target];\n      if (uIndex === vIndex) {\n        return;\n      }\n      const u = this.nodeMap[source];\n      const v = this.nodeMap[target];\n      if (!isNumber(v.x) || !isNumber(u.x) || !isNumber(v.y) || !isNumber(u.y)) {\n        return;\n      }\n      const vecX = v.x - u.x;\n      const vecY = v.y - u.y;\n      const vecLength = Math.sqrt(vecX * vecX + vecY * vecY);\n      const common = (vecLength * vecLength) / k;\n      displacements[vIndex].x -= (vecX / vecLength) * common;\n      displacements[vIndex].y -= (vecY / vecLength) * common;\n      displacements[uIndex].x += (vecX / vecLength) * common;\n      displacements[uIndex].y += (vecY / vecLength) * common;\n    });\n  }\n\n  public stop() {\n    if (this.timeInterval && typeof window !== \"undefined\") {\n      window.clearInterval(this.timeInterval);\n    }\n  }\n\n  public destroy() {\n    const self = this;\n    self.stop();\n    self.tick = null;\n    self.nodes = null;\n    self.edges = null;\n    self.destroyed = true;\n  }\n\n  public getType() {\n    return \"fruchterman\";\n  }\n}\n"]}},"error":null,"hash":"b76bc4021754d945a2be1fe8d4673ea0","cacheData":{"env":{}}}