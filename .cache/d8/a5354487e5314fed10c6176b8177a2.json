{"id":"node_modules/@antv/layout/lib/layout/dagre/src/greedy-fas.js","dependencies":[{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\greedy-fas.js.map","includedInParent":true,"mtime":1676178923660},{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\src\\layout\\dagre\\src\\greedy-fas.ts","includedInParent":true,"mtime":1676178923927},{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\package.json","includedInParent":true,"mtime":1676178924413},{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\package.json","includedInParent":true,"mtime":1676178923486},{"name":"./data/list","loc":{"line":21,"column":37,"index":1016},"parent":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\greedy-fas.js","resolved":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\data\\list.js"},{"name":"@antv/graphlib","loc":{"line":22,"column":25,"index":1058},"parent":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\greedy-fas.js","resolved":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\graphlib\\es\\index.js"}],"generated":{"js":"\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar list_1 = __importDefault(require(\"./data/list\"));\nvar graphlib_1 = require(\"@antv/graphlib\");\nvar List = /** @class */ (function (_super) {\n    __extends(List, _super);\n    function List() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return List;\n}(list_1.default));\nvar StateGraph = /** @class */ (function (_super) {\n    __extends(StateGraph, _super);\n    function StateGraph() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return StateGraph;\n}(graphlib_1.Graph));\n/*\n * A greedy heuristic for finding a feedback arc set for a graph. A feedback\n * arc set is a set of edges that can be removed to make a graph acyclic.\n * The algorithm comes from: P. Eades, X. Lin, and W. F. Smyth, \"A fast and\n * effective heuristic for the feedback arc set problem.\" This implementation\n * adjusts that from the paper to allow for weighted edges.\n */\nvar DEFAULT_WEIGHT_FN = function () { return 1; };\nvar greedyFAS = function (g, weightFn) {\n    var _a;\n    if (g.nodeCount() <= 1)\n        return [];\n    var state = buildState(g, weightFn || DEFAULT_WEIGHT_FN);\n    var results = doGreedyFAS(state.graph, state.buckets, state.zeroIdx);\n    return (_a = results.map(function (e) { return g.outEdges(e.v, e.w); })) === null || _a === void 0 ? void 0 : _a.flat();\n};\nvar doGreedyFAS = function (g, buckets, zeroIdx) {\n    var results = [];\n    var sources = buckets[buckets.length - 1];\n    var sinks = buckets[0];\n    var entry;\n    while (g.nodeCount()) {\n        while ((entry = sinks.dequeue())) {\n            removeNode(g, buckets, zeroIdx, entry);\n        }\n        while ((entry = sources.dequeue())) {\n            removeNode(g, buckets, zeroIdx, entry);\n        }\n        if (g.nodeCount()) {\n            for (var i = buckets.length - 2; i > 0; --i) {\n                entry = buckets[i].dequeue();\n                if (entry) {\n                    results = results.concat(removeNode(g, buckets, zeroIdx, entry, true));\n                    break;\n                }\n            }\n        }\n    }\n    return results;\n};\nvar removeNode = function (g, buckets, zeroIdx, entry, collectPredecessors) {\n    var _a, _b;\n    var results = [];\n    (_a = g.inEdges(entry.v)) === null || _a === void 0 ? void 0 : _a.forEach(function (edge) {\n        var weight = g.edge(edge);\n        var uEntry = g.node(edge.v);\n        if (collectPredecessors) {\n            // this result not really care about in or out\n            results.push({ v: edge.v, w: edge.w, in: 0, out: 0 });\n        }\n        if (uEntry.out === undefined)\n            uEntry.out = 0;\n        uEntry.out -= weight;\n        assignBucket(buckets, zeroIdx, uEntry);\n    });\n    (_b = g.outEdges(entry.v)) === null || _b === void 0 ? void 0 : _b.forEach(function (edge) {\n        var weight = g.edge(edge);\n        var w = edge.w;\n        var wEntry = g.node(w);\n        if (wEntry.in === undefined)\n            wEntry.in = 0;\n        wEntry.in -= weight;\n        assignBucket(buckets, zeroIdx, wEntry);\n    });\n    g.removeNode(entry.v);\n    return collectPredecessors ? results : undefined;\n};\nvar buildState = function (g, weightFn) {\n    var fasGraph = new StateGraph();\n    var maxIn = 0;\n    var maxOut = 0;\n    g.nodes().forEach(function (v) {\n        fasGraph.setNode(v, { v: v, in: 0, out: 0 });\n    });\n    // Aggregate weights on nodes, but also sum the weights across multi-edges\n    // into a single edge for the fasGraph.\n    g.edges().forEach(function (e) {\n        var prevWeight = fasGraph.edge(e) || 0;\n        var weight = (weightFn === null || weightFn === void 0 ? void 0 : weightFn(e)) || 1;\n        var edgeWeight = prevWeight + weight;\n        fasGraph.setEdge(e.v, e.w, edgeWeight);\n        maxOut = Math.max(maxOut, (fasGraph.node(e.v).out += weight));\n        maxIn = Math.max(maxIn, (fasGraph.node(e.w).in += weight));\n    });\n    var buckets = [];\n    var rangeMax = maxOut + maxIn + 3;\n    for (var i = 0; i < rangeMax; i++) {\n        buckets.push(new List());\n    }\n    var zeroIdx = maxIn + 1;\n    fasGraph.nodes().forEach(function (v) {\n        assignBucket(buckets, zeroIdx, fasGraph.node(v));\n    });\n    return { buckets: buckets, zeroIdx: zeroIdx, graph: fasGraph };\n};\nvar assignBucket = function (buckets, zeroIdx, entry) {\n    if (!entry.out) {\n        buckets[0].enqueue(entry);\n    }\n    else if (!entry[\"in\"]) {\n        buckets[buckets.length - 1].enqueue(entry);\n    }\n    else {\n        buckets[entry.out - entry[\"in\"] + zeroIdx].enqueue(entry);\n    }\n};\nexports.default = greedyFAS;\n"},"sourceMaps":{"js":{"version":3,"file":"greedy-fas.js","sourceRoot":"","sources":["../../../../src/layout/dagre/src/greedy-fas.ts"],"names":[],"mappings":"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","sourcesContent":["import RawList from \"./data/list\";\nimport { Edge, Graph } from \"../graph\";\nimport { Graph as RawGraph } from \"@antv/graphlib\";\n\ntype StateNode = {\n  v: string;\n  w?: string;\n  in: number;\n  out: number;\n  prev?: StateNode;\n  next?: StateNode;\n};\nclass List extends RawList<StateNode> {}\n\nclass StateGraph extends RawGraph<string, StateNode, number> {}\n\n/*\n * A greedy heuristic for finding a feedback arc set for a graph. A feedback\n * arc set is a set of edges that can be removed to make a graph acyclic.\n * The algorithm comes from: P. Eades, X. Lin, and W. F. Smyth, \"A fast and\n * effective heuristic for the feedback arc set problem.\" This implementation\n * adjusts that from the paper to allow for weighted edges.\n */\n\nconst DEFAULT_WEIGHT_FN = () => 1;\n\nconst greedyFAS = (g: Graph, weightFn?: (e: Edge) => number) => {\n  if (g.nodeCount() <= 1) return [];\n  const state = buildState(g, weightFn || DEFAULT_WEIGHT_FN);\n  const results = doGreedyFAS(state.graph, state.buckets, state.zeroIdx);\n\n  return results.map((e) => g.outEdges(e.v, e.w))?.flat();\n};\n\nconst doGreedyFAS = (g: StateGraph, buckets: List[], zeroIdx: number) => {\n  let results: StateNode[] = [];\n  const sources = buckets[buckets.length - 1];\n  const sinks = buckets[0];\n\n  let entry;\n  while (g.nodeCount()) {\n    while ((entry = sinks.dequeue())) {\n      removeNode(g, buckets, zeroIdx, entry);\n    }\n    while ((entry = sources.dequeue())) {\n      removeNode(g, buckets, zeroIdx, entry);\n    }\n    if (g.nodeCount()) {\n      for (let i = buckets.length - 2; i > 0; --i) {\n        entry = buckets[i].dequeue();\n        if (entry) {\n          results = results.concat(\n            removeNode(g, buckets, zeroIdx, entry, true)!\n          );\n          break;\n        }\n      }\n    }\n  }\n\n  return results;\n};\n\nconst removeNode = (\n  g: StateGraph,\n  buckets: List[],\n  zeroIdx: number,\n  entry: StateNode,\n  collectPredecessors?: boolean\n) => {\n  const results: StateNode[] = [];\n\n  g.inEdges(entry.v)?.forEach((edge) => {\n    const weight = g.edge(edge)!;\n    const uEntry = g.node(edge.v)!;\n\n    if (collectPredecessors) {\n      // this result not really care about in or out\n      results.push({ v: edge.v, w: edge.w, in: 0, out: 0 });\n    }\n    if (uEntry.out === undefined) uEntry.out = 0;\n    uEntry.out -= weight;\n    assignBucket(buckets, zeroIdx, uEntry);\n  });\n\n  g.outEdges(entry.v)?.forEach((edge) => {\n    const weight = g.edge(edge)!;\n    const w = edge.w;\n    const wEntry = g.node(w)!;\n    if (wEntry.in === undefined) wEntry.in = 0;\n    wEntry.in -= weight;\n    assignBucket(buckets, zeroIdx, wEntry);\n  });\n\n  g.removeNode(entry.v);\n\n  return collectPredecessors ? results : undefined;\n};\n\nconst buildState = (g: Graph, weightFn?: (param: any) => number) => {\n  const fasGraph = new StateGraph();\n  let maxIn = 0;\n  let maxOut = 0;\n\n  g.nodes().forEach((v) => {\n    fasGraph.setNode(v, { v, in: 0, out: 0 });\n  });\n\n  // Aggregate weights on nodes, but also sum the weights across multi-edges\n  // into a single edge for the fasGraph.\n  g.edges().forEach((e) => {\n    const prevWeight = fasGraph.edge(e) || 0;\n    const weight = weightFn?.(e) || 1;\n    const edgeWeight = prevWeight + weight;\n    fasGraph.setEdge(e.v, e.w, edgeWeight);\n    maxOut = Math.max(maxOut, (fasGraph.node(e.v)!.out += weight));\n    maxIn = Math.max(maxIn, (fasGraph.node(e.w)!.in += weight));\n  });\n\n  const buckets: List[] = [];\n  const rangeMax = maxOut + maxIn + 3;\n  for (let i = 0; i < rangeMax; i++) {\n    buckets.push(new List());\n  }\n  const zeroIdx = maxIn + 1;\n\n  fasGraph.nodes().forEach((v: string) => {\n    assignBucket(buckets, zeroIdx, fasGraph.node(v)!);\n  });\n\n  return { buckets, zeroIdx, graph: fasGraph };\n};\n\nconst assignBucket = (buckets: List[], zeroIdx: number, entry: StateNode) => {\n  if (!entry.out) {\n    buckets[0].enqueue(entry);\n  } else if (!entry[\"in\"]) {\n    buckets[buckets.length - 1].enqueue(entry);\n  } else {\n    buckets[entry.out - entry[\"in\"] + zeroIdx].enqueue(entry);\n  }\n};\n\nexport default greedyFAS;\n"]}},"error":null,"hash":"69030ea4e7e082a76d783bc323687007","cacheData":{"env":{}}}