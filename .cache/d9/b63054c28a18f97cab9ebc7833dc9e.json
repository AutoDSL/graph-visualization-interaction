{"id":"node_modules/@antv/layout/lib/layout/circular.js","dependencies":[{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\circular.js.map","includedInParent":true,"mtime":1676178923550},{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\src\\layout\\circular.ts","includedInParent":true,"mtime":1676178923820},{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\package.json","includedInParent":true,"mtime":1676178924413},{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\package.json","includedInParent":true,"mtime":1676178923486},{"name":"./base","loc":{"line":23,"column":21,"index":965},"parent":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\circular.js","resolved":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\base.js"},{"name":"../util","loc":{"line":24,"column":21,"index":997},"parent":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\circular.js","resolved":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\util\\index.js"}],"generated":{"js":"\"use strict\";\n/**\n * @fileOverview random layout\n * @author shiwu.wyy@antfin.com\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CircularLayout = void 0;\nvar base_1 = require(\"./base\");\nvar util_1 = require(\"../util\");\nfunction initHierarchy(nodes, edges, nodeMap, directed) {\n    nodes.forEach(function (_, i) {\n        nodes[i].children = [];\n        nodes[i].parent = [];\n    });\n    if (directed) {\n        edges.forEach(function (e) {\n            var source = (0, util_1.getEdgeTerminal)(e, 'source');\n            var target = (0, util_1.getEdgeTerminal)(e, 'target');\n            var sourceIdx = 0;\n            if (source) {\n                sourceIdx = nodeMap[source];\n            }\n            var targetIdx = 0;\n            if (target) {\n                targetIdx = nodeMap[target];\n            }\n            var child = nodes[sourceIdx].children;\n            var parent = nodes[targetIdx].parent;\n            child.push(nodes[targetIdx].id);\n            parent.push(nodes[sourceIdx].id);\n        });\n    }\n    else {\n        edges.forEach(function (e) {\n            var source = (0, util_1.getEdgeTerminal)(e, 'source');\n            var target = (0, util_1.getEdgeTerminal)(e, 'target');\n            var sourceIdx = 0;\n            if (source) {\n                sourceIdx = nodeMap[source];\n            }\n            var targetIdx = 0;\n            if (target) {\n                targetIdx = nodeMap[target];\n            }\n            var sourceChildren = nodes[sourceIdx].children;\n            var targetChildren = nodes[targetIdx].children;\n            sourceChildren.push(nodes[targetIdx].id);\n            targetChildren.push(nodes[sourceIdx].id);\n        });\n    }\n}\nfunction connect(a, b, edges) {\n    var m = edges.length;\n    for (var i = 0; i < m; i++) {\n        var source = (0, util_1.getEdgeTerminal)(edges[i], 'source');\n        var target = (0, util_1.getEdgeTerminal)(edges[i], 'target');\n        if ((a.id === source && b.id === target) ||\n            (b.id === source && a.id === target)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction compareDegree(a, b) {\n    var aDegree = a.degree;\n    var bDegree = b.degree;\n    if (aDegree < bDegree) {\n        return -1;\n    }\n    if (aDegree > bDegree) {\n        return 1;\n    }\n    return 0;\n}\n/**\n * 圆形布局\n */\nvar CircularLayout = /** @class */ (function (_super) {\n    __extends(CircularLayout, _super);\n    function CircularLayout(options) {\n        var _this = _super.call(this) || this;\n        /** 固定半径，若设置了 radius，则 startRadius 与 endRadius 不起效 */\n        _this.radius = null;\n        /** 节点大小，配合 nodeSpacing，一起用于计算 radius。若不配置，节点大小默认为 30 */\n        _this.nodeSize = undefined;\n        /** 起始半径 */\n        _this.startRadius = null;\n        /** 终止半径 */\n        _this.endRadius = null;\n        /** 起始角度 */\n        _this.startAngle = 0;\n        /** 终止角度 */\n        _this.endAngle = 2 * Math.PI;\n        /** 是否顺时针 */\n        _this.clockwise = true;\n        /** 节点在环上分成段数（几个段将均匀分布），在 endRadius - startRadius != 0 时生效 */\n        _this.divisions = 1;\n        /** 节点在环上排序的依据，可选: 'topology', 'degree', 'null' */\n        _this.ordering = null;\n        /** how many 2*pi from first to last nodes */\n        _this.angleRatio = 1;\n        _this.nodes = [];\n        _this.edges = [];\n        _this.nodeMap = {};\n        _this.degrees = [];\n        _this.width = 300;\n        _this.height = 300;\n        _this.updateCfg(options);\n        return _this;\n    }\n    CircularLayout.prototype.getDefaultCfg = function () {\n        return {\n            radius: null,\n            startRadius: null,\n            endRadius: null,\n            startAngle: 0,\n            endAngle: 2 * Math.PI,\n            clockwise: true,\n            divisions: 1,\n            ordering: null,\n            angleRatio: 1\n        };\n    };\n    /**\n     * 执行布局\n     */\n    CircularLayout.prototype.execute = function () {\n        var _a;\n        var self = this;\n        var nodes = self.nodes;\n        var edges = self.edges;\n        var n = nodes.length;\n        if (n === 0) {\n            if (self.onLayoutEnd)\n                self.onLayoutEnd();\n            return;\n        }\n        if (!self.width && typeof window !== \"undefined\") {\n            self.width = window.innerWidth;\n        }\n        if (!self.height && typeof window !== \"undefined\") {\n            self.height = window.innerHeight;\n        }\n        if (!self.center) {\n            self.center = [self.width / 2, self.height / 2];\n        }\n        var center = self.center;\n        if (n === 1) {\n            nodes[0].x = center[0];\n            nodes[0].y = center[1];\n            if (self.onLayoutEnd)\n                self.onLayoutEnd();\n            return;\n        }\n        var radius = self.radius, startRadius = self.startRadius, endRadius = self.endRadius;\n        var divisions = self.divisions, startAngle = self.startAngle, endAngle = self.endAngle, angleRatio = self.angleRatio, ordering = self.ordering, clockwise = self.clockwise, paramNodeSpacing = self.nodeSpacing, paramNodeSize = self.nodeSize;\n        var angleStep = (endAngle - startAngle) / n;\n        // layout\n        var nodeMap = {};\n        nodes.forEach(function (node, i) {\n            nodeMap[node.id] = i;\n        });\n        self.nodeMap = nodeMap;\n        var degrees = (0, util_1.getDegree)(nodes.length, nodeMap, edges);\n        self.degrees = degrees;\n        if (paramNodeSpacing) {\n            var nodeSpacing_1 = (0, util_1.getFuncByUnknownType)(10, paramNodeSpacing);\n            var nodeSize_1 = (0, util_1.getFuncByUnknownType)(10, paramNodeSize);\n            var maxNodeSize_1 = -Infinity;\n            nodes.forEach(function (node) {\n                var nSize = nodeSize_1(node);\n                if (maxNodeSize_1 < nSize)\n                    maxNodeSize_1 = nSize;\n            });\n            var length_1 = 0;\n            nodes.forEach(function (node, i) {\n                if (i === 0)\n                    length_1 += (maxNodeSize_1 || 10);\n                else\n                    length_1 += (nodeSpacing_1(node) || 0) + (maxNodeSize_1 || 10);\n            });\n            radius = length_1 / (2 * Math.PI);\n        }\n        else if (!radius && !startRadius && !endRadius) {\n            radius = self.height > self.width ? self.width / 2 : self.height / 2;\n        }\n        else if (!startRadius && endRadius) {\n            startRadius = endRadius;\n        }\n        else if (startRadius && !endRadius) {\n            endRadius = startRadius;\n        }\n        var astep = angleStep * angleRatio;\n        var layoutNodes = [];\n        if (ordering === \"topology\") {\n            // layout according to the topology\n            layoutNodes = self.topologyOrdering();\n        }\n        else if (ordering === \"topology-directed\") {\n            // layout according to the topology\n            layoutNodes = self.topologyOrdering(true);\n        }\n        else if (ordering === \"degree\") {\n            // layout according to the descent order of degrees\n            layoutNodes = self.degreeOrdering();\n        }\n        else {\n            // layout according to the original order in the data.nodes\n            layoutNodes = nodes;\n        }\n        var divN = Math.ceil(n / divisions); // node number in each division\n        for (var i = 0; i < n; ++i) {\n            var r = radius;\n            if (!r && startRadius !== null && endRadius !== null) {\n                r = startRadius + (i * (endRadius - startRadius)) / (n - 1);\n            }\n            if (!r) {\n                r = 10 + (i * 100) / (n - 1);\n            }\n            var angle = startAngle +\n                (i % divN) * astep +\n                ((2 * Math.PI) / divisions) * Math.floor(i / divN);\n            if (!clockwise) {\n                angle =\n                    endAngle -\n                        (i % divN) * astep -\n                        ((2 * Math.PI) / divisions) * Math.floor(i / divN);\n            }\n            layoutNodes[i].x = center[0] + Math.cos(angle) * r;\n            layoutNodes[i].y = center[1] + Math.sin(angle) * r;\n            layoutNodes[i].weight = degrees[i].all;\n        }\n        (_a = self.onLayoutEnd) === null || _a === void 0 ? void 0 : _a.call(self);\n        return {\n            nodes: layoutNodes,\n            edges: this.edges\n        };\n    };\n    /**\n     * 根据节点的拓扑结构排序\n     * @return {array} orderedNodes 排序后的结果\n     */\n    CircularLayout.prototype.topologyOrdering = function (directed) {\n        if (directed === void 0) { directed = false; }\n        var self = this;\n        var degrees = self.degrees;\n        var edges = self.edges;\n        var nodes = self.nodes;\n        var cnodes = (0, util_1.clone)(nodes);\n        var nodeMap = self.nodeMap;\n        var orderedCNodes = [cnodes[0]];\n        var resNodes = [nodes[0]];\n        var pickFlags = [];\n        var n = nodes.length;\n        pickFlags[0] = true;\n        initHierarchy(cnodes, edges, nodeMap, directed);\n        var k = 0;\n        cnodes.forEach(function (cnode, i) {\n            if (i !== 0) {\n                if ((i === n - 1 ||\n                    degrees[i].all !== degrees[i + 1].all ||\n                    connect(orderedCNodes[k], cnode, edges)) &&\n                    !pickFlags[i]) {\n                    orderedCNodes.push(cnode);\n                    resNodes.push(nodes[nodeMap[cnode.id]]);\n                    pickFlags[i] = true;\n                    k++;\n                }\n                else {\n                    var children = orderedCNodes[k].children;\n                    var foundChild = false;\n                    for (var j = 0; j < children.length; j++) {\n                        var childIdx = nodeMap[children[j]];\n                        if (degrees[childIdx].all === degrees[i].all && !pickFlags[childIdx]) {\n                            orderedCNodes.push(cnodes[childIdx]);\n                            resNodes.push(nodes[nodeMap[cnodes[childIdx].id]]);\n                            pickFlags[childIdx] = true;\n                            foundChild = true;\n                            break;\n                        }\n                    }\n                    var ii = 0;\n                    while (!foundChild) {\n                        if (!pickFlags[ii]) {\n                            orderedCNodes.push(cnodes[ii]);\n                            resNodes.push(nodes[nodeMap[cnodes[ii].id]]);\n                            pickFlags[ii] = true;\n                            foundChild = true;\n                        }\n                        ii++;\n                        if (ii === n) {\n                            break;\n                        }\n                    }\n                }\n            }\n        });\n        return resNodes;\n    };\n    /**\n     * 根据节点度数大小排序\n     * @return {array} orderedNodes 排序后的结果\n     */\n    CircularLayout.prototype.degreeOrdering = function () {\n        var self = this;\n        var nodes = self.nodes;\n        var orderedNodes = [];\n        var degrees = self.degrees;\n        nodes.forEach(function (node, i) {\n            node.degree = degrees[i].all;\n            orderedNodes.push(node);\n        });\n        orderedNodes.sort(compareDegree);\n        return orderedNodes;\n    };\n    CircularLayout.prototype.getType = function () {\n        return \"circular\";\n    };\n    return CircularLayout;\n}(base_1.Base));\nexports.CircularLayout = CircularLayout;\n"},"sourceMaps":{"js":{"version":3,"file":"circular.js","sourceRoot":"","sources":["../../src/layout/circular.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @fileOverview random layout\n * @author shiwu.wyy@antfin.com\n */\n\nimport {\n  OutNode,\n  Edge,\n  PointTuple,\n  IndexMap,\n  CircularLayoutOptions,\n  Degree\n} from \"./types\";\nimport { Base } from \"./base\";\nimport { getDegree, clone, getEdgeTerminal, getFuncByUnknownType } from \"../util\";\n\ntype INode = OutNode & {\n  degree: number;\n  size: number | PointTuple;\n  weight: number;\n  children: string[];\n  parent: string[];\n};\n\nfunction initHierarchy(\n  nodes: INode[],\n  edges: Edge[],\n  nodeMap: IndexMap,\n  directed: boolean\n) {\n  nodes.forEach((_, i: number) => {\n    nodes[i].children = [];\n    nodes[i].parent = [];\n  });\n  if (directed) {\n    edges.forEach((e) => {\n      const source = getEdgeTerminal(e, 'source');\n      const target = getEdgeTerminal(e, 'target');\n      let sourceIdx = 0;\n      if (source) {\n        sourceIdx = nodeMap[source];\n      }\n      let targetIdx = 0;\n      if (target) {\n        targetIdx = nodeMap[target];\n      }\n      const child = nodes[sourceIdx].children!;\n      const parent = nodes[targetIdx].parent!;\n      child.push(nodes[targetIdx].id);\n      parent.push(nodes[sourceIdx].id);\n    });\n  } else {\n    edges.forEach((e) => {\n      const source = getEdgeTerminal(e, 'source');\n      const target = getEdgeTerminal(e, 'target');\n      let sourceIdx = 0;\n      if (source) {\n        sourceIdx = nodeMap[source];\n      }\n      let targetIdx = 0;\n      if (target) {\n        targetIdx = nodeMap[target];\n      }\n      const sourceChildren = nodes[sourceIdx].children!;\n      const targetChildren = nodes[targetIdx].children!;\n      sourceChildren.push(nodes[targetIdx].id);\n      targetChildren.push(nodes[sourceIdx].id);\n    });\n  }\n}\n\nfunction connect(a: INode, b: INode, edges: Edge[]) {\n  const m = edges.length;\n  for (let i = 0; i < m; i++) {\n    const source = getEdgeTerminal(edges[i], 'source');\n    const target = getEdgeTerminal(edges[i], 'target');\n    if (\n      (a.id === source && b.id === target) ||\n      (b.id === source && a.id === target)\n    ) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction compareDegree(a: INode, b: INode) {\n  const aDegree = a.degree!;\n  const bDegree = b.degree!;\n  if (aDegree < bDegree) {\n    return -1;\n  }\n  if (aDegree > bDegree) {\n    return 1;\n  }\n  return 0;\n}\n\n/**\n * 圆形布局\n */\nexport class CircularLayout extends Base {\n  /** 布局中心 */\n  public center: PointTuple;\n\n  /** 固定半径，若设置了 radius，则 startRadius 与 endRadius 不起效 */\n  public radius: number | null = null;\n\n  /** 节点间距，若设置 nodeSpacing，则 radius 将被自动计算，即设置 radius 不生效 */\n  public nodeSpacing: ((d?: unknown) => number) | number | undefined;\n\n  /** 节点大小，配合 nodeSpacing，一起用于计算 radius。若不配置，节点大小默认为 30 */\n  public nodeSize: number | undefined = undefined;\n\n  /** 起始半径 */\n  public startRadius: number | null = null;\n\n  /** 终止半径 */\n  public endRadius: number | null = null;\n\n  /** 起始角度 */\n  public startAngle: number = 0;\n\n  /** 终止角度 */\n  public endAngle: number = 2 * Math.PI;\n\n  /** 是否顺时针 */\n  public clockwise: boolean = true;\n\n  /** 节点在环上分成段数（几个段将均匀分布），在 endRadius - startRadius != 0 时生效 */\n  public divisions: number = 1;\n\n  /** 节点在环上排序的依据，可选: 'topology', 'degree', 'null' */\n  public ordering: \"topology\" | \"topology-directed\" | \"degree\" | null = null;\n\n  /** how many 2*pi from first to last nodes */\n  public angleRatio = 1;\n\n  public nodes: INode[] = [];\n\n  public edges: Edge[] = [];\n\n  private nodeMap: IndexMap = {};\n\n  private degrees: Degree[] = [];\n\n  public width: number = 300;\n\n  public height: number = 300;\n\n  public onLayoutEnd: () => void;\n\n  constructor(options?: CircularLayoutOptions) {\n    super();\n    this.updateCfg(options);\n  }\n\n  public getDefaultCfg() {\n    return {\n      radius: null,\n      startRadius: null,\n      endRadius: null,\n      startAngle: 0,\n      endAngle: 2 * Math.PI,\n      clockwise: true,\n      divisions: 1,\n      ordering: null,\n      angleRatio: 1\n    };\n  }\n\n  /**\n   * 执行布局\n   */\n  public execute() {\n    const self = this;\n    const nodes = self.nodes;\n    const edges = self.edges;\n    const n = nodes.length;\n    if (n === 0) {\n      if (self.onLayoutEnd) self.onLayoutEnd();\n      return;\n    }\n\n    if (!self.width && typeof window !== \"undefined\") {\n      self.width = window.innerWidth;\n    }\n    if (!self.height && typeof window !== \"undefined\") {\n      self.height = window.innerHeight;\n    }\n    if (!self.center) {\n      self.center = [self.width / 2, self.height / 2];\n    }\n    const center = self.center;\n\n    if (n === 1) {\n      nodes[0].x = center[0];\n      nodes[0].y = center[1];\n      if (self.onLayoutEnd) self.onLayoutEnd();\n      return;\n    }\n\n    let { radius, startRadius, endRadius } = self;\n    const { divisions, startAngle, endAngle, angleRatio, ordering, clockwise, nodeSpacing: paramNodeSpacing, nodeSize: paramNodeSize } = self;\n    const angleStep = (endAngle - startAngle) / n;\n    // layout\n    const nodeMap: IndexMap = {};\n    nodes.forEach((node, i) => {\n      nodeMap[node.id] = i;\n    });\n    self.nodeMap = nodeMap;\n    const degrees = getDegree(nodes.length, nodeMap, edges);\n    self.degrees = degrees;\n    if (paramNodeSpacing) {\n      const nodeSpacing: Function = getFuncByUnknownType(10, paramNodeSpacing);\n      const nodeSize: Function = getFuncByUnknownType(10, paramNodeSize);\n      let maxNodeSize = -Infinity;\n      nodes.forEach((node) => {\n        const nSize = nodeSize(node);\n        if (maxNodeSize < nSize) maxNodeSize = nSize;\n      });\n      let length = 0;\n      nodes.forEach((node, i) => {\n        if (i === 0) length += (maxNodeSize || 10);\n        else length += (nodeSpacing(node) || 0) + (maxNodeSize || 10);\n      });\n      radius = length / (2 * Math.PI);\n    } else if (!radius && !startRadius && !endRadius) {\n      radius = self.height > self.width ? self.width / 2 : self.height / 2;\n    } else if (!startRadius && endRadius) {\n      startRadius = endRadius;\n    } else if (startRadius && !endRadius) {\n      endRadius = startRadius;\n    }\n    const astep = angleStep * angleRatio;\n\n    let layoutNodes = [];\n    if (ordering === \"topology\") {\n      // layout according to the topology\n      layoutNodes = self.topologyOrdering();\n    } else if (ordering === \"topology-directed\") {\n      // layout according to the topology\n      layoutNodes = self.topologyOrdering(true);\n    } else if (ordering === \"degree\") {\n      // layout according to the descent order of degrees\n      layoutNodes = self.degreeOrdering();\n    } else {\n      // layout according to the original order in the data.nodes\n      layoutNodes = nodes;\n    }\n\n    const divN = Math.ceil(n / divisions); // node number in each division\n    for (let i = 0; i < n; ++i) {\n      let r = radius;\n      if (!r && startRadius !== null && endRadius !== null) {\n        r = startRadius + (i * (endRadius - startRadius)) / (n - 1);\n      }\n      if (!r) {\n        r = 10 + (i * 100) / (n - 1);\n      }\n      let angle =\n        startAngle +\n        (i % divN) * astep +\n        ((2 * Math.PI) / divisions) * Math.floor(i / divN);\n      if (!clockwise) {\n        angle =\n          endAngle -\n          (i % divN) * astep -\n          ((2 * Math.PI) / divisions) * Math.floor(i / divN);\n      }\n      layoutNodes[i].x = center[0] + Math.cos(angle) * r;\n      layoutNodes[i].y = center[1] + Math.sin(angle) * r;\n      layoutNodes[i].weight = degrees[i].all;\n    }\n\n    self.onLayoutEnd?.();\n\n    return {\n      nodes: layoutNodes,\n      edges: this.edges\n    };\n  }\n\n  /**\n   * 根据节点的拓扑结构排序\n   * @return {array} orderedNodes 排序后的结果\n   */\n  public topologyOrdering(directed: boolean = false) {\n    const self = this;\n    const degrees = self.degrees;\n    const edges = self.edges;\n    const nodes = self.nodes;\n    const cnodes = clone(nodes);\n    const nodeMap = self.nodeMap;\n    const orderedCNodes = [cnodes[0]];\n    const resNodes = [nodes[0]];\n    const pickFlags: boolean[] = [];\n    const n = nodes.length;\n    pickFlags[0] = true;\n    initHierarchy(cnodes, edges, nodeMap, directed);\n    let k = 0;\n    cnodes.forEach((cnode, i) => {\n      if (i !== 0) {\n        if (\n          (i === n - 1 ||\n            degrees[i].all !== degrees[i + 1].all ||\n            connect(\n              orderedCNodes[k],\n              cnode,\n              edges\n            )) &&\n          !pickFlags[i]\n        ) {\n          orderedCNodes.push(cnode);\n          resNodes.push(nodes[nodeMap[cnode.id]]);\n          pickFlags[i] = true;\n          k++;\n        } else {\n          const children = orderedCNodes[k].children!;\n          let foundChild = false;\n          for (let j = 0; j < children.length; j++) {\n            const childIdx = nodeMap[children[j]];\n            if (degrees[childIdx].all === degrees[i].all && !pickFlags[childIdx]) {\n              orderedCNodes.push(cnodes[childIdx]);\n              resNodes.push(nodes[nodeMap[cnodes[childIdx].id]]);\n              pickFlags[childIdx] = true;\n              foundChild = true;\n              break;\n            }\n          }\n          let ii = 0;\n          while (!foundChild) {\n            if (!pickFlags[ii]) {\n              orderedCNodes.push(cnodes[ii]);\n              resNodes.push(nodes[nodeMap[cnodes[ii].id]]);\n              pickFlags[ii] = true;\n              foundChild = true;\n            }\n            ii++;\n            if (ii === n) {\n              break;\n            }\n          }\n        }\n      }\n    });\n    return resNodes;\n  }\n\n  /**\n   * 根据节点度数大小排序\n   * @return {array} orderedNodes 排序后的结果\n   */\n  public degreeOrdering(): INode[] {\n    const self = this;\n    const nodes = self.nodes;\n    const orderedNodes: INode[] = [];\n    const degrees = self.degrees;\n    nodes.forEach((node, i) => {\n      node.degree = degrees[i].all;\n      orderedNodes.push(node);\n    });\n    orderedNodes.sort(compareDegree);\n    return orderedNodes;\n  }\n\n  public getType() {\n    return \"circular\";\n  }\n}\n"]}},"error":null,"hash":"672d4f13cc0d6c2cc5f58c73be53fbde","cacheData":{"env":{}}}