{"id":"node_modules/@antv/layout/lib/layout/dagre/src/order/init-order.js","dependencies":[{"name":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\order\\init-order.js.map","includedInParent":true,"mtime":499162500000},{"name":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\src\\layout\\dagre\\src\\order\\init-order.ts","includedInParent":true,"mtime":499162500000},{"name":"D:\\myData\\前端\\doing\\AutoPL\\package.json","includedInParent":true,"mtime":1674182060254},{"name":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\package.json","includedInParent":true,"mtime":1674179681168}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Assigns an initial order value for each node by performing a DFS search\n * starting from nodes in the first rank. Nodes are assigned an order in their\n * rank as they are first visited.\n *\n * This approach comes from Gansner, et al., \"A Technique for Drawing Directed\n * Graphs.\"\n *\n * Returns a layering matrix with an array per layer and each layer sorted by\n * the order of its nodes.\n */\nvar initOrder = function (g) {\n    var visited = {};\n    var simpleNodes = g.nodes().filter(function (v) {\n        var _a;\n        return !((_a = g.children(v)) === null || _a === void 0 ? void 0 : _a.length);\n    });\n    var nodeRanks = simpleNodes.map(function (v) { return g.node(v).rank; });\n    var maxRank = Math.max.apply(Math, nodeRanks);\n    var layers = [];\n    for (var i = 0; i < maxRank + 1; i++) {\n        layers.push([]);\n    }\n    var dfs = function (v) {\n        var _a;\n        if (visited.hasOwnProperty(v))\n            return;\n        visited[v] = true;\n        var node = g.node(v);\n        if (!isNaN(node.rank)) {\n            layers[node.rank].push(v);\n        }\n        (_a = g.successors(v)) === null || _a === void 0 ? void 0 : _a.forEach(function (child) { return dfs(child); });\n    };\n    var orderedVs = simpleNodes.sort(function (a, b) { return g.node(a).rank - g.node(b).rank; });\n    // const orderedVs = _.sortBy(simpleNodes, function(v) { return g.node(v)!.rank; });\n    // 有fixOrder的，直接排序好放进去\n    var beforeSort = orderedVs.filter(function (n) {\n        return g.node(n).fixorder !== undefined;\n    });\n    var fixOrderNodes = beforeSort.sort(function (a, b) { return g.node(a).fixorder - g.node(b).fixorder; });\n    fixOrderNodes === null || fixOrderNodes === void 0 ? void 0 : fixOrderNodes.forEach(function (n) {\n        if (!isNaN(g.node(n).rank)) {\n            layers[g.node(n).rank].push(n);\n        }\n        visited[n] = true;\n    });\n    orderedVs === null || orderedVs === void 0 ? void 0 : orderedVs.forEach(dfs);\n    return layers;\n};\nexports.default = initOrder;\n"},"sourceMaps":{"js":{"version":3,"file":"init-order.js","sourceRoot":"","sources":["../../../../../src/layout/dagre/src/order/init-order.ts"],"names":[],"mappings":";;AAEA;;;;;;;;;;GAUG;AACH,IAAM,SAAS,GAAG,UAAC,CAAQ;IACzB,IAAM,OAAO,GAA4B,EAAE,CAAC;IAC5C,IAAM,WAAW,GAAG,CAAC,CAAC,KAAK,EAAE,CAAC,MAAM,CAAC,UAAC,CAAC;;QACrC,OAAO,CAAC,CAAA,MAAA,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,0CAAE,MAAM,CAAA,CAAC;IAChC,CAAC,CAAC,CAAC;IACH,IAAM,SAAS,GAAG,WAAW,CAAC,GAAG,CAAC,UAAC,CAAC,IAAK,OAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAE,CAAC,IAAe,EAA3B,CAA2B,CAAC,CAAC;IACtE,IAAM,OAAO,GAAG,IAAI,CAAC,GAAG,OAAR,IAAI,EAAQ,SAAS,CAAC,CAAC;IACvC,IAAM,MAAM,GAAe,EAAE,CAAC;IAC9B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE;QACpC,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;KACjB;IAED,IAAM,GAAG,GAAG,UAAC,CAAS;;QACpB,IAAI,OAAO,CAAC,cAAc,CAAC,CAAC,CAAC;YAAE,OAAO;QACtC,OAAO,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC;QAClB,IAAM,IAAI,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,CAAE,CAAC;QACxB,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAc,CAAC,EAAE;YAC/B,MAAM,CAAC,IAAI,CAAC,IAAc,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;SACrC;QACD,MAAA,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,0CAAE,OAAO,CAAC,UAAC,KAAK,IAAK,OAAA,GAAG,CAAC,KAAY,CAAC,EAAjB,CAAiB,CAAC,CAAC;IACzD,CAAC,CAAC;IAEF,IAAM,SAAS,GAAG,WAAW,CAAC,IAAI,CAAC,UAAC,CAAC,EAAE,CAAC,IAAK,OAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAE,CAAC,IAAe,GAAI,CAAC,CAAC,IAAI,CAAC,CAAC,CAAE,CAAC,IAAe,EAAzD,CAAyD,CAAC,CAAC;IACxG,oFAAoF;IAEpF,sBAAsB;IACtB,IAAM,UAAU,GAAG,SAAS,CAAC,MAAM,CAAC,UAAC,CAAC;QACpC,OAAO,CAAC,CAAC,IAAI,CAAC,CAAC,CAAE,CAAC,QAAQ,KAAK,SAAS,CAAC;IAC3C,CAAC,CAAC,CAAC;IACH,IAAM,aAAa,GAAG,UAAU,CAAC,IAAI,CAAC,UAAC,CAAC,EAAE,CAAC,IAAK,OAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAE,CAAC,QAAmB,GAAI,CAAC,CAAC,IAAI,CAAC,CAAC,CAAE,CAAC,QAAmB,EAAjE,CAAiE,CAAC,CAAC;IACnH,aAAa,aAAb,aAAa,uBAAb,aAAa,CAAE,OAAO,CAAC,UAAC,CAAC;QACvB,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAE,CAAC,IAAc,CAAC,EAAE;YACrC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAE,CAAC,IAAc,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;SAC3C;QACD,OAAO,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC;IACpB,CAAC,CAAC,CAAC;IAEH,SAAS,aAAT,SAAS,uBAAT,SAAS,CAAE,OAAO,CAAC,GAAG,CAAC,CAAC;IAExB,OAAO,MAAM,CAAC;AAChB,CAAC,CAAC;AAEF,kBAAe,SAAS,CAAC","sourcesContent":["import { Graph } from \"../../graph\";\n\n/*\n * Assigns an initial order value for each node by performing a DFS search\n * starting from nodes in the first rank. Nodes are assigned an order in their\n * rank as they are first visited.\n *\n * This approach comes from Gansner, et al., \"A Technique for Drawing Directed\n * Graphs.\"\n *\n * Returns a layering matrix with an array per layer and each layer sorted by\n * the order of its nodes.\n */\nconst initOrder = (g: Graph) => {\n  const visited: Record<string, boolean> = {};\n  const simpleNodes = g.nodes().filter((v) => {\n    return !g.children(v)?.length;\n  });\n  const nodeRanks = simpleNodes.map((v) => (g.node(v)!.rank as number));\n  const maxRank = Math.max(...nodeRanks);\n  const layers: string[][] = [];\n  for (let i = 0; i < maxRank + 1; i++) {\n    layers.push([]);\n  }\n\n  const dfs = (v: string) => {\n    if (visited.hasOwnProperty(v)) return;\n    visited[v] = true;\n    const node = g.node(v)!;\n    if (!isNaN(node.rank as number)) {\n      layers[node.rank as number].push(v);\n    }\n    g.successors(v)?.forEach((child) => dfs(child as any));\n  };\n\n  const orderedVs = simpleNodes.sort((a, b) => (g.node(a)!.rank as number) - (g.node(b)!.rank as number));\n  // const orderedVs = _.sortBy(simpleNodes, function(v) { return g.node(v)!.rank; });\n\n  // 有fixOrder的，直接排序好放进去\n  const beforeSort = orderedVs.filter((n) => {\n    return g.node(n)!.fixorder !== undefined;\n  });\n  const fixOrderNodes = beforeSort.sort((a, b) => (g.node(a)!.fixorder as number) - (g.node(b)!.fixorder as number));\n  fixOrderNodes?.forEach((n) => {\n    if (!isNaN(g.node(n)!.rank as number)) {\n      layers[g.node(n)!.rank as number].push(n);\n    }\n    visited[n] = true;\n  });\n\n  orderedVs?.forEach(dfs);\n\n  return layers;\n};\n\nexport default initOrder;"]}},"error":null,"hash":"22ef5121ebf6a30a0992313d32b2c5a0","cacheData":{"env":{}}}