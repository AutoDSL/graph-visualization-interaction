{"id":"node_modules/@antv/layout/lib/layout/er/mysqlWorkbench.js","dependencies":[{"name":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\lib\\layout\\er\\mysqlWorkbench.js.map","includedInParent":true,"mtime":499162500000},{"name":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\src\\layout\\er\\mysqlWorkbench.ts","includedInParent":true,"mtime":499162500000},{"name":"D:\\myData\\前端\\doing\\AutoPL\\package.json","includedInParent":true,"mtime":1674182060254},{"name":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\package.json","includedInParent":true,"mtime":1674179681168}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graphWidth = 1200;\nvar graphHeight = 800;\nvar OVERLAP_QUOT = 10000000;\nvar MIN_DIST = 10;\nvar M_PI = 3.14159265358979323846;\nvar M_PI_2 = 1.57079632679489661923;\nvar PI_38 = M_PI * 0.375;\nvar PI_58 = M_PI * 0.625;\nvar nodeEdgeMap = new Map();\nvar CELL_W = 10;\nvar CELL_H = 10;\nvar T = 0.8;\nvar T_MIN = 0.1;\nvar R = 0.5;\nfunction distanceToNode(node1, node2, isHoriz) {\n    var x11 = node1.x - node1.size[0] / 2;\n    var y11 = node1.y - node1.size[1] / 2;\n    var x12 = node1.x + node1.size[0] / 2;\n    var y12 = node1.y + node1.size[1] / 2;\n    var x21 = node2.x - node2.size[0] / 2;\n    var y21 = node2.y - node2.size[1] / 2;\n    var x22 = node2.x + node2.size[0] / 2;\n    var y22 = node2.y + node2.size[1] / 2;\n    var cx1 = node1.x;\n    var cy1 = node1.y;\n    var cx2 = node2.x;\n    var cy2 = node2.y;\n    var dcx = cx2 - cx1;\n    // 两个节点间的方位角  \n    var qr = Math.atan2(dcx, (cy2 - cy1));\n    var dx = 0;\n    var dy = 0;\n    var l1 = 0;\n    var l2 = 0;\n    if (qr > M_PI_2) {\n        dy = y11 - y22;\n        dx = x21 - x12;\n        l1 = parseFloat(dy ? (dy / Math.cos(qr)).toFixed(2) : (dx).toFixed(2));\n        l2 = parseFloat(dx ? (dx / Math.sin(qr)).toFixed(2) : (dy).toFixed(2));\n    }\n    else if (0.0 < qr && qr <= M_PI_2) {\n        dy = y21 - y12;\n        dx = x21 - x12;\n        if (dy > dx) {\n            l1 = l2 = parseFloat(dy ? (dy / Math.cos(qr)).toFixed(2) : (dx).toFixed(2));\n        }\n        else {\n            l1 = l2 = parseFloat(dx ? (dx / Math.sin(qr)).toFixed(2) : (dy).toFixed(2));\n        }\n    }\n    else if (qr < -M_PI_2) {\n        dy = y11 - y22;\n        dx = -(x22 - x11);\n        if (dy > dx) {\n            l1 = l2 = parseFloat(dy ? (dy / Math.cos(qr)).toFixed(2) : (dx).toFixed(2));\n        }\n        else {\n            l1 = l2 = parseFloat(dx ? (dx / Math.sin(qr)).toFixed(2) : (dy).toFixed(2));\n        }\n    }\n    else {\n        dy = y21 - y12;\n        if (Math.abs(dcx) > (x12 - x11) / 2) {\n            dx = x11 - x22;\n        }\n        else {\n            dx = dcx;\n        }\n        if (dy > dx) {\n            l1 = l2 = parseFloat(dy ? (dy / Math.cos(qr)).toFixed(2) : (dx).toFixed(2));\n        }\n        else {\n            l1 = l2 = parseFloat((dx && qr !== 0.0) ? (dx / Math.sin(qr)).toFixed(2) : (dy).toFixed(2));\n        }\n    }\n    var aqr = parseFloat(qr.toFixed(2));\n    // 判断是否水平，角度\n    var newHoriz = isHoriz;\n    if (isHoriz) {\n        newHoriz = PI_38 < aqr && aqr < PI_58;\n    }\n    return {\n        distance: Math.abs(l1 < l2 ? l1 : l2),\n        isHoriz: newHoriz,\n    };\n}\nfunction calcNodePair(nodeA, nodeB) {\n    // 确定两个节点间是否存在连线\n    var edges = nodeEdgeMap.get(nodeA.id) || [];\n    var isLinked = edges.find(function (edge) {\n        return edge.source === nodeB.id || edge.target === nodeB.id;\n    });\n    var areaA = nodeA.size[0] * nodeA.size[1];\n    var areaB = nodeB.size[0] * nodeB.size[1];\n    var node1 = areaA > areaB ? nodeB : nodeA;\n    var node2 = areaA > areaB ? nodeA : nodeB;\n    var x11 = node1.x - node1.size[0] / 2;\n    var y11 = node1.y - node1.size[1] / 2;\n    var x12 = node1.x + node1.size[0] / 2;\n    var y12 = node1.y + node1.size[1] / 2;\n    var x21 = node2.x - node2.size[0] / 2;\n    var y21 = node2.y - node2.size[1] / 2;\n    var x22 = node2.x + node2.size[0] / 2;\n    var y22 = node2.y + node2.size[1] / 2;\n    var cx1 = node1.x;\n    var cy1 = node1.y;\n    var cx2 = node2.x;\n    var cy2 = node2.y;\n    // Detect if nodes overlap  检查节点之间是否存在覆盖问题\n    var isoverlap = ((x12 >= x21) && (x22 >= x11) && (y12 >= y21) && (y22 >= y11));\n    var e = 0;\n    var distance = 0;\n    if (isoverlap) {\n        distance = Math.sqrt(Math.pow((cx2 - cx1), 2) + Math.pow((cy2 - cy1), 2));\n        // calc area of overlap 计算重复区域的坐标和面积\n        var sx1 = x11 > x21 ? x11 : x21;\n        var sy1 = y11 > y21 ? y11 : y21;\n        var sx2 = x12 < x22 ? x12 : x22;\n        var sy2 = y12 < y22 ? y12 : y22;\n        var dsx = sx2 - sx1;\n        var dsy = sy2 - sy1;\n        var sov = dsx * dsy;\n        if (distance === 0.0) {\n            distance = 0.0000001;\n        }\n        e = MIN_DIST * 1 / distance * 100 + sov;\n        e *= OVERLAP_QUOT;\n    }\n    else {\n        var isHoriz = false;\n        var res = distanceToNode(node1, node2, isHoriz);\n        distance = res.distance;\n        isHoriz = res.isHoriz;\n        if (distance <= MIN_DIST) {\n            if (distance !== 0) {\n                if (isLinked) {\n                    e += MIN_DIST + OVERLAP_QUOT * 1 / distance;\n                }\n                else {\n                    e += MIN_DIST + OVERLAP_QUOT * MIN_DIST / distance;\n                }\n            }\n            else {\n                e += OVERLAP_QUOT;\n            }\n        }\n        else {\n            e += distance;\n            if (isLinked) {\n                e += distance * distance;\n            }\n        }\n    }\n    return e;\n}\nfunction calcEnergy(nodes) {\n    var energy = 0;\n    for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n        if ((node.x < 0) || (node.y < 0) || (node.x > graphWidth) || (node.y > graphHeight)) {\n            energy += 1000000000000;\n        }\n        for (var j = i + 1; j < nodes.length; j++) {\n            energy += calcNodePair(node, nodes[j]);\n        }\n    }\n    return energy;\n}\nfunction isCorrectPosition(node, newPosition, nodes, edges) {\n    var nodeIdxMap = new Map();\n    nodes.forEach(function (o, i) {\n        nodeIdxMap.set(o.id, o);\n    });\n    var relateEdges = edges.filter(function (edge) { return edge.source === node.id || edge.target === node.id; }) || [];\n    var relateNodes = [];\n    relateEdges.forEach(function (edge) {\n        var otherNodeId = edge.source === node.id ? edge.target : edge.source;\n        var otherNode = nodeIdxMap.get(otherNodeId);\n        if (otherNode) {\n            relateNodes.push(otherNode);\n        }\n    });\n    var flag = true;\n    for (var i = 0; i < relateNodes.length; i++) {\n        var item = relateNodes[i];\n        // 判断条件调整，节点的坐标不需要完全一致。可以根据节点间的夹角来判断\n        var delta = Math.atan((node.y - item.y) / (item.x - node.y)) * 180;\n        var newDelta = Math.atan((newPosition.y - item.y) / (item.x - newPosition.y)) * 180;\n        var isHor = delta < 30 || delta > 150;\n        var newIsHor = newDelta < 30 || newDelta > 150;\n        var isVer = delta > 70 && delta < 110;\n        var newIsVer = newDelta > 70 && newDelta < 110;\n        // 定义四个相似角度区间，0-15度，75-90度，90到105度，165到180度。\n        if (isHor && !newIsHor || ((delta * newDelta) < 0)) {\n            flag = false;\n            break;\n        }\n        else if (isVer && !newIsVer || ((delta * newDelta) < 0)) {\n            flag = false;\n            break;\n        }\n        else if ((item.x - node.x) * (item.x - newPosition.x) < 0) {\n            flag = false;\n            break;\n        }\n        else if ((item.y - node.y) * (item.y - newPosition.y) < 0) {\n            flag = false;\n            break;\n        }\n    }\n    return flag;\n}\nfunction shuffle(nodes, edges) {\n    var foundSmallerEnergy = false;\n    // 多次测试发现step为1时的效果最佳。\n    var step = 1;\n    var wstep = CELL_W * step;\n    var hstep = CELL_H * step;\n    var wsteps = [wstep, -wstep, 0, 0,];\n    var hsteps = [0, 0, hstep, -hstep,];\n    for (var i = 0; i < nodes.length; ++i) {\n        var node = nodes[i];\n        var nodeEnergy = calcNodeEnergy(node, nodes);\n        for (var ns = 0; ns < wsteps.length; ns++) {\n            // 判断新位置与其他连线节点的位置关系是否违规\n            var flag = isCorrectPosition(node, { x: node.x + wsteps[ns], y: node.y + hsteps[ns] }, nodes, edges);\n            if (flag) {\n                // 节点朝上下左右四个方向移动，找到能量最小的那个位置\n                node.x += wsteps[ns];\n                node.y += hsteps[ns];\n                // 计算移动后节点的能量\n                var energy = calcNodeEnergy(node, nodes);\n                var rdm = Math.random();\n                if (energy < nodeEnergy) {\n                    nodeEnergy = energy;\n                    foundSmallerEnergy = true;\n                }\n                else if (rdm < T && rdm > T_MIN) {\n                    nodeEnergy = energy;\n                    foundSmallerEnergy = true;\n                }\n                else {\n                    // 回归原位\n                    node.x -= wsteps[ns];\n                    node.y -= hsteps[ns];\n                }\n            }\n        }\n    }\n    if (T > T_MIN) {\n        T *= R;\n    }\n    // 重新计算图整体的能量\n    if (foundSmallerEnergy) {\n        return calcEnergy(nodes);\n    }\n    return 0;\n}\n// 计算节点的能量，\nfunction calcNodeEnergy(node, nodes) {\n    var e = 0.0;\n    if ((node.x < 0) || (node.y < 0) ||\n        (node.x + node.size[0] + 20 > graphWidth) ||\n        (node.y + node.size[1] + 20 > graphHeight)) {\n        e += 1000000000000.0;\n    }\n    for (var i = 0; i < nodes.length; ++i) {\n        if (node.id !== nodes[i].id) {\n            e += calcNodePair(node, nodes[i]);\n        }\n    }\n    return e;\n}\nfunction layout(nodes, edges) {\n    if (nodes.length === 0) {\n        return { nodes: nodes, edges: edges };\n    }\n    nodes.forEach(function (node) {\n        var relateEdge = edges.filter(function (edge) { return edge.source === node.id || edge.target === node.id; });\n        nodeEdgeMap.set(node, relateEdge);\n    });\n    // 1. 初始化\n    // 将node按照连接数进行排序\n    nodes.sort(function (node1, node2) {\n        var _a, _b;\n        return ((_a = nodeEdgeMap.get(node1.id)) === null || _a === void 0 ? void 0 : _a.length) - ((_b = nodeEdgeMap.get(node2.id)) === null || _b === void 0 ? void 0 : _b.length);\n    });\n    // 2. 计算图能量\n    var minEnergy = calcEnergy(nodes);\n    var deSameCount = 20; // de=0 count\n    var de = 1; // energy delta\n    var prevEnergy = 0;\n    // 定义总的迭代次数。超过就停掉，防止死循环\n    var MAX_COUNT = 50;\n    var count = 0;\n    while (deSameCount > 0) {\n        count++;\n        if (count >= MAX_COUNT) {\n            break;\n        }\n        var ea = shuffle(nodes, edges);\n        if (ea !== 0) {\n            prevEnergy = ea;\n        }\n        de = prevEnergy - minEnergy;\n        minEnergy = prevEnergy;\n        if (de === 0) {\n            --deSameCount;\n        }\n        else {\n            deSameCount = 20;\n        }\n    }\n    nodes.forEach(function (node) {\n        node.x = node.x - node.size[0] / 2;\n        node.y = node.y - node.size[1] / 2;\n    });\n    return {\n        nodes: nodes,\n        edges: edges,\n    };\n}\nexports.default = layout;\n"},"sourceMaps":{"js":{"version":3,"file":"mysqlWorkbench.js","sourceRoot":"","sources":["../../../src/layout/er/mysqlWorkbench.ts"],"names":[],"mappings":"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","sourcesContent":["import { IEdge, IMysqlNode } from './type';\n\nconst graphWidth = 1200;\nconst graphHeight = 800;\nconst OVERLAP_QUOT = 10000000;\nconst MIN_DIST = 10;\nconst M_PI = 3.14159265358979323846;\nconst M_PI_2 = 1.57079632679489661923;\nconst PI_38 = M_PI * 0.375;\nconst PI_58 = M_PI * 0.625;\nconst nodeEdgeMap = new Map();\nconst CELL_W = 10;\nconst CELL_H = 10;\nlet T = 0.8;\nconst T_MIN = 0.1;\nconst R = 0.5;\n\nfunction distanceToNode(node1: IMysqlNode, node2: IMysqlNode, isHoriz: boolean) {\n  const x11 = node1.x - node1.size[0] / 2;\n  const y11 = node1.y - node1.size[1] / 2;\n  const x12 = node1.x + node1.size[0] / 2;\n  const y12 = node1.y + node1.size[1] / 2;\n  const x21 = node2.x - node2.size[0] / 2;\n  const y21 = node2.y - node2.size[1] / 2;\n  const x22 = node2.x + node2.size[0] / 2;\n  const y22 = node2.y + node2.size[1] / 2;\n\n  const cx1 = node1.x;\n  const cy1 = node1.y;\n  const cx2 = node2.x;\n  const cy2 = node2.y;\n  const dcx = cx2 - cx1;\n  // 两个节点间的方位角  \n  const qr = Math.atan2(dcx, (cy2 - cy1));\n  let dx = 0;\n  let dy = 0;\n  let l1 = 0;\n  let l2 = 0;\n  if (qr > M_PI_2) {\n    dy = y11 - y22;\n    dx = x21 - x12;\n    l1 = parseFloat(dy ? (dy / Math.cos(qr)).toFixed(2) : (dx).toFixed(2)); \n    l2 = parseFloat(dx ? (dx / Math.sin(qr)).toFixed(2) : (dy).toFixed(2)); \n  } else if (0.0 < qr && qr <= M_PI_2) {\n    dy = y21 - y12;\n    dx = x21 - x12;\n    if (dy > dx) {\n      l1 = l2 = parseFloat(dy ? (dy / Math.cos(qr)).toFixed(2) : (dx).toFixed(2));\n    } else {\n      l1 = l2 = parseFloat(dx ? (dx / Math.sin(qr)).toFixed(2) : (dy).toFixed(2));\n    }\n      \n  } else if (qr < -M_PI_2) {\n    dy = y11 - y22;\n    dx = -(x22 - x11);\n    if (dy > dx) {\n      l1 = l2 = parseFloat(dy ? (dy / Math.cos(qr)).toFixed(2) : (dx).toFixed(2));\n    } else {\n      l1 = l2 = parseFloat(dx ? (dx / Math.sin(qr)).toFixed(2) : (dy).toFixed(2));\n    }\n  }else {\n    dy = y21 - y12;\n    if (Math.abs(dcx) > (x12 - x11) / 2) {\n      dx = x11 - x22;\n    } else {\n      dx = dcx;\n    }\n      \n    if (dy > dx) {\n      l1 = l2 = parseFloat(dy ? (dy / Math.cos(qr)).toFixed(2) : (dx).toFixed(2));\n    } else {\n      l1 = l2 = parseFloat((dx && qr !== 0.0) ? (dx / Math.sin(qr)).toFixed(2) : (dy).toFixed(2));\n    }\n      \n  }\n  const aqr = parseFloat(qr.toFixed(2));\n  // 判断是否水平，角度\n  let newHoriz = isHoriz;\n  if (isHoriz) {\n    newHoriz = PI_38 < aqr && aqr < PI_58;\n  }\n  return {\n    distance: Math.abs(l1 < l2 ? l1 : l2),\n    isHoriz: newHoriz,\n  };\n}\n\nfunction calcNodePair(nodeA: IMysqlNode, nodeB: IMysqlNode) {\n  // 确定两个节点间是否存在连线\n  const edges = nodeEdgeMap.get(nodeA.id) || [];\n  const isLinked = edges.find((edge: IEdge) => {\n    return edge.source === nodeB.id || edge.target === nodeB.id;\n  });\n\n  const areaA = nodeA.size[0] * nodeA.size[1];\n  const areaB = nodeB.size[0] * nodeB.size[1];\n  const node1 = areaA > areaB ? nodeB : nodeA;\n  const node2 = areaA > areaB ? nodeA : nodeB;\n\n  const x11 = node1.x - node1.size[0] / 2;\n  const y11 = node1.y - node1.size[1] / 2;\n  const x12 = node1.x + node1.size[0] / 2;\n  const y12 = node1.y + node1.size[1] / 2;\n  const x21 = node2.x - node2.size[0] / 2;\n  const y21 = node2.y - node2.size[1] / 2;\n  const x22 = node2.x + node2.size[0] / 2;\n  const y22 = node2.y + node2.size[1] / 2;\n\n  const cx1 = node1.x;\n  const cy1 = node1.y;\n  const cx2 = node2.x;\n  const cy2 = node2.y;\n\n  // Detect if nodes overlap  检查节点之间是否存在覆盖问题\n  const isoverlap = ((x12 >= x21) && (x22 >= x11) && (y12 >= y21) && (y22 >= y11));\n  let e = 0;\n  let distance = 0;\n  \n  if (isoverlap) {\n    \n    distance = Math.sqrt(Math.pow((cx2 - cx1), 2) + Math.pow((cy2 - cy1), 2));\n\n    // calc area of overlap 计算重复区域的坐标和面积\n    const sx1 = x11 > x21 ? x11 : x21;\n    const sy1 = y11 > y21 ? y11 : y21;\n    const sx2 = x12 < x22 ? x12 : x22;\n    const sy2 = y12 < y22 ? y12 : y22;\n    const dsx = sx2 - sx1;\n    const dsy = sy2 - sy1;\n\n    const sov = dsx * dsy;\n\n    if (distance === 0.0) {\n      distance = 0.0000001;\n    }\n\n    e = MIN_DIST * 1 / distance * 100 + sov;\n    e *= OVERLAP_QUOT;\n  } else {\n    let isHoriz = false;\n    const res = distanceToNode(node1, node2, isHoriz);\n    distance = res.distance;\n    isHoriz = res.isHoriz;\n\n    if (distance <= MIN_DIST) {\n      if (distance !== 0) {\n        if (isLinked) {\n          e += MIN_DIST + OVERLAP_QUOT * 1 / distance;\n        }\n        else {\n          e += MIN_DIST + OVERLAP_QUOT * MIN_DIST / distance;\n        }  \n      } else {\n        e += OVERLAP_QUOT;\n      }\n    } else {\n      e += distance;\n      if (isLinked) {\n        e += distance * distance;\n      } \n    }\n  }\n\n  return e;\n}\nfunction calcEnergy(nodes: any) {\n  let energy = 0;\n  for(let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if ((node.x < 0) || (node.y < 0) || (node.x > graphWidth) || (node.y > graphHeight)) {\n      energy += 1000000000000;\n    }\n    for (let j = i + 1; j < nodes.length; j++) {\n      energy += calcNodePair(node, nodes[j]);\n    }\n  }\n\n  return energy;\n}\n\nfunction isCorrectPosition(node: IMysqlNode, newPosition: {\n  x: number, y: number\n}, nodes: IMysqlNode[], edges: IEdge[]) {\n  const nodeIdxMap = new Map<string, IMysqlNode>();\n  nodes.forEach((o, i) => {\n    nodeIdxMap.set(o.id, o);\n  });\n  const relateEdges = edges.filter((edge) => edge.source === node.id || edge.target === node.id) || [];\n  const relateNodes: IMysqlNode[] = [];\n  relateEdges.forEach((edge) => {\n    const otherNodeId = edge.source === node.id ? edge.target : edge.source;\n    const otherNode = nodeIdxMap.get(otherNodeId);\n    if (otherNode) {\n      relateNodes.push(otherNode);\n    }\n  });\n\n  let flag = true;\n  for(let i = 0; i < relateNodes.length; i++) {\n    const item = relateNodes[i];\n    // 判断条件调整，节点的坐标不需要完全一致。可以根据节点间的夹角来判断\n    const delta = Math.atan((node.y - item.y) / (item.x - node.y)) * 180;\n    const newDelta = Math.atan((newPosition.y - item.y) / (item.x - newPosition.y)) * 180;\n    const isHor = delta < 30 || delta > 150;\n    const newIsHor = newDelta < 30 || newDelta > 150;\n    const isVer = delta > 70 && delta < 110;\n    const newIsVer = newDelta > 70 && newDelta < 110;\n    // 定义四个相似角度区间，0-15度，75-90度，90到105度，165到180度。\n    if (isHor && !newIsHor || ((delta * newDelta) < 0)) {\n      flag = false;\n      break;\n    } else if (isVer && !newIsVer || ((delta * newDelta) < 0)) {\n      flag = false;\n      break;\n    } else if ((item.x - node.x) * (item.x - newPosition.x) < 0) {\n      flag = false;\n      break;\n    }else if ((item.y - node.y) * (item.y - newPosition.y) < 0) {\n      flag = false;\n      break;\n    }\n  }\n  return flag;\n}\n\nfunction shuffle(nodes: IMysqlNode[], edges: IEdge[]) {\n  let foundSmallerEnergy = false;\n  // 多次测试发现step为1时的效果最佳。\n  const step = 1; \n  const wstep = CELL_W * step;\n  const hstep = CELL_H * step;\n  const wsteps = [ wstep, -wstep, 0, 0, ];\n  const hsteps = [ 0, 0, hstep, -hstep, ];\n  for (let i = 0; i < nodes.length; ++i) {\n    const node = nodes[i];\n    let nodeEnergy = calcNodeEnergy(node, nodes);\n    for (let ns = 0; ns < wsteps.length ; ns++) {\n      // 判断新位置与其他连线节点的位置关系是否违规\n      const flag = isCorrectPosition(node, { x: node.x + wsteps[ns], y: node.y + hsteps[ns] }, nodes, edges);\n      if (flag) {\n        // 节点朝上下左右四个方向移动，找到能量最小的那个位置\n        node.x += wsteps[ns];\n        node.y += hsteps[ns];\n        \n        // 计算移动后节点的能量\n        const energy = calcNodeEnergy(node, nodes);\n        const rdm = Math.random();\n        \n        if (energy < nodeEnergy) {\n          nodeEnergy = energy;\n          foundSmallerEnergy = true;\n         \n        } else if (rdm < T && rdm > T_MIN) {\n          nodeEnergy = energy;\n          foundSmallerEnergy = true;\n         \n        } else {\n          // 回归原位\n          node.x -= wsteps[ns];\n          node.y -= hsteps[ns];\n        }\n      }   \n    }\n\n  }\n  if (T > T_MIN) {\n    T *= R;\n  }\n   // 重新计算图整体的能量\n  if (foundSmallerEnergy) {\n    return calcEnergy(nodes);\n  }\n  return 0;\n}\n\n// 计算节点的能量，\nfunction calcNodeEnergy(node: IMysqlNode, nodes: IMysqlNode[]) {\n  let e = 0.0;\n  if ((node.x < 0) || (node.y < 0) || \n    (node.x + node.size[0] + 20 > graphWidth) ||\n    (node.y + node.size[1] + 20 > graphHeight)\n  ) {\n    e += 1000000000000.0;\n  }\n\n  for (let i = 0; i < nodes.length; ++i) {\n    if (node.id !== nodes[i].id) {\n      e += calcNodePair(node, nodes[i]);\n    }\n  }\n  return e;\n}\n\nfunction layout(nodes: IMysqlNode[], edges: IEdge[]) {\n  if (nodes.length === 0) {\n    return { nodes, edges };\n  }\n  nodes.forEach((node: any) => {\n    const relateEdge = edges.filter((edge) => edge.source === node.id || edge.target === node.id);\n    nodeEdgeMap.set(node, relateEdge);\n  });\n\n  // 1. 初始化\n  // 将node按照连接数进行排序\n  nodes.sort((node1: IMysqlNode, node2: IMysqlNode) => {\n    return nodeEdgeMap.get(node1.id)?.length - nodeEdgeMap.get(node2.id)?.length;\n  });\n\n  // 2. 计算图能量\n  let minEnergy = calcEnergy(nodes);\n  let deSameCount = 20; // de=0 count\n  let de = 1;      // energy delta\n  let prevEnergy = 0;\n  // 定义总的迭代次数。超过就停掉，防止死循环\n  const MAX_COUNT = 50;\n  let count = 0;\n  while (deSameCount > 0) {\n    count ++;\n    if (count >= MAX_COUNT) {\n      break;\n    }\n    const ea = shuffle(nodes, edges);\n    if (ea !== 0) {\n      prevEnergy = ea;\n    } \n    de = prevEnergy - minEnergy;\n    minEnergy = prevEnergy;\n    if (de === 0) {\n      --deSameCount;\n    } else {\n      deSameCount = 20;\n    }\n  }\n  nodes.forEach((node: IMysqlNode) => {\n    node.x = node.x - node.size[0] / 2;\n    node.y = node.y - node.size[1] / 2;\n  });\n \n  return {\n    nodes,\n    edges,\n  };\n}\n\nexport default layout;"]}},"error":null,"hash":"7872309039e93750e26c714a39d9fc3b","cacheData":{"env":{}}}