{"id":"node_modules/@antv/layout/lib/layout/dagre.js","dependencies":[{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\dagre.js.map","includedInParent":true,"mtime":1676178923596},{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\src\\layout\\dagre.ts","includedInParent":true,"mtime":1676178923850},{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\package.json","includedInParent":true,"mtime":1676178924413},{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\package.json","includedInParent":true,"mtime":1676178923486},{"name":"./dagre/index","loc":{"line":26,"column":38,"index":1117},"parent":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\dagre.js","resolved":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\index.js"},{"name":"../util","loc":{"line":27,"column":21,"index":1157},"parent":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\dagre.js","resolved":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\util\\index.js"},{"name":"./base","loc":{"line":28,"column":21,"index":1190},"parent":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\dagre.js","resolved":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\base.js"},{"name":"./dagre/graph","loc":{"line":29,"column":22,"index":1223},"parent":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\dagre.js","resolved":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\graph.js"}],"generated":{"js":"\"use strict\";\n/**\n * @fileOverview dagre layout\n * @author shiwu.wyy@antfin.com\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DagreLayout = void 0;\nvar index_1 = __importDefault(require(\"./dagre/index\"));\nvar util_1 = require(\"../util\");\nvar base_1 = require(\"./base\");\nvar graph_1 = require(\"./dagre/graph\");\n/**\n * 层次布局\n */\nvar DagreLayout = /** @class */ (function (_super) {\n    __extends(DagreLayout, _super);\n    function DagreLayout(options) {\n        var _this = _super.call(this) || this;\n        /** layout 方向, 可选 TB, BT, LR, RL */\n        _this.rankdir = \"TB\";\n        /** 节点水平间距(px) */\n        _this.nodesep = 50;\n        /** 每一层节点之间间距 */\n        _this.ranksep = 50;\n        /** 是否保留布局连线的控制点 */\n        _this.controlPoints = false;\n        /** 每层节点是否根据节点数据中的 comboId 进行排序，以防止同层 combo 重叠 */\n        _this.sortByCombo = false;\n        /** 是否保留每条边上的dummy node */\n        _this.edgeLabelSpace = true;\n        /** 是否基于 dagre 进行辐射布局，若是，第一层节点将被放置在最内环上，其余层依次向外辐射 */\n        _this.radial = false;\n        _this.nodes = [];\n        _this.edges = [];\n        /** 迭代结束的回调函数 */\n        _this.onLayoutEnd = function () { };\n        _this.layoutNode = function (nodeId) {\n            var self = _this;\n            var nodes = self.nodes;\n            var node = nodes.find(function (node) { return node.id === nodeId; });\n            if (node) {\n                var layout = node.layout !== false;\n                return layout;\n            }\n            return true;\n        };\n        _this.updateCfg(options);\n        return _this;\n    }\n    DagreLayout.prototype.getDefaultCfg = function () {\n        return {\n            rankdir: \"TB\",\n            align: undefined,\n            nodeSize: undefined,\n            nodesepFunc: undefined,\n            ranksepFunc: undefined,\n            nodesep: 50,\n            ranksep: 50,\n            controlPoints: false,\n            radial: false,\n            focusNode: null, // radial 为 true 时生效，关注的节点\n        };\n    };\n    /**\n     * 执行布局\n     */\n    DagreLayout.prototype.execute = function () {\n        var _this = this;\n        var _a, _b, _c;\n        var self = this;\n        var nodes = self.nodes, nodeSize = self.nodeSize, rankdir = self.rankdir, combos = self.combos, begin = self.begin, radial = self.radial, _d = self.comboEdges, comboEdges = _d === void 0 ? [] : _d, _e = self.vedges, vedges = _e === void 0 ? [] : _e;\n        if (!nodes)\n            return;\n        var edges = self.edges || [];\n        var g = new graph_1.Graph({\n            multigraph: true,\n            compound: true,\n        });\n        // collect the nodes in their combo, to create virtual edges for comboEdges\n        self.nodeMap = {};\n        var nodeComboMap = {};\n        nodes.forEach(function (node) {\n            self.nodeMap[node.id] = node;\n            if (!node.comboId)\n                return;\n            nodeComboMap[node.comboId] = nodeComboMap[node.comboId] || [];\n            nodeComboMap[node.comboId].push(node.id);\n        });\n        var nodeSizeFunc;\n        if (!nodeSize) {\n            nodeSizeFunc = function (d) {\n                if (d.size) {\n                    if ((0, util_1.isArray)(d.size)) {\n                        return d.size;\n                    }\n                    if ((0, util_1.isObject)(d.size)) {\n                        return [d.size.width || 40, d.size.height || 40];\n                    }\n                    return [d.size, d.size];\n                }\n                return [40, 40];\n            };\n        }\n        else if ((0, util_1.isArray)(nodeSize)) {\n            nodeSizeFunc = function () { return nodeSize; };\n        }\n        else {\n            nodeSizeFunc = function () { return [nodeSize, nodeSize]; };\n        }\n        var ranksepfunc = (0, util_1.getFunc)(self.ranksep, 50, self.ranksepFunc);\n        var nodesepfunc = (0, util_1.getFunc)(self.nodesep, 50, self.nodesepFunc);\n        var horisep = nodesepfunc;\n        var vertisep = ranksepfunc;\n        if (rankdir === \"LR\" || rankdir === \"RL\") {\n            horisep = ranksepfunc;\n            vertisep = nodesepfunc;\n        }\n        g.setDefaultEdgeLabel(function () { return ({}); });\n        g.setGraph(self);\n        var comboMap = {};\n        if (this.sortByCombo && combos) {\n            combos.forEach(function (combo) {\n                comboMap[combo.id] = combo;\n                // regard the collapsed combo as a node\n                if (combo.collapsed) {\n                    var size = nodeSizeFunc(combo);\n                    var verti = vertisep(combo);\n                    var hori = horisep(combo);\n                    var width = size[0] + 2 * hori;\n                    var height = size[1] + 2 * verti;\n                    g.setNode(combo.id, { width: width, height: height });\n                }\n                if (!combo.parentId)\n                    return;\n                if (!comboMap[combo.parentId]) {\n                    g.setNode(combo.parentId, {});\n                }\n                g.setParent(combo.id, combo.parentId);\n            });\n        }\n        nodes.filter(function (node) { return node.layout !== false; }).forEach(function (node) {\n            var size = nodeSizeFunc(node);\n            var verti = vertisep(node);\n            var hori = horisep(node);\n            var width = size[0] + 2 * hori;\n            var height = size[1] + 2 * verti;\n            var layer = node.layer;\n            if ((0, util_1.isNumber)(layer)) {\n                // 如果有layer属性，加入到node的label中\n                g.setNode(node.id, { width: width, height: height, layer: layer });\n            }\n            else {\n                g.setNode(node.id, { width: width, height: height });\n            }\n            if (_this.sortByCombo && node.comboId) {\n                if (!comboMap[node.comboId]) {\n                    comboMap[node.comboId] = { id: node.comboId };\n                    g.setNode(node.comboId, {});\n                }\n                g.setParent(node.id, node.comboId);\n            }\n        });\n        edges.forEach(function (edge) {\n            // dagrejs Wiki https://github.com/dagrejs/dagre/wiki#configuring-the-layout\n            var source = (0, util_1.getEdgeTerminal)(edge, 'source');\n            var target = (0, util_1.getEdgeTerminal)(edge, 'target');\n            if (_this.layoutNode(source) && _this.layoutNode(target)) {\n                g.setEdge(source, target, {\n                    weight: edge.weight || 1,\n                });\n            }\n        });\n        // create virtual edges from node to node for comboEdges\n        (_a = (comboEdges === null || comboEdges === void 0 ? void 0 : comboEdges.concat(vedges || []))) === null || _a === void 0 ? void 0 : _a.forEach(function (comboEdge) {\n            var _a, _b;\n            var source = comboEdge.source, target = comboEdge.target;\n            var sources = ((_a = comboMap[source]) === null || _a === void 0 ? void 0 : _a.collapsed) ? [source] : nodeComboMap[source] || [source];\n            var targets = ((_b = comboMap[target]) === null || _b === void 0 ? void 0 : _b.collapsed) ? [target] : nodeComboMap[target] || [target];\n            sources.forEach(function (s) {\n                targets.forEach(function (t) {\n                    g.setEdge(s, t, {\n                        weight: comboEdge.weight || 1,\n                    });\n                });\n            });\n        });\n        // 考虑增量图中的原始图\n        var prevGraph = undefined;\n        if ((_b = self.preset) === null || _b === void 0 ? void 0 : _b.nodes) {\n            prevGraph = new graph_1.Graph({\n                multigraph: true,\n                compound: true,\n            });\n            self.preset.nodes.forEach(function (node) {\n                prevGraph === null || prevGraph === void 0 ? void 0 : prevGraph.setNode(node.id, node);\n            });\n        }\n        index_1.default.layout(g, {\n            prevGraph: prevGraph,\n            edgeLabelSpace: self.edgeLabelSpace,\n            keepNodeOrder: Boolean(!!self.nodeOrder),\n            nodeOrder: self.nodeOrder,\n        });\n        var dBegin = [0, 0];\n        if (begin) {\n            var minX_1 = Infinity;\n            var minY_1 = Infinity;\n            g.nodes().forEach(function (node) {\n                var coord = g.node(node);\n                if (minX_1 > coord.x)\n                    minX_1 = coord.x;\n                if (minY_1 > coord.y)\n                    minY_1 = coord.y;\n            });\n            g.edges().forEach(function (edge) {\n                var _a;\n                var coord = g.edge(edge);\n                (_a = coord.points) === null || _a === void 0 ? void 0 : _a.forEach(function (point) {\n                    if (minX_1 > point.x)\n                        minX_1 = point.x;\n                    if (minY_1 > point.y)\n                        minY_1 = point.y;\n                });\n            });\n            dBegin[0] = begin[0] - minX_1;\n            dBegin[1] = begin[1] - minY_1;\n        }\n        // 变形为辐射\n        if (radial) {\n            var _f = this, focusNode = _f.focusNode, ranksep = _f.ranksep, getRadialPos_1 = _f.getRadialPos;\n            var focusId = (0, util_1.isString)(focusNode) ? focusNode : focusNode === null || focusNode === void 0 ? void 0 : focusNode.id;\n            var focusLayer_1 = focusId ? (_c = g.node(focusId)) === null || _c === void 0 ? void 0 : _c._rank : 0;\n            var layers_1 = [];\n            var isHorizontal = rankdir === 'LR' || rankdir === 'RL';\n            var dim_1 = isHorizontal ? 'y' : 'x';\n            var sizeDim_1 = isHorizontal ? 'height' : 'width';\n            // 找到整个图作为环的坐标维度（dim）的最大、最小值，考虑节点宽度\n            var min_1 = Infinity;\n            var max_1 = -Infinity;\n            g.nodes().forEach(function (node) {\n                var coord = g.node(node);\n                var i = nodes.findIndex(function (it) { return it.id === node; });\n                if (!nodes[i])\n                    return;\n                var currentNodesep = nodesepfunc(nodes[i]);\n                if (focusLayer_1 === 0) {\n                    if (!layers_1[coord._rank])\n                        layers_1[coord._rank] = { nodes: [], totalWidth: 0, maxSize: -Infinity };\n                    layers_1[coord._rank].nodes.push(node);\n                    layers_1[coord._rank].totalWidth += currentNodesep * 2 + coord[sizeDim_1];\n                    if (layers_1[coord._rank].maxSize < Math.max(coord.width, coord.height))\n                        layers_1[coord._rank].maxSize = Math.max(coord.width, coord.height);\n                }\n                else {\n                    var diffLayer = coord._rank - focusLayer_1;\n                    if (diffLayer === 0) {\n                        if (!layers_1[diffLayer])\n                            layers_1[diffLayer] = { nodes: [], totalWidth: 0, maxSize: -Infinity };\n                        layers_1[diffLayer].nodes.push(node);\n                        layers_1[diffLayer].totalWidth += currentNodesep * 2 + coord[sizeDim_1];\n                        if (layers_1[diffLayer].maxSize < Math.max(coord.width, coord.height))\n                            layers_1[diffLayer].maxSize = Math.max(coord.width, coord.height);\n                    }\n                    else {\n                        var diffLayerAbs = Math.abs(diffLayer);\n                        if (!layers_1[diffLayerAbs])\n                            layers_1[diffLayerAbs] = { left: [], right: [], totalWidth: 0, maxSize: -Infinity };\n                        layers_1[diffLayerAbs].totalWidth += currentNodesep * 2 + coord[sizeDim_1];\n                        if (layers_1[diffLayerAbs].maxSize < Math.max(coord.width, coord.height))\n                            layers_1[diffLayerAbs].maxSize = Math.max(coord.width, coord.height);\n                        if (diffLayer < 0) {\n                            layers_1[diffLayerAbs].left.push(node);\n                        }\n                        else {\n                            layers_1[diffLayerAbs].right.push(node);\n                        }\n                    }\n                }\n                var leftPos = coord[dim_1] - coord[sizeDim_1] / 2 - currentNodesep;\n                var rightPos = coord[dim_1] + coord[sizeDim_1] / 2 + currentNodesep;\n                if (leftPos < min_1)\n                    min_1 = leftPos;\n                if (rightPos > max_1)\n                    max_1 = rightPos;\n            });\n            // const padding = (max - min) * 0.1; // TODO\n            // \b初始化为第一圈的半径，后面根据每层 ranksep 叠加\n            var radius_1 = ranksep || 50; // TODO;\n            var radiusMap_1 = {};\n            // 扩大最大最小值范围，以便为环上留出接缝处的空隙\n            var rangeLength_1 = (max_1 - min_1) / 0.9;\n            var range_1 = [(min_1 + max_1 - rangeLength_1) * 0.5, (min_1 + max_1 + rangeLength_1) * 0.5];\n            // 根据半径、分布比例，计算节点在环上的位置，并返回该组节点中最大的 ranksep 值\n            var processNodes_1 = function (layerNodes, radius, propsMaxRanksep, arcRange) {\n                if (propsMaxRanksep === void 0) { propsMaxRanksep = -Infinity; }\n                if (arcRange === void 0) { arcRange = [0, 1]; }\n                var maxRanksep = propsMaxRanksep;\n                layerNodes.forEach(function (node) {\n                    var coord = g.node(node);\n                    radiusMap_1[node] = radius;\n                    // 获取变形为 radial 后的直角坐标系坐标\n                    var _a = getRadialPos_1(coord[dim_1], range_1, rangeLength_1, radius, arcRange), newX = _a.x, newY = _a.y;\n                    // 将新坐标写入源数据\n                    var i = nodes.findIndex(function (it) { return it.id === node; });\n                    if (!nodes[i])\n                        return;\n                    nodes[i].x = newX + dBegin[0];\n                    nodes[i].y = newY + dBegin[1];\n                    // @ts-ignore: pass layer order to data for increment layout use\n                    nodes[i]._order = coord._order;\n                    // 找到本层最大的一个 ranksep，作为下一层与本层的间隙，叠加到下一层的半径上\n                    var currentNodeRanksep = ranksepfunc(nodes[i]);\n                    if (maxRanksep < currentNodeRanksep)\n                        maxRanksep = currentNodeRanksep;\n                });\n                return maxRanksep;\n            };\n            var isFirstLevel_1 = true;\n            var lastLayerMaxNodeSize_1 = 0;\n            layers_1.forEach(function (layerNodes) {\n                var _a, _b, _c, _d, _e, _f, _g;\n                if (!((_a = layerNodes === null || layerNodes === void 0 ? void 0 : layerNodes.nodes) === null || _a === void 0 ? void 0 : _a.length) && !((_b = layerNodes === null || layerNodes === void 0 ? void 0 : layerNodes.left) === null || _b === void 0 ? void 0 : _b.length) && !((_c = layerNodes === null || layerNodes === void 0 ? void 0 : layerNodes.right) === null || _c === void 0 ? void 0 : _c.length))\n                    return;\n                // 第一层只有一个节点，直接放在圆心，初始半径设定为 0\n                if (isFirstLevel_1 && layerNodes.nodes.length === 1) {\n                    // 将新坐标写入源数据\n                    var i = nodes.findIndex(function (it) { return it.id === layerNodes.nodes[0]; });\n                    if (i <= -1)\n                        return;\n                    nodes[i].x = dBegin[0];\n                    nodes[i].y = dBegin[1];\n                    radiusMap_1[layerNodes.nodes[0]] = 0;\n                    radius_1 = ranksepfunc(nodes[i]);\n                    isFirstLevel_1 = false;\n                    return;\n                }\n                // 为接缝留出空隙，半径也需要扩大\n                radius_1 = Math.max(radius_1, layerNodes.totalWidth / (2 * Math.PI)); // / 0.9;\n                var maxRanksep = -Infinity;\n                if (focusLayer_1 === 0 || ((_d = layerNodes.nodes) === null || _d === void 0 ? void 0 : _d.length)) {\n                    maxRanksep = processNodes_1(layerNodes.nodes, radius_1, maxRanksep, [0, 1]); // 0.8\n                }\n                else {\n                    var leftRatio = ((_e = layerNodes.left) === null || _e === void 0 ? void 0 : _e.length) / (((_f = layerNodes.left) === null || _f === void 0 ? void 0 : _f.length) + ((_g = layerNodes.right) === null || _g === void 0 ? void 0 : _g.length));\n                    maxRanksep = processNodes_1(layerNodes.left, radius_1, maxRanksep, [0, leftRatio]); // 接缝留出 0.05 的缝隙\n                    maxRanksep = processNodes_1(layerNodes.right, radius_1, maxRanksep, [leftRatio + 0.05, 1]); // 接缝留出 0.05 的缝隙\n                }\n                radius_1 += maxRanksep;\n                isFirstLevel_1 = false;\n                lastLayerMaxNodeSize_1 - layerNodes.maxSize;\n            });\n            g.edges().forEach(function (edge) {\n                var _a, _b, _c;\n                var coord = g.edge(edge);\n                var i = edges.findIndex(function (it) {\n                    var source = (0, util_1.getEdgeTerminal)(it, 'source');\n                    var target = (0, util_1.getEdgeTerminal)(it, 'target');\n                    return source === edge.v && target === edge.w;\n                });\n                if (i <= -1)\n                    return;\n                if ((self.edgeLabelSpace) && self.controlPoints && edges[i].type !== \"loop\") {\n                    var otherDim_1 = dim_1 === 'x' ? 'y' : 'x';\n                    var controlPoints = (_a = coord === null || coord === void 0 ? void 0 : coord.points) === null || _a === void 0 ? void 0 : _a.slice(1, coord.points.length - 1);\n                    var newControlPoints_1 = [];\n                    var sourceOtherDimValue_1 = (_b = g.node(edge.v)) === null || _b === void 0 ? void 0 : _b[otherDim_1];\n                    var otherDimDist_1 = sourceOtherDimValue_1 - ((_c = g.node(edge.w)) === null || _c === void 0 ? void 0 : _c[otherDim_1]);\n                    var sourceRadius_1 = radiusMap_1[edge.v];\n                    var radiusDist_1 = sourceRadius_1 - radiusMap_1[edge.w];\n                    controlPoints === null || controlPoints === void 0 ? void 0 : controlPoints.forEach(function (point) {\n                        // 根据该边的起点、终点半径，及起点、终点、控制点位置关系，确定该控制点的半径\n                        var cRadius = (point[otherDim_1] - sourceOtherDimValue_1) / otherDimDist_1 * radiusDist_1 + sourceRadius_1;\n                        // 获取变形为 radial 后的直角坐标系坐标\n                        var newPos = getRadialPos_1(point[dim_1], range_1, rangeLength_1, cRadius);\n                        newControlPoints_1.push({\n                            x: newPos.x + dBegin[0],\n                            y: newPos.y + dBegin[1]\n                        });\n                    });\n                    edges[i].controlPoints = newControlPoints_1;\n                }\n            });\n        }\n        else {\n            g.nodes().forEach(function (node) {\n                var coord = g.node(node);\n                if (!coord)\n                    return;\n                var ndata = _this.nodeMap[node];\n                if (!ndata) {\n                    ndata = combos === null || combos === void 0 ? void 0 : combos.find(function (it) { return it.id === node; });\n                }\n                if (!ndata)\n                    return;\n                ndata.x = coord.x + dBegin[0];\n                ndata.y = coord.y + dBegin[1];\n                // @ts-ignore: pass layer order to data for increment layout use\n                ndata._order = coord._order;\n            });\n            g.edges().forEach(function (edge) {\n                var _a;\n                var coord = g.edge(edge);\n                var i = edges.findIndex(function (it) {\n                    var source = (0, util_1.getEdgeTerminal)(it, 'source');\n                    var target = (0, util_1.getEdgeTerminal)(it, 'target');\n                    return source === edge.v && target === edge.w;\n                });\n                if (i <= -1)\n                    return;\n                if ((self.edgeLabelSpace) && self.controlPoints && edges[i].type !== \"loop\") {\n                    edges[i].controlPoints = ((_a = coord === null || coord === void 0 ? void 0 : coord.points) === null || _a === void 0 ? void 0 : _a.slice(1, coord.points.length - 1)) || []; // 去掉头尾\n                    edges[i].controlPoints.forEach(function (point) {\n                        point.x += dBegin[0];\n                        point.y += dBegin[1];\n                    });\n                }\n            });\n        }\n        if (self.onLayoutEnd)\n            self.onLayoutEnd();\n        return {\n            nodes: nodes,\n            edges: edges,\n        };\n    };\n    DagreLayout.prototype.getRadialPos = function (dimValue, range, rangeLength, radius, arcRange) {\n        if (arcRange === void 0) { arcRange = [0, 1]; }\n        // dimRatio 占圆弧的比例\n        var dimRatio = (dimValue - range[0]) / rangeLength;\n        // 再进一步归一化到指定的范围上\n        dimRatio = dimRatio * (arcRange[1] - arcRange[0]) + arcRange[0];\n        // 使用最终归一化后的范围计算角度\n        var angle = dimRatio * 2 * Math.PI; // 弧度\n        // 将极坐标系转换为直角坐标系\n        return {\n            x: Math.cos(angle) * radius,\n            y: Math.sin(angle) * radius\n        };\n    };\n    DagreLayout.prototype.getType = function () {\n        return \"dagre\";\n    };\n    return DagreLayout;\n}(base_1.Base));\nexports.DagreLayout = DagreLayout;\n"},"sourceMaps":{"js":{"version":3,"file":"dagre.js","sourceRoot":"","sources":["../../src/layout/dagre.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @fileOverview dagre layout\n * @author shiwu.wyy@antfin.com\n */\n\nimport { Edge, OutNode, DagreLayoutOptions, PointTuple, Point, Node } from \"./types\";\nimport dagre from \"./dagre/index\";\nimport { isArray, isNumber, isObject, getEdgeTerminal, getFunc, isString } from \"../util\";\nimport { Base } from \"./base\";\nimport { Graph as DagreGraph } from './dagre/graph';\n\n/**\n * 层次布局\n */\nexport class DagreLayout extends Base {\n  /** layout 方向, 可选 TB, BT, LR, RL */\n  public rankdir: \"TB\" | \"BT\" | \"LR\" | \"RL\" = \"TB\";\n\n  /** 节点对齐方式，可选 UL, UR, DL, DR */\n  public align: undefined | \"UL\" | \"UR\" | \"DL\" | \"DR\";\n\n  /** 布局的起始（左上角）位置 */\n  public begin: PointTuple;\n\n  /** 节点大小 */\n  public nodeSize: number | number[] | undefined;\n\n  /** 节点水平间距(px) */\n  public nodesepFunc: ((d?: any) => number) | undefined;\n\n  /** 每一层节点之间间距 */\n  public ranksepFunc: ((d?: any) => number) | undefined;\n\n  /** 节点水平间距(px) */\n  public nodesep: number = 50;\n\n  /** 每一层节点之间间距 */\n  public ranksep: number = 50;\n\n  /** 是否保留布局连线的控制点 */\n  public controlPoints: boolean = false;\n\n  /** 每层节点是否根据节点数据中的 comboId 进行排序，以防止同层 combo 重叠 */\n  public sortByCombo: boolean = false;\n\n  /** 是否保留每条边上的dummy node */\n  public edgeLabelSpace: boolean = true;\n\n  /** 是否基于 dagre 进行辐射布局，若是，第一层节点将被放置在最内环上，其余层依次向外辐射 */\n  public radial: boolean = false;\n\n  /** radial 下生效，中心节点，被指定的节点及其同层节点将被放置在最内环上 */\n  public focusNode: string | Node | null;\n\n  /** 给定的节点顺序，配合keepNodeOrder使用 */\n  public nodeOrder: string[];\n\n  /** 上次的布局结果 */\n  public preset: {\n    nodes: OutNode[],\n    edges: any[],\n  };\n\n  public nodes: OutNode[] = [];\n\n  public edges: Edge[] = [];\n\n  /** 迭代结束的回调函数 */\n  public onLayoutEnd: () => void = () => {};\n\n  private nodeMap: {\n    [id: string]: OutNode;\n  }\n\n  constructor(options?: DagreLayoutOptions) {\n    super();\n    this.updateCfg(options);\n  }\n\n  public getDefaultCfg() {\n    return {\n      rankdir: \"TB\", // layout 方向, 可选 TB, BT, LR, RL\n      align: undefined, // 节点对齐方式，可选 UL, UR, DL, DR\n      nodeSize: undefined, // 节点大小\n      nodesepFunc: undefined, // 节点水平间距(px)\n      ranksepFunc: undefined, // 每一层节点之间间距\n      nodesep: 50, // 节点水平间距(px)\n      ranksep: 50, // 每一层节点之间间距\n      controlPoints: false, // 是否保留布局连线的控制点\n      radial: false, // 是否基于 dagre 进行辐射布局\n      focusNode: null, // radial 为 true 时生效，关注的节点\n    };\n  }\n\n  public layoutNode = (nodeId: string) => {\n    const self = this;\n    const { nodes } = self;\n    const node = nodes.find((node) => node.id === nodeId);\n    if (node) {\n      const layout = node.layout !== false;\n      return layout;\n    }\n    return true;\n  }\n\n  /**\n   * 执行布局\n   */\n  public execute() {\n    const self = this;\n    const { nodes, nodeSize, rankdir, combos, begin, radial, comboEdges = [], vedges = [] } = self;\n    if (!nodes) return;\n    const edges = (self.edges as any[]) || [];\n    const g = new DagreGraph({\n      multigraph: true,\n      compound: true,\n    });\n\n    // collect the nodes in their combo, to create virtual edges for comboEdges\n    self.nodeMap = {};\n    const nodeComboMap = {} as any;\n    nodes.forEach(node => {\n      self.nodeMap[node.id] = node;\n      if (!node.comboId) return;\n      nodeComboMap[node.comboId] = nodeComboMap[node.comboId] || [];\n      nodeComboMap[node.comboId].push(node.id);\n    })\n\n    let nodeSizeFunc: (d?: any) => number[];\n    if (!nodeSize) {\n      nodeSizeFunc = (d: any) => {\n        if (d.size) {\n          if (isArray(d.size)) {\n            return d.size;\n          }  if (isObject(d.size)) {\n            return [d.size.width || 40, d.size.height || 40];\n          }\n          return [d.size, d.size];\n        }\n        return [40, 40];\n      };\n    } else if (isArray(nodeSize)) {\n      nodeSizeFunc = () => nodeSize;\n    } else {\n      nodeSizeFunc = () => [nodeSize, nodeSize];\n    }\n    const ranksepfunc = getFunc(self.ranksep, 50, self.ranksepFunc);\n    const nodesepfunc = getFunc(self.nodesep, 50, self.nodesepFunc);\n    let horisep: Function = nodesepfunc;\n    let vertisep: Function = ranksepfunc;\n\n    if (rankdir === \"LR\" || rankdir === \"RL\") {\n      horisep = ranksepfunc;\n      vertisep = nodesepfunc;\n    }\n    g.setDefaultEdgeLabel(() => ({}));\n    g.setGraph(self);\n\n    const comboMap: { [key: string]: any } = {};\n\n    if (this.sortByCombo && combos) {\n      combos.forEach((combo) => {\n        comboMap[combo.id] = combo;\n        // regard the collapsed combo as a node\n        if (combo.collapsed) {\n          const size = nodeSizeFunc(combo);\n          const verti = vertisep(combo);\n          const hori = horisep(combo);\n          const width = size[0] + 2 * hori;\n          const height = size[1] + 2 * verti;\n          g.setNode(combo.id, { width, height });\n        }\n        if (!combo.parentId) return;\n        if (!comboMap[combo.parentId]) {\n          g.setNode(combo.parentId, {});\n        }\n        g.setParent(combo.id, combo.parentId);\n      });\n    }\n\n    nodes.filter((node) => node.layout !== false).forEach((node) => {\n      const size = nodeSizeFunc(node);\n      const verti = vertisep(node);\n      const hori = horisep(node);\n      const width = size[0] + 2 * hori;\n      const height = size[1] + 2 * verti;\n      const layer = node.layer;\n      if (isNumber(layer)) {\n        // 如果有layer属性，加入到node的label中\n        g.setNode(node.id, { width, height, layer });\n      } else {\n        g.setNode(node.id, { width, height });\n      }\n\n      if (this.sortByCombo && node.comboId) {\n        if (!comboMap[node.comboId]) {\n          comboMap[node.comboId] = { id: node.comboId };\n          g.setNode(node.comboId, {});\n        }\n        g.setParent(node.id, node.comboId);\n      }\n    });\n    \n\n\n    edges.forEach((edge) => {\n      // dagrejs Wiki https://github.com/dagrejs/dagre/wiki#configuring-the-layout\n      const source = getEdgeTerminal(edge, 'source');\n      const target = getEdgeTerminal(edge, 'target');\n      if (this.layoutNode(source) && this.layoutNode(target)) {\n        g.setEdge(source, target, {\n          weight: edge.weight || 1,\n        });\n      }\n    });\n\n    // create virtual edges from node to node for comboEdges\n    (comboEdges?.concat(vedges || []))?.forEach((comboEdge: any) => {\n      const { source, target } = comboEdge;\n      const sources = comboMap[source]?.collapsed ? [source] : nodeComboMap[source] || [source];\n      const targets =  comboMap[target]?.collapsed ? [target] : nodeComboMap[target] || [target];\n      sources.forEach((s: string) => {\n        targets.forEach((t: string) => {\n          g.setEdge(s, t, {\n            weight: comboEdge.weight || 1,\n          });\n        })\n      })\n    })\n\n    // 考虑增量图中的原始图\n    let prevGraph: DagreGraph | undefined = undefined;\n    if (self.preset?.nodes) {\n      prevGraph = new DagreGraph({\n        multigraph: true,\n        compound: true,\n      });\n      self.preset.nodes.forEach((node) => {\n        prevGraph?.setNode(node.id, node);\n      });\n    }\n\n    dagre.layout(g, {\n      prevGraph,\n      edgeLabelSpace: self.edgeLabelSpace,\n      keepNodeOrder: Boolean(!!self.nodeOrder),\n      nodeOrder: self.nodeOrder,\n    });\n\n    const dBegin = [0, 0];\n    if (begin) {\n      let minX = Infinity;\n      let minY = Infinity;\n      g.nodes().forEach((node) => {\n        const coord = g.node(node)!;\n        if (minX > coord.x!) minX = coord.x!;\n        if (minY > coord.y!) minY = coord.y!;\n      });\n      g.edges().forEach((edge) => {\n        const coord = g.edge(edge)!;\n        coord.points?.forEach((point: any) => {\n          if (minX > point.x) minX = point.x;\n          if (minY > point.y) minY = point.y;\n        });\n      });\n      dBegin[0] = begin[0] - minX;\n      dBegin[1] = begin[1] - minY;\n    }\n\n    // 变形为辐射\n    if (radial) {\n      const { focusNode, ranksep, getRadialPos } = this;\n      const focusId = isString(focusNode) ? focusNode: focusNode?.id;\n      const focusLayer = focusId ? g.node(focusId)?._rank : 0;\n      const layers: any[] = [];\n      const isHorizontal = rankdir === 'LR' || rankdir === 'RL';\n      const dim = isHorizontal ? 'y' : 'x';\n      const sizeDim = isHorizontal ? 'height' : 'width';\n      // 找到整个图作为环的坐标维度（dim）的最大、最小值，考虑节点宽度\n      let min = Infinity;\n      let max = -Infinity;\n      g.nodes().forEach((node: any) => {\n        const coord = g.node(node)! as any;\n        const i = nodes.findIndex((it) => it.id === node);\n        if (!nodes[i]) return;\n        const currentNodesep = nodesepfunc(nodes[i]);\n\n        if (focusLayer === 0) {\n          if (!layers[coord._rank]) layers[coord._rank] = { nodes: [], totalWidth: 0, maxSize: -Infinity };\n          layers[coord._rank].nodes.push(node);\n          layers[coord._rank].totalWidth += currentNodesep * 2 + coord[sizeDim];\n          if (layers[coord._rank].maxSize < Math.max(coord.width, coord.height)) layers[coord._rank].maxSize = Math.max(coord.width, coord.height);\n        } else {\n          const diffLayer = coord._rank - focusLayer!;\n          if (diffLayer === 0) {\n            if (!layers[diffLayer]) layers[diffLayer] = { nodes: [], totalWidth: 0, maxSize: -Infinity };\n            layers[diffLayer].nodes.push(node);\n            layers[diffLayer].totalWidth += currentNodesep * 2 + coord[sizeDim];\n            if (layers[diffLayer].maxSize < Math.max(coord.width, coord.height)) layers[diffLayer].maxSize = Math.max(coord.width, coord.height);\n          } else {\n            const diffLayerAbs = Math.abs(diffLayer);\n            if (!layers[diffLayerAbs]) layers[diffLayerAbs] = { left: [], right: [], totalWidth: 0, maxSize: -Infinity };\n            layers[diffLayerAbs].totalWidth += currentNodesep * 2 + coord[sizeDim];\n            if (layers[diffLayerAbs].maxSize < Math.max(coord.width, coord.height)) layers[diffLayerAbs].maxSize = Math.max(coord.width, coord.height);\n            if (diffLayer < 0) {\n              layers[diffLayerAbs].left.push(node);\n            } else {\n              layers[diffLayerAbs].right.push(node);\n            }\n          }\n        }\n        const leftPos = coord[dim] - coord[sizeDim] / 2 - currentNodesep;\n        const rightPos = coord[dim] + coord[sizeDim] / 2 + currentNodesep;\n        if (leftPos < min) min = leftPos;\n        if (rightPos > max) max = rightPos;\n      });\n      // const padding = (max - min) * 0.1; // TODO\n      // \b初始化为第一圈的半径，后面根据每层 ranksep 叠加\n      let radius = ranksep || 50; // TODO;\n      const radiusMap: any = {};\n\n      // 扩大最大最小值范围，以便为环上留出接缝处的空隙\n      const rangeLength = (max - min) / 0.9;\n      const range = [ (min + max - rangeLength) * 0.5 , (min + max + rangeLength) * 0.5 ];\n\n      // 根据半径、分布比例，计算节点在环上的位置，并返回该组节点中最大的 ranksep 值\n      const processNodes = (layerNodes: any, radius: number, propsMaxRanksep = -Infinity, arcRange = [0, 1]) => {\n        let maxRanksep = propsMaxRanksep;\n        layerNodes.forEach((node: any) => {\n          const coord = g.node(node);\n          radiusMap[node] = radius;\n          // 获取变形为 radial 后的直角坐标系坐标\n          const { x: newX, y: newY } = getRadialPos(coord![dim]!, range, rangeLength, radius, arcRange);\n          // 将新坐标写入源数据\n          const i = nodes.findIndex((it) => it.id === node);\n          if (!nodes[i]) return;\n          nodes[i].x = newX + dBegin[0];\n          nodes[i].y = newY + dBegin[1];\n          // @ts-ignore: pass layer order to data for increment layout use\n          nodes[i]._order = coord._order;\n\n          // 找到本层最大的一个 ranksep，作为下一层与本层的间隙，叠加到下一层的半径上\n          const currentNodeRanksep = ranksepfunc(nodes[i]);\n          if (maxRanksep < currentNodeRanksep) maxRanksep = currentNodeRanksep;\n        });\n        return maxRanksep;\n      };\n\n      let isFirstLevel = true;\n      const lastLayerMaxNodeSize = 0;\n      layers.forEach((layerNodes) => {\n        if (!layerNodes?.nodes?.length && !layerNodes?.left?.length && !layerNodes?.right?.length) return;\n        // 第一层只有一个节点，直接放在圆心，初始半径设定为 0\n        if (isFirstLevel && layerNodes.nodes.length === 1) {\n          // 将新坐标写入源数据\n          const i = nodes.findIndex((it) => it.id === layerNodes.nodes[0]);\n          if (i <= -1) return;\n          nodes[i].x = dBegin[0];\n          nodes[i].y = dBegin[1];\n          radiusMap[layerNodes.nodes[0]] = 0;\n          radius = ranksepfunc(nodes[i]);\n          isFirstLevel = false;\n          return;\n        }\n\n        // 为接缝留出空隙，半径也需要扩大\n        radius = Math.max(radius, layerNodes.totalWidth / (2 * Math.PI)); // / 0.9;\n        \n        let maxRanksep = -Infinity;\n        if (focusLayer === 0 || layerNodes.nodes?.length) {\n          maxRanksep = processNodes(layerNodes.nodes, radius, maxRanksep, [0, 1]); // 0.8\n        } else {\n          const leftRatio = layerNodes.left?.length / (layerNodes.left?.length + layerNodes.right?.length);\n          maxRanksep= processNodes(layerNodes.left, radius, maxRanksep, [0, leftRatio]); // 接缝留出 0.05 的缝隙\n          maxRanksep = processNodes(layerNodes.right, radius, maxRanksep, [leftRatio + 0.05, 1]); // 接缝留出 0.05 的缝隙\n        }\n        radius += maxRanksep;\n        isFirstLevel = false;\n        lastLayerMaxNodeSize - layerNodes.maxSize;\n      });\n      g.edges().forEach((edge: any) => {\n        const coord = g.edge(edge);\n        const i = edges.findIndex((it) => {\n          const source = getEdgeTerminal(it, 'source');\n          const target = getEdgeTerminal(it, 'target');\n          return source === edge.v && target === edge.w;\n        });\n        if (i <= -1) return;\n        if ((self.edgeLabelSpace) && self.controlPoints && edges[i].type !== \"loop\") {\n          const otherDim = dim === 'x' ? 'y' : 'x';\n          const controlPoints = coord?.points?.slice(1, coord.points.length - 1);\n          const newControlPoints: Point[] = [];\n          const sourceOtherDimValue = g.node(edge.v)?.[otherDim]!;\n          const otherDimDist = sourceOtherDimValue - g.node(edge.w)?.[otherDim]!;\n          const sourceRadius = radiusMap[edge.v];\n          const radiusDist = sourceRadius - radiusMap[edge.w];\n          controlPoints?.forEach((point: any) => {\n            // 根据该边的起点、终点半径，及起点、终点、控制点位置关系，确定该控制点的半径\n            const cRadius = (point[otherDim] - sourceOtherDimValue) / otherDimDist * radiusDist + sourceRadius;\n            // 获取变形为 radial 后的直角坐标系坐标\n            const newPos = getRadialPos(point[dim], range, rangeLength, cRadius);\n            newControlPoints.push({\n              x: newPos.x + dBegin[0],\n              y: newPos.y + dBegin[1]\n            });\n          });\n          edges[i].controlPoints = newControlPoints;\n        }\n      });\n    } else {\n      g.nodes().forEach((node: any) => {\n        const coord = g.node(node)!;\n        if (!coord) return;\n        let ndata: any = this.nodeMap[node];\n        if (!ndata) {\n          ndata = combos?.find((it) => it.id === node);\n        }\n        if (!ndata) return;\n        ndata.x = coord.x! + dBegin[0];\n        ndata.y = coord.y! + dBegin[1];\n        // @ts-ignore: pass layer order to data for increment layout use\n        ndata._order = coord._order;\n      });\n      g.edges().forEach((edge: any) => {\n        const coord = g.edge(edge);\n        const i = edges.findIndex((it) => {\n          const source = getEdgeTerminal(it, 'source');\n          const target = getEdgeTerminal(it, 'target');\n          return source === edge.v && target === edge.w;\n        });\n        if (i <= -1) return;\n        if ((self.edgeLabelSpace) && self.controlPoints && edges[i].type !== \"loop\") {\n          edges[i].controlPoints = coord?.points?.slice(1, coord.points.length - 1) || []; // 去掉头尾\n          edges[i].controlPoints.forEach((point: any) => {\n            point.x += dBegin[0];\n            point.y += dBegin[1];\n          });\n        }\n      });\n    }\n\n    if (self.onLayoutEnd) self.onLayoutEnd();\n    return {\n      nodes,\n      edges,\n    };\n  }\n\n  private getRadialPos(dimValue: number, range: number[], rangeLength: number, radius: number, arcRange: number[] = [0, 1]) {\n    // dimRatio 占圆弧的比例\n    let dimRatio = (dimValue - range[0]) / rangeLength;\n    // 再进一步归一化到指定的范围上\n    dimRatio = dimRatio * (arcRange[1] - arcRange[0]) + arcRange[0];\n    // 使用最终归一化后的范围计算角度\n    const angle = dimRatio * 2 * Math.PI; // 弧度\n    // 将极坐标系转换为直角坐标系\n    return {\n      x: Math.cos(angle) * radius,\n      y: Math.sin(angle) * radius\n    };\n  }\n\n  public getType() {\n    return \"dagre\";\n  }\n}"]}},"error":null,"hash":"78d8df7ad442a950468e5b06ddfeccc9","cacheData":{"env":{}}}