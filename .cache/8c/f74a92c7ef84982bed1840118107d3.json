{"id":"node_modules/@antv/layout/lib/layout/concentric.js","dependencies":[{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\concentric.js.map","includedInParent":true,"mtime":1676178923568},{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\src\\layout\\concentric.ts","includedInParent":true,"mtime":1676178923832},{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\package.json","includedInParent":true,"mtime":1676178924413},{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\package.json","includedInParent":true,"mtime":1676178923486},{"name":"../util","loc":{"line":24,"column":21,"index":1059},"parent":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\concentric.js","resolved":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\util\\index.js"},{"name":"./base","loc":{"line":25,"column":21,"index":1092},"parent":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\concentric.js","resolved":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\base.js"}],"generated":{"js":"\"use strict\";\n/**\n * @fileOverview concentric layout\n * @author shiwu.wyy@antfin.com\n * this algorithm refers to <cytoscape.js> - https://github.com/cytoscape/cytoscape.js/\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ConcentricLayout = void 0;\nvar util_1 = require(\"../util\");\nvar base_1 = require(\"./base\");\n/**\n * 同心圆布局\n */\nvar ConcentricLayout = /** @class */ (function (_super) {\n    __extends(ConcentricLayout, _super);\n    function ConcentricLayout(options) {\n        var _this = _super.call(this) || this;\n        _this.nodeSize = 30;\n        /** min spacing between outside of nodes (used for radius adjustment) */\n        _this.minNodeSpacing = 10;\n        /** same as minNodeSpacing. min spacing between outside of nodes (used for radius adjustment) */\n        _this.nodeSpacing = 10;\n        /** prevents node overlap, may overflow boundingBox if not enough space */\n        _this.preventOverlap = false;\n        /** whether levels have an equal radial distance betwen them, may cause bounding box overflow */\n        _this.equidistant = false;\n        /** where nodes start in radians */\n        _this.startAngle = (3 / 2) * Math.PI;\n        /** whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false) */\n        _this.clockwise = true;\n        /** 根据 sortBy 指定的属性进行排布，数值高的放在中心，如果是 sortBy 则会计算节点度数，度数最高的放在中心 */\n        _this.sortBy = \"degree\";\n        _this.nodes = [];\n        _this.edges = [];\n        _this.width = 300;\n        _this.height = 300;\n        /** 迭代结束的回调函数 */\n        _this.onLayoutEnd = function () { };\n        _this.updateCfg(options);\n        return _this;\n    }\n    ConcentricLayout.prototype.getDefaultCfg = function () {\n        return {\n            nodeSize: 30,\n            minNodeSpacing: 10,\n            nodeSpacing: 10,\n            preventOverlap: false,\n            sweep: undefined,\n            equidistant: false,\n            startAngle: (3 / 2) * Math.PI,\n            clockwise: true,\n            maxLevelDiff: undefined,\n            sortBy: \"degree\"\n        };\n    };\n    /**\n     * 执行布局\n     */\n    ConcentricLayout.prototype.execute = function () {\n        var _a, _b;\n        var self = this;\n        var nodes = self.nodes, edges = self.edges;\n        var n = nodes.length;\n        if (n === 0) {\n            (_a = self.onLayoutEnd) === null || _a === void 0 ? void 0 : _a.call(self);\n            return;\n        }\n        if (!self.width && typeof window !== \"undefined\") {\n            self.width = window.innerWidth;\n        }\n        if (!self.height && typeof window !== \"undefined\") {\n            self.height = window.innerHeight;\n        }\n        if (!self.center) {\n            self.center = [self.width / 2, self.height / 2];\n        }\n        var center = self.center;\n        if (n === 1) {\n            nodes[0].x = center[0];\n            nodes[0].y = center[1];\n            (_b = self.onLayoutEnd) === null || _b === void 0 ? void 0 : _b.call(self);\n            return;\n        }\n        var nodeSize = self.nodeSize, nodeSpacing = self.nodeSpacing;\n        var layoutNodes = [];\n        var maxNodeSize;\n        var maxNodeSpacing = 0;\n        if ((0, util_1.isArray)(nodeSize)) {\n            maxNodeSize = Math.max(nodeSize[0], nodeSize[1]);\n        }\n        else {\n            maxNodeSize = nodeSize;\n        }\n        if ((0, util_1.isArray)(nodeSpacing)) {\n            maxNodeSpacing = Math.max(nodeSpacing[0], nodeSpacing[1]);\n        }\n        else if ((0, util_1.isNumber)(nodeSpacing)) {\n            maxNodeSpacing = nodeSpacing;\n        }\n        nodes.forEach(function (node) {\n            layoutNodes.push(node);\n            var nodeSize = maxNodeSize;\n            if ((0, util_1.isArray)(node.size)) {\n                nodeSize = Math.max(node.size[0], node.size[1]);\n            }\n            else if ((0, util_1.isNumber)(node.size)) {\n                nodeSize = node.size;\n            }\n            else if ((0, util_1.isObject)(node.size)) {\n                nodeSize = Math.max(node.size.width, node.size.height);\n            }\n            maxNodeSize = Math.max(maxNodeSize, nodeSize);\n            if ((0, util_1.isFunction)(nodeSpacing)) {\n                maxNodeSpacing = Math.max(nodeSpacing(node), maxNodeSpacing);\n            }\n        });\n        self.clockwise =\n            self.counterclockwise !== undefined\n                ? !self.counterclockwise\n                : self.clockwise;\n        // layout\n        var nodeMap = {};\n        var indexMap = {};\n        layoutNodes.forEach(function (node, i) {\n            nodeMap[node.id] = node;\n            indexMap[node.id] = i;\n        });\n        // get the node degrees\n        if (self.sortBy === \"degree\" ||\n            !(0, util_1.isString)(self.sortBy) ||\n            layoutNodes[0][self.sortBy] === undefined) {\n            self.sortBy = \"degree\";\n            if (!(0, util_1.isNumber)(nodes[0].degree)) {\n                var values_1 = (0, util_1.getDegree)(nodes.length, indexMap, edges);\n                layoutNodes.forEach(function (node, i) {\n                    node.degree = values_1[i].all;\n                });\n            }\n        }\n        // sort nodes by value\n        layoutNodes.sort(function (n1, n2) {\n            return n2[self.sortBy] - n1[self.sortBy];\n        });\n        self.maxValueNode = layoutNodes[0];\n        self.maxLevelDiff =\n            self.maxLevelDiff || self.maxValueNode[self.sortBy] / 4;\n        // put the values into levels\n        var levels = [[]];\n        var currentLevel = levels[0];\n        layoutNodes.forEach(function (node) {\n            if (currentLevel.length > 0) {\n                var diff = Math.abs(currentLevel[0][self.sortBy] - node[self.sortBy]);\n                if (self.maxLevelDiff && diff >= self.maxLevelDiff) {\n                    currentLevel = [];\n                    levels.push(currentLevel);\n                }\n            }\n            currentLevel.push(node);\n        });\n        // create positions for levels\n        var minDist = maxNodeSize + (maxNodeSpacing || self.minNodeSpacing); // min dist between nodes\n        if (!self.preventOverlap) {\n            // then strictly constrain to bb\n            var firstLvlHasMulti = levels.length > 0 && levels[0].length > 1;\n            var maxR = Math.min(self.width, self.height) / 2 - minDist;\n            var rStep = maxR / (levels.length + (firstLvlHasMulti ? 1 : 0));\n            minDist = Math.min(minDist, rStep);\n        }\n        // find the metrics for each level\n        var r = 0;\n        levels.forEach(function (level) {\n            var sweep = self.sweep;\n            if (sweep === undefined) {\n                sweep = 2 * Math.PI - (2 * Math.PI) / level.length;\n            }\n            var dTheta = (level.dTheta = sweep / Math.max(1, level.length - 1));\n            // calculate the radius\n            if (level.length > 1 && self.preventOverlap) {\n                // but only if more than one node (can't overlap)\n                var dcos = Math.cos(dTheta) - Math.cos(0);\n                var dsin = Math.sin(dTheta) - Math.sin(0);\n                var rMin = Math.sqrt((minDist * minDist) / (dcos * dcos + dsin * dsin)); // s.t. no nodes overlapping\n                r = Math.max(rMin, r);\n            }\n            level.r = r;\n            r += minDist;\n        });\n        if (self.equidistant) {\n            var rDeltaMax_1 = 0;\n            var rr_1 = 0;\n            for (var i = 0; i < levels.length; i++) {\n                var level = levels[i];\n                var rDelta = level.r - rr_1;\n                rDeltaMax_1 = Math.max(rDeltaMax_1, rDelta);\n            }\n            rr_1 = 0;\n            levels.forEach(function (level, i) {\n                if (i === 0) {\n                    rr_1 = level.r;\n                }\n                level.r = rr_1;\n                rr_1 += rDeltaMax_1;\n            });\n        }\n        // calculate the node positions\n        levels.forEach(function (level) {\n            var dTheta = level.dTheta;\n            var rr = level.r;\n            level.forEach(function (node, j) {\n                var theta = self.startAngle + (self.clockwise ? 1 : -1) * dTheta * j;\n                node.x = center[0] + rr * Math.cos(theta);\n                node.y = center[1] + rr * Math.sin(theta);\n            });\n        });\n        if (self.onLayoutEnd)\n            self.onLayoutEnd();\n        return {\n            nodes: nodes,\n            edges: edges\n        };\n    };\n    ConcentricLayout.prototype.getType = function () {\n        return \"concentric\";\n    };\n    return ConcentricLayout;\n}(base_1.Base));\nexports.ConcentricLayout = ConcentricLayout;\n"},"sourceMaps":{"js":{"version":3,"file":"concentric.js","sourceRoot":"","sources":["../../src/layout/concentric.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @fileOverview concentric layout\n * @author shiwu.wyy@antfin.com\n * this algorithm refers to <cytoscape.js> - https://github.com/cytoscape/cytoscape.js/\n */\n\nimport {\n  OutNode,\n  Edge,\n  PointTuple,\n  Size,\n  IndexMap,\n  ConcentricLayoutOptions\n} from \"./types\";\nimport { isString, isArray, isNumber, getDegree, isObject, isFunction } from \"../util\";\nimport { Base } from \"./base\";\n\ntype INode = OutNode & {\n  degree: number;\n  size: number | PointTuple | Size;\n};\n\ntype NodeMap = {\n  [key: string]: INode;\n};\n\n/**\n * 同心圆布局\n */\nexport class ConcentricLayout extends Base {\n  /** 布局中心 */\n  public center: PointTuple;\n\n  public nodeSize: number | PointTuple = 30;\n\n  /** min spacing between outside of nodes (used for radius adjustment) */\n  public minNodeSpacing: number = 10;\n\n  /** same as minNodeSpacing. min spacing between outside of nodes (used for radius adjustment) */\n  public nodeSpacing: number | number[] | ((d?: unknown) => number) | undefined = 10;\n\n  /** prevents node overlap, may overflow boundingBox if not enough space */\n  public preventOverlap: boolean = false;\n\n  /** how many radians should be between the first and last node (defaults to full circle) */\n  public sweep: number | undefined;\n\n  /** whether levels have an equal radial distance betwen them, may cause bounding box overflow */\n  public equidistant: boolean = false;\n\n  /** where nodes start in radians */\n  public startAngle: number = (3 / 2) * Math.PI;\n\n  /** whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false) */\n  public clockwise: boolean = true;\n\n  /** the letiation of concentric values in each level */\n  public maxLevelDiff: undefined | number;\n\n  /** 根据 sortBy 指定的属性进行排布，数值高的放在中心，如果是 sortBy 则会计算节点度数，度数最高的放在中心 */\n  public sortBy: string = \"degree\";\n\n  public nodes: INode[] = [];\n\n  public edges: Edge[] = [];\n\n  public width: number = 300;\n\n  public height: number = 300;\n\n  /** 迭代结束的回调函数 */\n  public onLayoutEnd: () => void = () => {};\n\n  private maxValueNode: INode | undefined;\n\n  private counterclockwise: boolean | undefined;\n\n  constructor(options?: ConcentricLayoutOptions) {\n    super();\n    this.updateCfg(options);\n  }\n\n  public getDefaultCfg() {\n    return {\n      nodeSize: 30,\n      minNodeSpacing: 10,\n      nodeSpacing: 10,\n      preventOverlap: false,\n      sweep: undefined,\n      equidistant: false,\n      startAngle: (3 / 2) * Math.PI,\n      clockwise: true,\n      maxLevelDiff: undefined,\n      sortBy: \"degree\"\n    };\n  }\n\n  /**\n   * 执行布局\n   */\n  public execute() {\n    const self = this;\n    const { nodes, edges } = self;\n    const n = nodes.length;\n    if (n === 0) {\n      self.onLayoutEnd?.();\n      return;\n    }\n\n    if (!self.width && typeof window !== \"undefined\") {\n      self.width = window.innerWidth;\n    }\n    if (!self.height && typeof window !== \"undefined\") {\n      self.height = window.innerHeight;\n    }\n    if (!self.center) {\n      self.center = [self.width / 2, self.height / 2];\n    }\n    const center = self.center;\n\n    if (n === 1) {\n      nodes[0].x = center[0];\n      nodes[0].y = center[1];\n      self.onLayoutEnd?.();\n      return;\n    }\n\n    const { nodeSize, nodeSpacing } = self;\n\n    const layoutNodes: INode[] = [];\n    let maxNodeSize: number;\n    let maxNodeSpacing: number = 0;\n    if (isArray(nodeSize)) {\n      maxNodeSize = Math.max(nodeSize[0], nodeSize[1]);\n    } else {\n      maxNodeSize = nodeSize;\n    }\n    if (isArray(nodeSpacing)) {\n      maxNodeSpacing = Math.max(nodeSpacing[0], nodeSpacing[1]);\n    } else if (isNumber(nodeSpacing)) {\n      maxNodeSpacing = nodeSpacing;\n    }\n    nodes.forEach((node) => {\n      layoutNodes.push(node);\n      let nodeSize: number = maxNodeSize;\n      if (isArray(node.size)) {\n        nodeSize = Math.max(node.size[0], node.size[1]);\n      } else if (isNumber(node.size)) {\n        nodeSize = node.size;\n      } else if (isObject(node.size)) {\n        nodeSize = Math.max((node.size as any).width, (node.size as any).height);\n      }\n      maxNodeSize = Math.max(maxNodeSize, nodeSize);\n\n      if (isFunction(nodeSpacing)) {\n        maxNodeSpacing = Math.max(nodeSpacing(node), maxNodeSpacing);\n      }\n    });\n\n    self.clockwise =\n      self.counterclockwise !== undefined\n        ? !self.counterclockwise\n        : self.clockwise;\n\n    // layout\n    const nodeMap: NodeMap = {};\n    const indexMap: IndexMap = {};\n    layoutNodes.forEach((node, i) => {\n      nodeMap[node.id] = node;\n      indexMap[node.id] = i;\n    });\n\n    // get the node degrees\n    if (\n      self.sortBy === \"degree\" ||\n      !isString(self.sortBy) ||\n      (layoutNodes[0] as any)[self.sortBy] === undefined\n    ) {\n      self.sortBy = \"degree\";\n      if (!isNumber(nodes[0].degree)) {\n        const values = getDegree(nodes.length, indexMap, edges);\n        layoutNodes.forEach((node, i) => {\n          node.degree = values[i].all;\n        });\n      }\n    }\n    // sort nodes by value\n    layoutNodes.sort(\n      (n1: INode, n2: INode) =>\n        (n2 as any)[self.sortBy] - (n1 as any)[self.sortBy]\n    );\n\n    self.maxValueNode = layoutNodes[0];\n\n    self.maxLevelDiff =\n      self.maxLevelDiff || (self.maxValueNode as any)[self.sortBy] / 4;\n\n    // put the values into levels\n    const levels: any[] = [[]];\n    let currentLevel = levels[0];\n    layoutNodes.forEach((node) => {\n      if (currentLevel.length > 0) {\n        const diff = Math.abs(\n          currentLevel[0][self.sortBy] - (node as any)[self.sortBy]\n        );\n        if (self.maxLevelDiff && diff >= self.maxLevelDiff) {\n          currentLevel = [];\n          levels.push(currentLevel);\n        }\n      }\n      currentLevel.push(node);\n    });\n\n    // create positions for levels\n    let minDist = maxNodeSize + (maxNodeSpacing || self.minNodeSpacing); // min dist between nodes\n    if (!self.preventOverlap) {\n      // then strictly constrain to bb\n      const firstLvlHasMulti = levels.length > 0 && levels[0].length > 1;\n      const maxR = Math.min(self.width, self.height) / 2 - minDist;\n      const rStep = maxR / (levels.length + (firstLvlHasMulti ? 1 : 0));\n\n      minDist = Math.min(minDist, rStep);\n    }\n\n    // find the metrics for each level\n    let r = 0;\n    levels.forEach((level) => {\n      let sweep = self.sweep;\n      if (sweep === undefined) {\n        sweep = 2 * Math.PI - (2 * Math.PI) / level.length;\n      }\n      const dTheta = (level.dTheta = sweep / Math.max(1, level.length - 1));\n\n      // calculate the radius\n      if (level.length > 1 && self.preventOverlap) {\n        // but only if more than one node (can't overlap)\n        const dcos = Math.cos(dTheta) - Math.cos(0);\n        const dsin = Math.sin(dTheta) - Math.sin(0);\n        const rMin = Math.sqrt(\n          (minDist * minDist) / (dcos * dcos + dsin * dsin)\n        ); // s.t. no nodes overlapping\n\n        r = Math.max(rMin, r);\n      }\n      level.r = r;\n      r += minDist;\n    });\n\n    if (self.equidistant) {\n      let rDeltaMax = 0;\n      let rr = 0;\n      for (let i = 0; i < levels.length; i++) {\n        const level = levels[i];\n        const rDelta = level.r - rr;\n        rDeltaMax = Math.max(rDeltaMax, rDelta);\n      }\n      rr = 0;\n      levels.forEach((level, i) => {\n        if (i === 0) {\n          rr = level.r;\n        }\n        level.r = rr;\n        rr += rDeltaMax;\n      });\n    }\n\n    // calculate the node positions\n    levels.forEach((level) => {\n      const dTheta = level.dTheta;\n      const rr = level.r;\n      level.forEach((node: INode, j: number) => {\n        const theta = self.startAngle + (self.clockwise ? 1 : -1) * dTheta * j;\n        node.x = center[0] + rr * Math.cos(theta);\n        node.y = center[1] + rr * Math.sin(theta);\n      });\n    });\n\n    if (self.onLayoutEnd) self.onLayoutEnd();\n\n    return {\n      nodes,\n      edges\n    };\n  }\n\n  public getType() {\n    return \"concentric\";\n  }\n}\n"]}},"error":null,"hash":"dd5a4dd8904be585ce28d085534f65c2","cacheData":{"env":{}}}