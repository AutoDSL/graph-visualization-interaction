{"id":"node_modules/@antv/layout/lib/layout/force2/ForceNBody.js","dependencies":[{"name":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\lib\\layout\\force2\\ForceNBody.js.map","includedInParent":true,"mtime":499162500000},{"name":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\src\\layout\\force2\\ForceNBody.ts","includedInParent":true,"mtime":499162500000},{"name":"D:\\myData\\前端\\doing\\AutoPL\\package.json","includedInParent":true,"mtime":1674182060254},{"name":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\package.json","includedInParent":true,"mtime":1674179681168},{"name":"d3-quadtree","loc":{"line":4,"column":28,"index":134},"parent":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\lib\\layout\\force2\\ForceNBody.js","resolved":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\d3-quadtree\\src\\index.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.forceNBody = void 0;\nvar d3_quadtree_1 = require(\"d3-quadtree\");\nvar theta2 = 0.81; // Barnes-Hut approximation threshold\nvar epsilon = 0.1; // 为了防止出现除0的情况，加一个epsilon\nfunction forceNBody(nodes, nodeMap, factor, coulombDisScale2, accArray) {\n    var weightParam = factor / coulombDisScale2;\n    var data = nodes.map(function (n, i) {\n        // @ts-ignore\n        var mappedNode = nodeMap[n.id];\n        // @ts-ignore\n        var nodeData = mappedNode.data, x = mappedNode.x, y = mappedNode.y, size = mappedNode.size;\n        var nodeStrength = nodeData.layout.force.nodeStrength;\n        return {\n            x: x,\n            y: y,\n            size: size,\n            index: i,\n            vx: 0,\n            vy: 0,\n            weight: weightParam * nodeStrength,\n        };\n    });\n    var tree = (0, d3_quadtree_1.quadtree)(data, function (d) { return d.x; }, function (d) { return d.y; }).visitAfter(accumulate); // init internal node\n    data.forEach(function (n) {\n        // @ts-ignore\n        computeForce(n, tree);\n    });\n    data.map(function (n, i) {\n        // @ts-ignore\n        var mappedNode = nodeMap[nodes[i].id];\n        // @ts-ignore\n        var _a = mappedNode.data.layout.force.mass, mass = _a === void 0 ? 1 : _a;\n        // 从 0 开始，= 初始化 + 加斥力\n        accArray[2 * i] = n.vx / mass;\n        accArray[2 * i + 1] = n.vy / mass;\n    });\n    return accArray;\n}\nexports.forceNBody = forceNBody;\n// @ts-ignore\nfunction accumulate(quad) {\n    var accWeight = 0;\n    var accX = 0;\n    var accY = 0;\n    if (quad.length) {\n        // internal node, accumulate 4 child quads\n        for (var i = 0; i < 4; i++) {\n            var q = quad[i];\n            if (q && q.weight) {\n                accWeight += q.weight;\n                accX += q.x * q.weight;\n                accY += q.y * q.weight;\n            }\n        }\n        quad.x = accX / accWeight;\n        quad.y = accY / accWeight;\n        quad.weight = accWeight;\n    }\n    else {\n        // leaf node\n        var q = quad;\n        quad.x = q.data.x;\n        quad.y = q.data.y;\n        quad.weight = q.data.weight;\n    }\n}\n// @ts-ignore\nvar apply = function (quad, x1, y1, x2, y2, node) {\n    var dx = (node.x - quad.x) || epsilon;\n    var dy = (node.y - quad.y) || epsilon;\n    var width = x2 - x1;\n    var len2 = dx * dx + dy * dy;\n    var len3 = Math.sqrt(len2) * len2;\n    // far node, apply Barnes-Hut approximation\n    if ((width * width) * theta2 < len2) {\n        var param = quad.weight / len3;\n        node.vx += dx * param;\n        node.vy += dy * param;\n        return true;\n    }\n    // near quad, compute force directly\n    if (quad.length)\n        return false; // internal node, visit children\n    // leaf node\n    if (quad.data !== node) {\n        var param = quad.data.weight / len3;\n        node.vx += dx * param;\n        node.vy += dy * param;\n    }\n};\n// @ts-ignore\nfunction computeForce(node, tree) {\n    // @ts-ignore\n    tree.visit(function (quad, x1, y1, x2, y2) { return apply(quad, x1, y1, x2, y2, node); });\n}\n"},"sourceMaps":{"js":{"version":3,"file":"ForceNBody.js","sourceRoot":"","sources":["../../../src/layout/force2/ForceNBody.ts"],"names":[],"mappings":"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","sourcesContent":["import { quadtree } from 'd3-quadtree';\nimport { NodeMap } from '..';\n\nconst theta2 = 0.81; // Barnes-Hut approximation threshold\nconst epsilon = 0.1; // 为了防止出现除0的情况，加一个epsilon\n\ninterface Node {\n  x: number;\n  y: number;\n}\n\ninterface InternalNode {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  weight: number;\n  size: number;\n}\n\nexport function forceNBody(\n  nodes: Node[],\n  nodeMap: NodeMap,\n  factor: number,\n  coulombDisScale2: number,\n  accArray: number[]\n) {\n  const weightParam = factor / coulombDisScale2;\n  const data = nodes.map((n, i) => {\n    // @ts-ignore\n    const mappedNode = nodeMap[n.id];\n    // @ts-ignore\n    const { data: nodeData, x, y, size } = mappedNode;\n    const { nodeStrength } = nodeData.layout.force;\n    return {\n      x,\n      y,\n      size,\n      index: i,\n      vx: 0,\n      vy: 0,\n      weight: weightParam * nodeStrength,\n    };\n  });\n\n  const tree = quadtree(\n    data,\n    (d: any) => d.x,\n    (d: any) => d.y,\n  ).visitAfter(accumulate); // init internal node\n\n  data.forEach((n) => {\n    // @ts-ignore\n    computeForce(n, tree);\n  });\n\n  data.map((n, i) => {\n    // @ts-ignore\n    const mappedNode = nodeMap[nodes[i].id];\n    // @ts-ignore\n    const { mass = 1 } = mappedNode.data.layout.force;\n    // 从 0 开始，= 初始化 + 加斥力\n    accArray[2 * i] = n.vx / mass;\n    accArray[2 * i + 1] = n.vy / mass;\n  });\n  return accArray;\n}\n\n// @ts-ignore\nfunction accumulate(quad) {\n  let accWeight = 0;\n  let accX = 0;\n  let accY = 0;\n\n  if (quad.length) {\n    // internal node, accumulate 4 child quads\n    for (let i = 0; i < 4; i++) {\n      const q = quad[i];\n      if (q && q.weight) {\n        accWeight += q.weight;\n        accX += q.x * q.weight;\n        accY += q.y * q.weight;\n      }\n    }\n    quad.x = accX / accWeight;\n    quad.y = accY / accWeight;\n    quad.weight = accWeight;\n  } else {\n    // leaf node\n    const q = quad;\n    quad.x = q.data.x;\n    quad.y = q.data.y;\n    quad.weight = q.data.weight;\n  }\n}\n\n// @ts-ignore\nconst apply = (quad, x1: number, y1: number, x2: number, y2: number, node: InternalNode) => {\n  const dx = (node.x - quad.x) || epsilon;\n  const dy = (node.y - quad.y) || epsilon;\n  const width = x2 - x1;\n  const len2 = dx * dx + dy * dy;\n  const len3 = Math.sqrt(len2) * len2;\n\n  // far node, apply Barnes-Hut approximation\n  if ((width * width) * theta2 < len2) {\n    const param = quad.weight / len3;\n    node.vx += dx * param;\n    node.vy += dy * param;\n    return true;\n  }\n  // near quad, compute force directly\n  if (quad.length) return false; // internal node, visit children\n\n  // leaf node\n\n  if (quad.data !== node) {\n    const param = quad.data.weight / len3;\n    node.vx += dx * param;\n    node.vy += dy * param;\n  }\n};\n\n// @ts-ignore\nfunction computeForce(node: InternalNode, tree) {\n  // @ts-ignore\n  tree.visit((quad, x1, y1, x2, y2) => apply(quad, x1, y1, x2, y2, node));\n}\n"]}},"error":null,"hash":"65d50c1e953d2fbbec0545b38649ae2f","cacheData":{"env":{}}}