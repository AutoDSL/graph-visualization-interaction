{"id":"node_modules/@antv/layout/lib/layout/dagre/src/rank/network-simplex.js","dependencies":[{"name":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\rank\\network-simplex.js.map","includedInParent":true,"mtime":499162500000},{"name":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\src\\layout\\dagre\\src\\rank\\network-simplex.ts","includedInParent":true,"mtime":499162500000},{"name":"D:\\myData\\前端\\doing\\AutoPL\\package.json","includedInParent":true,"mtime":1674182060254},{"name":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\package.json","includedInParent":true,"mtime":1674179681168},{"name":"./feasible-tree","loc":{"line":4,"column":30,"index":253},"parent":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\rank\\network-simplex.js","resolved":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\rank\\feasible-tree.js"},{"name":"./util","loc":{"line":5,"column":21,"index":294},"parent":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\rank\\network-simplex.js","resolved":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\rank\\util.js"},{"name":"../util","loc":{"line":6,"column":21,"index":326},"parent":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\rank\\network-simplex.js","resolved":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\util.js"},{"name":"@antv/graphlib","loc":{"line":7,"column":25,"index":363},"parent":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\rank\\network-simplex.js","resolved":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\graphlib\\es\\index.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.exchangeEdges = exports.enterEdge = exports.leaveEdge = exports.initLowLimValues = exports.calcCutValue = exports.initCutValues = void 0;\nvar feasible_tree_1 = require(\"./feasible-tree\");\nvar util_1 = require(\"./util\");\nvar util_2 = require(\"../util\");\nvar graphlib_1 = require(\"@antv/graphlib\");\nvar preorder = graphlib_1.algorithm.preorder, postorder = graphlib_1.algorithm.postorder;\n/*\n * The network simplex algorithm assigns ranks to each node in the input graph\n * and iteratively improves the ranking to reduce the length of edges.\n *\n * Preconditions:\n *\n *    1. The input graph must be a DAG.\n *    2. All nodes in the graph must have an object value.\n *    3. All edges in the graph must have \"minlen\" and \"weight\" attributes.\n *\n * Postconditions:\n *\n *    1. All nodes in the graph will have an assigned \"rank\" attribute that has\n *       been optimized by the network simplex algorithm. Ranks start at 0.\n *\n *\n * A rough sketch of the algorithm is as follows:\n *\n *    1. Assign initial ranks to each node. We use the longest path algorithm,\n *       which assigns ranks to the lowest position possible. In general this\n *       leads to very wide bottom ranks and unnecessarily long edges.\n *    2. Construct a feasible tight tree. A tight tree is one such that all\n *       edges in the tree have no slack (difference between length of edge\n *       and minlen for the edge). This by itself greatly improves the assigned\n *       rankings by shorting edges.\n *    3. Iteratively find edges that have negative cut values. Generally a\n *       negative cut value indicates that the edge could be removed and a new\n *       tree edge could be added to produce a more compact graph.\n *\n * Much of the algorithms here are derived from Gansner, et al., \"A Technique\n * for Drawing Directed Graphs.\" The structure of the file roughly follows the\n * structure of the overall algorithm.\n */\nvar networkSimplex = function (og) {\n    var g = (0, util_2.simplify)(og);\n    (0, util_1.longestPath)(g);\n    var t = (0, feasible_tree_1.feasibleTree)(g);\n    (0, exports.initLowLimValues)(t);\n    (0, exports.initCutValues)(t, g);\n    var e;\n    var f;\n    while ((e = (0, exports.leaveEdge)(t))) {\n        f = (0, exports.enterEdge)(t, g, e);\n        (0, exports.exchangeEdges)(t, g, e, f);\n    }\n};\n/*\n * Initializes cut values for all edges in the tree.\n */\nvar initCutValues = function (t, g) {\n    var vs = postorder(t, t.nodes());\n    vs = vs === null || vs === void 0 ? void 0 : vs.slice(0, (vs === null || vs === void 0 ? void 0 : vs.length) - 1);\n    vs === null || vs === void 0 ? void 0 : vs.forEach(function (v) {\n        assignCutValue(t, g, v);\n    });\n};\nexports.initCutValues = initCutValues;\nvar assignCutValue = function (t, g, child) {\n    var childLab = t.node(child);\n    var parent = childLab.parent;\n    t.edgeFromArgs(child, parent).cutvalue = (0, exports.calcCutValue)(t, g, child);\n};\n/*\n * Given the tight tree, its graph, and a child in the graph calculate and\n * return the cut value for the edge between the child and its parent.\n */\nvar calcCutValue = function (t, g, child) {\n    var _a;\n    var childLab = t.node(child);\n    var parent = childLab.parent;\n    // True if the child is on the tail end of the edge in the directed graph\n    var childIsTail = true;\n    // The graph's view of the tree edge we're inspecting\n    var graphEdge = g.edgeFromArgs(child, parent);\n    // The accumulated cut value for the edge between this node and its parent\n    var cutValue = 0;\n    if (!graphEdge) {\n        childIsTail = false;\n        graphEdge = g.edgeFromArgs(parent, child);\n    }\n    cutValue = graphEdge.weight;\n    (_a = g.nodeEdges(child)) === null || _a === void 0 ? void 0 : _a.forEach(function (e) {\n        var isOutEdge = e.v === child;\n        var other = isOutEdge ? e.w : e.v;\n        if (other !== parent) {\n            var pointsToHead = isOutEdge === childIsTail;\n            var otherWeight = g.edge(e).weight;\n            cutValue += pointsToHead ? otherWeight : -otherWeight;\n            if (isTreeEdge(t, child, other)) {\n                var otherCutValue = t.edgeFromArgs(child, other).cutvalue;\n                cutValue += pointsToHead ? -otherCutValue : otherCutValue;\n            }\n        }\n    });\n    return cutValue;\n};\nexports.calcCutValue = calcCutValue;\nvar initLowLimValues = function (tree, root) {\n    if (root === void 0) { root = tree.nodes()[0]; }\n    dfsAssignLowLim(tree, {}, 1, root);\n};\nexports.initLowLimValues = initLowLimValues;\nvar dfsAssignLowLim = function (tree, visited, nextLim, v, parent) {\n    var _a;\n    var low = nextLim;\n    var useNextLim = nextLim;\n    var label = tree.node(v);\n    visited[v] = true;\n    (_a = tree.neighbors(v)) === null || _a === void 0 ? void 0 : _a.forEach(function (w) {\n        if (!visited[w]) {\n            useNextLim = dfsAssignLowLim(tree, visited, useNextLim, w, v);\n        }\n    });\n    label.low = low;\n    label.lim = useNextLim++;\n    if (parent) {\n        label.parent = parent;\n    }\n    else {\n        // TODO should be able to remove this when we incrementally update low lim\n        delete label.parent;\n    }\n    return useNextLim;\n};\nvar leaveEdge = function (tree) {\n    return tree.edges().find(function (e) {\n        return tree.edge(e).cutvalue < 0;\n    });\n};\nexports.leaveEdge = leaveEdge;\nvar enterEdge = function (t, g, edge) {\n    var v = edge.v;\n    var w = edge.w;\n    // For the rest of this function we assume that v is the tail and w is the\n    // head, so if we don't have this edge in the graph we should flip it to\n    // match the correct orientation.\n    if (!g.hasEdge(v, w)) {\n        v = edge.w;\n        w = edge.v;\n    }\n    var vLabel = t.node(v);\n    var wLabel = t.node(w);\n    var tailLabel = vLabel;\n    var flip = false;\n    // If the root is in the tail of the edge then we need to flip the logic that\n    // checks for the head and tail nodes in the candidates function below.\n    if (vLabel.lim > wLabel.lim) {\n        tailLabel = wLabel;\n        flip = true;\n    }\n    var candidates = g.edges().filter(function (edge) {\n        return flip === isDescendant(t, t.node(edge.v), tailLabel) &&\n            flip !== isDescendant(t, t.node(edge.w), tailLabel);\n    });\n    return (0, util_2.minBy)(candidates, function (edge) { return (0, util_1.slack)(g, edge); });\n};\nexports.enterEdge = enterEdge;\nvar exchangeEdges = function (t, g, e, f) {\n    var v = e.v;\n    var w = e.w;\n    t.removeEdge(v, w);\n    t.setEdge(f.v, f.w, {});\n    (0, exports.initLowLimValues)(t);\n    (0, exports.initCutValues)(t, g);\n    updateRanks(t, g);\n};\nexports.exchangeEdges = exchangeEdges;\nvar updateRanks = function (t, g) {\n    var root = t.nodes().find(function (v) { var _a; return !((_a = g.node(v)) === null || _a === void 0 ? void 0 : _a.parent); });\n    var vs = preorder(t, root);\n    vs = vs === null || vs === void 0 ? void 0 : vs.slice(1);\n    vs === null || vs === void 0 ? void 0 : vs.forEach(function (v) {\n        var parent = t.node(v).parent;\n        var edge = g.edgeFromArgs(v, parent);\n        var flipped = false;\n        if (!edge) {\n            edge = g.edgeFromArgs(parent, v);\n            flipped = true;\n        }\n        g.node(v).rank = g.node(parent).rank + (flipped ? edge.minlen : -edge.minlen);\n    });\n};\n/*\n * Returns true if the edge is in the tree.\n */\nvar isTreeEdge = function (tree, u, v) {\n    return tree.hasEdge(u, v);\n};\n/*\n * Returns true if the specified node is descendant of the root node per the\n * assigned low and lim attributes in the tree.\n */\nvar isDescendant = function (tree, vLabel, rootLabel) {\n    return rootLabel.low <= vLabel.lim && vLabel.lim <= rootLabel.lim;\n};\nexports.default = networkSimplex;\n"},"sourceMaps":{"js":{"version":3,"file":"network-simplex.js","sourceRoot":"","sources":["../../../../../src/layout/dagre/src/rank/network-simplex.ts"],"names":[],"mappings":"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","sourcesContent":["import { feasibleTree } from './feasible-tree';\nimport { slack, longestPath as initRank } from './util';\nimport { minBy, simplify } from '../util';\nimport { algorithm } from '@antv/graphlib';\nimport { Edge, Graph } from '../../graph';\n\n\nconst { preorder, postorder } = algorithm;\n\n\n/*\n * The network simplex algorithm assigns ranks to each node in the input graph\n * and iteratively improves the ranking to reduce the length of edges.\n *\n * Preconditions:\n *\n *    1. The input graph must be a DAG.\n *    2. All nodes in the graph must have an object value.\n *    3. All edges in the graph must have \"minlen\" and \"weight\" attributes.\n *\n * Postconditions:\n *\n *    1. All nodes in the graph will have an assigned \"rank\" attribute that has\n *       been optimized by the network simplex algorithm. Ranks start at 0.\n *\n *\n * A rough sketch of the algorithm is as follows:\n *\n *    1. Assign initial ranks to each node. We use the longest path algorithm,\n *       which assigns ranks to the lowest position possible. In general this\n *       leads to very wide bottom ranks and unnecessarily long edges.\n *    2. Construct a feasible tight tree. A tight tree is one such that all\n *       edges in the tree have no slack (difference between length of edge\n *       and minlen for the edge). This by itself greatly improves the assigned\n *       rankings by shorting edges.\n *    3. Iteratively find edges that have negative cut values. Generally a\n *       negative cut value indicates that the edge could be removed and a new\n *       tree edge could be added to produce a more compact graph.\n *\n * Much of the algorithms here are derived from Gansner, et al., \"A Technique\n * for Drawing Directed Graphs.\" The structure of the file roughly follows the\n * structure of the overall algorithm.\n */\nconst networkSimplex = (og: Graph) => {\n  const g = simplify(og);\n  initRank(g);\n  const t = feasibleTree(g);\n  initLowLimValues(t);\n  initCutValues(t, g);\n\n  let e;\n  let f;\n  while ((e = leaveEdge(t))) {\n    f = enterEdge(t, g, e);\n    exchangeEdges(t, g, e, f);\n  }\n};\n\n/*\n * Initializes cut values for all edges in the tree.\n */\nexport const initCutValues = (t: Graph, g: Graph) => {\n  let vs = postorder(t, t.nodes());\n  vs = vs?.slice(0, vs?.length - 1);\n  vs?.forEach((v: string) => {\n    assignCutValue(t, g, v);\n  });\n};\n\nconst assignCutValue = (t: Graph, g: Graph, child: string) => {\n  const childLab = t.node(child)!;\n  const parent = childLab.parent!;\n  t.edgeFromArgs(child, parent)!.cutvalue = calcCutValue(t, g, child);\n};\n\n/*\n * Given the tight tree, its graph, and a child in the graph calculate and\n * return the cut value for the edge between the child and its parent.\n */\nexport const calcCutValue = (t: Graph, g: Graph, child: string) => {\n  const childLab = t.node(child)!;\n  const parent = childLab.parent as string;\n  // True if the child is on the tail end of the edge in the directed graph\n  let childIsTail = true;\n  // The graph's view of the tree edge we're inspecting\n  let graphEdge = g.edgeFromArgs(child, parent)!;\n  // The accumulated cut value for the edge between this node and its parent\n  let cutValue = 0;\n\n  if (!graphEdge) {\n    childIsTail = false;\n    graphEdge = g.edgeFromArgs(parent, child)!;\n  }\n\n  cutValue = graphEdge.weight!;\n\n  g.nodeEdges(child)?.forEach((e) => {\n    const isOutEdge = e.v === child;\n    const other = isOutEdge ? e.w : e.v;\n\n    if (other !== parent) {\n      const pointsToHead = isOutEdge === childIsTail;\n      const otherWeight = g.edge(e)!.weight!;\n\n      cutValue += pointsToHead ? otherWeight : -otherWeight;\n      if (isTreeEdge(t, child, other)) {\n        const otherCutValue = t.edgeFromArgs(child, other)!.cutvalue;\n        cutValue += pointsToHead ? -otherCutValue : otherCutValue;\n      }\n    }\n  });\n\n  return cutValue;\n};\n\nexport const initLowLimValues = (tree: Graph, root: string = tree.nodes()[0]) => {\n  dfsAssignLowLim(tree, {}, 1, root);\n};\n\nconst dfsAssignLowLim = (tree: Graph, visited: Record<string, boolean>, nextLim: number, v: string, parent?: string) => {\n  const low = nextLim;\n  let useNextLim = nextLim;\n  const label = tree.node(v)!;\n\n  visited[v] = true;\n  tree.neighbors(v)?.forEach((w) => {\n    if (!visited[w]) {\n      useNextLim = dfsAssignLowLim(tree, visited, useNextLim, w, v);\n    }\n  });\n\n  label.low = low;\n  label.lim = useNextLim++;\n  if (parent) {\n    label.parent = parent;\n  } else {\n    // TODO should be able to remove this when we incrementally update low lim\n    delete label.parent;\n  }\n\n  return useNextLim;\n};\n\nexport const leaveEdge = (tree: Graph) => {\n  return tree.edges().find((e) => {\n    return tree.edge(e)!.cutvalue < 0;\n  });\n};\n\nexport const enterEdge = (t: Graph, g: Graph, edge: any) => {\n  let v = edge.v;\n  let w = edge.w;\n\n  // For the rest of this function we assume that v is the tail and w is the\n  // head, so if we don't have this edge in the graph we should flip it to\n  // match the correct orientation.\n  if (!g.hasEdge(v, w)) {\n    v = edge.w;\n    w = edge.v;\n  }\n\n  const vLabel = t.node(v)!;\n  const wLabel = t.node(w)!;\n  let tailLabel = vLabel;\n  let flip = false;\n\n  // If the root is in the tail of the edge then we need to flip the logic that\n  // checks for the head and tail nodes in the candidates function below.\n  if ((vLabel.lim as number) > (wLabel.lim as number)) {\n    tailLabel = wLabel;\n    flip = true;\n  }\n\n  const candidates = g.edges().filter((edge) => {\n    return flip === isDescendant(t, t.node(edge.v), tailLabel) &&\n           flip !== isDescendant(t, t.node(edge.w), tailLabel);\n  });\n\n  return minBy(candidates, (edge) => { return slack(g, edge); });\n};\n\nexport const exchangeEdges = (t: Graph, g: Graph, e: Edge, f: Edge) => {\n  const v = e.v;\n  const w = e.w;\n  t.removeEdge(v, w);\n  t.setEdge(f.v, f.w, {});\n  initLowLimValues(t);\n  initCutValues(t, g);\n  updateRanks(t, g);\n};\n\nconst updateRanks = (t: Graph, g: Graph) => {\n  const root = t.nodes().find((v) =>{ return !g.node(v)?.parent; })!;\n  let vs = preorder(t, root);\n  vs = vs?.slice(1);\n  vs?.forEach((v: string) => {\n    const parent = t.node(v)!.parent as string;\n    let edge = g.edgeFromArgs(v, parent);\n    let flipped = false;\n\n    if (!edge) {\n      edge = g.edgeFromArgs(parent, v)!;\n      flipped = true;\n    }\n\n    g.node(v)!.rank = g.node(parent)!.rank! + (flipped ? edge.minlen! : -edge.minlen!);\n  });\n};\n\n/*\n * Returns true if the edge is in the tree.\n */\nconst isTreeEdge = (tree: Graph, u: string, v: string) => {\n  return tree.hasEdge(u, v);\n};\n\n/*\n * Returns true if the specified node is descendant of the root node per the\n * assigned low and lim attributes in the tree.\n */\nconst isDescendant = (tree: Graph, vLabel: any, rootLabel: any) => {\n  return rootLabel.low <= vLabel.lim && vLabel.lim <= rootLabel.lim;\n};\n\nexport default networkSimplex;"]}},"error":null,"hash":"3da76b403d872209384715ef9057e6dd","cacheData":{"env":{}}}