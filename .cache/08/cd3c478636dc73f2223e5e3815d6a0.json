{"id":"node_modules/@antv/layout/lib/layout/gpu/gForce.js","dependencies":[{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\gpu\\gForce.js.map","includedInParent":true,"mtime":1676178923646},{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\src\\layout\\gpu\\gForce.ts","includedInParent":true,"mtime":1676178923911},{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\package.json","includedInParent":true,"mtime":1676178924413},{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\package.json","includedInParent":true,"mtime":1676178923486},{"name":"../base","loc":{"line":60,"column":21,"index":3490},"parent":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\gpu\\gForce.js","resolved":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\base.js"},{"name":"../../util","loc":{"line":61,"column":21,"index":3523},"parent":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\gpu\\gForce.js","resolved":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\util\\index.js"},{"name":"@antv/g-webgpu","loc":{"line":63,"column":25,"index":3577},"parent":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\gpu\\gForce.js","resolved":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\g-webgpu\\es\\index.js"},{"name":"../../util/gpu","loc":{"line":64,"column":20,"index":3616},"parent":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\gpu\\gForce.js","resolved":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\util\\gpu.js"},{"name":"../../util/math","loc":{"line":65,"column":21,"index":3656},"parent":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\gpu\\gForce.js","resolved":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\util\\math.js"},{"name":"./gForceShader","loc":{"line":66,"column":29,"index":3705},"parent":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\gpu\\gForce.js","resolved":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\gpu\\gForceShader.js"},{"name":"../constants","loc":{"line":67,"column":26,"index":3750},"parent":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\gpu\\gForce.js","resolved":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\constants.js"}],"generated":{"js":"\"use strict\";\n// @ts-nocheck\n/**\n * @fileOverview fruchterman layout\n * @author shiwu.wyy@antfin.com\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GForceGPULayout = void 0;\nvar base_1 = require(\"../base\");\nvar util_1 = require(\"../../util\");\n// @ts-ignore\nvar g_webgpu_1 = require(\"@antv/g-webgpu\");\nvar gpu_1 = require(\"../../util/gpu\");\nvar math_1 = require(\"../../util/math\");\nvar gForceShader_1 = require(\"./gForceShader\");\nvar constants_1 = require(\"../constants\");\n/**\n * graphin 中的 force 布局\n */\nvar GForceGPULayout = /** @class */ (function (_super) {\n    __extends(GForceGPULayout, _super);\n    function GForceGPULayout(options) {\n        var _this = _super.call(this) || this;\n        /** 停止迭代的最大迭代数 */\n        _this.maxIteration = 1000;\n        /** 弹簧引力系数 */\n        _this.edgeStrength = 200;\n        /** 斥力系数 */\n        _this.nodeStrength = 1000;\n        /** 库伦系数 */\n        _this.coulombDisScale = 0.005;\n        /** 阻尼系数 */\n        _this.damping = 0.9;\n        /** 最大速度 */\n        _this.maxSpeed = 1000;\n        /** 一次迭代的平均移动距离小于该值时停止迭代 */\n        _this.minMovement = 0.5;\n        /** 迭代中衰减 */\n        _this.interval = 0.02;\n        /** 斥力的一个系数 */\n        _this.factor = 1;\n        /** 理想边长 */\n        _this.linkDistance = 1;\n        /** 重力大小 */\n        _this.gravity = 10;\n        /** 是否启用web worker。前提是在web worker里执行布局，否则无效\t*/\n        _this.workerEnabled = false;\n        _this.nodes = [];\n        _this.edges = [];\n        _this.width = 300;\n        _this.height = 300;\n        _this.nodeMap = {};\n        _this.nodeIdxMap = {};\n        _this.updateCfg(options);\n        return _this;\n    }\n    GForceGPULayout.prototype.getDefaultCfg = function () {\n        return {\n            maxIteration: 2000,\n            gravity: 10,\n            clustering: false,\n            clusterGravity: 10\n        };\n    };\n    /**\n     * 执行布局\n     */\n    GForceGPULayout.prototype.execute = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var self, nodes, center, nodeMap, nodeIdxMap;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        self = this;\n                        nodes = self.nodes;\n                        if (!nodes || nodes.length === 0) {\n                            if (self.onLayoutEnd)\n                                self.onLayoutEnd();\n                            return [2 /*return*/];\n                        }\n                        if (!self.width && typeof window !== \"undefined\") {\n                            self.width = window.innerWidth;\n                        }\n                        if (!self.height && typeof window !== \"undefined\") {\n                            self.height = window.innerHeight;\n                        }\n                        if (!self.center) {\n                            self.center = [self.width / 2, self.height / 2];\n                        }\n                        center = self.center;\n                        if (nodes.length === 1) {\n                            nodes[0].x = center[0];\n                            nodes[0].y = center[1];\n                            if (self.onLayoutEnd)\n                                self.onLayoutEnd();\n                            return [2 /*return*/];\n                        }\n                        nodeMap = {};\n                        nodeIdxMap = {};\n                        nodes.forEach(function (node, i) {\n                            if (!(0, util_1.isNumber)(node.x))\n                                node.x = Math.random() * self.width;\n                            if (!(0, util_1.isNumber)(node.y))\n                                node.y = Math.random() * self.height;\n                            nodeMap[node.id] = node;\n                            nodeIdxMap[node.id] = i;\n                        });\n                        self.nodeMap = nodeMap;\n                        self.nodeIdxMap = nodeIdxMap;\n                        self.nodeStrength = (0, gpu_1.proccessToFunc)(self.nodeStrength, 1);\n                        self.edgeStrength = (0, gpu_1.proccessToFunc)(self.edgeStrength, 1);\n                        // layout\n                        return [4 /*yield*/, self.run()];\n                    case 1:\n                        // layout\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    GForceGPULayout.prototype.executeWithWorker = function (canvas, ctx) {\n        var self = this;\n        var nodes = self.nodes;\n        var center = self.center;\n        if (!nodes || nodes.length === 0) {\n            return;\n        }\n        if (nodes.length === 1) {\n            nodes[0].x = center[0];\n            nodes[0].y = center[1];\n            return;\n        }\n        var nodeMap = {};\n        var nodeIdxMap = {};\n        nodes.forEach(function (node, i) {\n            if (!(0, util_1.isNumber)(node.x))\n                node.x = Math.random() * self.width;\n            if (!(0, util_1.isNumber)(node.y))\n                node.y = Math.random() * self.height;\n            nodeMap[node.id] = node;\n            nodeIdxMap[node.id] = i;\n        });\n        self.nodeMap = nodeMap;\n        self.nodeIdxMap = nodeIdxMap;\n        self.nodeStrength = (0, gpu_1.proccessToFunc)(self.nodeStrength, 1);\n        self.edgeStrength = (0, gpu_1.proccessToFunc)(self.edgeStrength, 1);\n        // layout\n        self.run(canvas, ctx);\n    };\n    GForceGPULayout.prototype.run = function (canvas, ctx) {\n        return __awaiter(this, void 0, void 0, function () {\n            var self, nodes, edges, maxIteration, numParticles, _a, maxEdgePerVetex, nodesEdgesArray, masses, nodeStrengths, centerXs, centerYs, centerGravities, fxs, fys, gravity, center, nodeAttributeArray1, nodeAttributeArray2, workerEnabled, world, onLayoutEnd, initPreviousData, i, kernelGForce, kernelAveMovement, execute;\n            var _this = this;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        self = this;\n                        nodes = self.nodes;\n                        edges = self.edges;\n                        maxIteration = self.maxIteration;\n                        if (!self.width && typeof window !== \"undefined\") {\n                            self.width = window.innerWidth;\n                        }\n                        if (!self.height && typeof window !== \"undefined\") {\n                            self.height = window.innerHeight;\n                        }\n                        numParticles = nodes.length;\n                        self.linkDistance = (0, gpu_1.proccessToFunc)(self.linkDistance);\n                        self.edgeStrength = (0, gpu_1.proccessToFunc)(self.edgeStrength);\n                        _a = (0, gpu_1.buildTextureDataWithTwoEdgeAttr)(nodes, edges, self.linkDistance, self.edgeStrength), maxEdgePerVetex = _a.maxEdgePerVetex, nodesEdgesArray = _a.array;\n                        // init degree for mass\n                        self.degrees = (0, math_1.getDegree)(nodes.length, self.nodeIdxMap, edges).map(function (degree) { return degree.all; });\n                        masses = [];\n                        nodeStrengths = [];\n                        centerXs = [];\n                        centerYs = [];\n                        centerGravities = [];\n                        fxs = [];\n                        fys = [];\n                        if (!self.getMass) {\n                            self.getMass = function (d) {\n                                return self.degrees[self.nodeIdxMap[d.id]] || 1;\n                            };\n                        }\n                        gravity = self.gravity;\n                        center = self.center;\n                        nodes.forEach(function (node, i) {\n                            masses.push(self.getMass(node));\n                            nodeStrengths.push(self.nodeStrength(node));\n                            if (!self.degrees[i])\n                                self.degrees[i] = 0;\n                            var nodeGravity = [center[0], center[1], gravity];\n                            if (self.getCenter) {\n                                var customCenter = self.getCenter(node, self.degrees[i]);\n                                if (customCenter &&\n                                    (0, util_1.isNumber)(customCenter[0]) &&\n                                    (0, util_1.isNumber)(customCenter[1]) &&\n                                    (0, util_1.isNumber)(customCenter[2])) {\n                                    nodeGravity = customCenter;\n                                }\n                            }\n                            centerXs.push(nodeGravity[0]);\n                            centerYs.push(nodeGravity[1]);\n                            centerGravities.push(nodeGravity[2]);\n                            if ((0, util_1.isNumber)(node.fx) && (0, util_1.isNumber)(node.fy)) {\n                                fxs.push(node.fx || 0.001);\n                                fys.push(node.fy || 0.001);\n                            }\n                            else {\n                                fxs.push(0);\n                                fys.push(0);\n                            }\n                        });\n                        nodeAttributeArray1 = (0, gpu_1.arrayToTextureData)([\n                            masses,\n                            self.degrees,\n                            nodeStrengths,\n                            fxs\n                        ]);\n                        nodeAttributeArray2 = (0, gpu_1.arrayToTextureData)([\n                            centerXs,\n                            centerYs,\n                            centerGravities,\n                            fys\n                        ]);\n                        workerEnabled = self.workerEnabled;\n                        if (workerEnabled) {\n                            world = g_webgpu_1.World.create({\n                                canvas: canvas,\n                                engineOptions: {\n                                    supportCompute: true\n                                }\n                            });\n                        }\n                        else {\n                            world = g_webgpu_1.World.create({\n                                engineOptions: {\n                                    supportCompute: true\n                                }\n                            });\n                        }\n                        onLayoutEnd = self.onLayoutEnd;\n                        initPreviousData = [];\n                        nodesEdgesArray.forEach(function (value) {\n                            initPreviousData.push(value);\n                        });\n                        for (i = 0; i < 4; i++) {\n                            initPreviousData.push(0);\n                        }\n                        kernelGForce = world\n                            .createKernel(gForceShader_1.gForceBundle)\n                            .setDispatch([numParticles, 1, 1])\n                            .setBinding({\n                            u_Data: nodesEdgesArray,\n                            u_damping: self.damping,\n                            u_maxSpeed: self.maxSpeed,\n                            u_minMovement: self.minMovement,\n                            u_coulombDisScale: self.coulombDisScale,\n                            u_factor: self.factor,\n                            u_NodeAttributeArray1: nodeAttributeArray1,\n                            u_NodeAttributeArray2: nodeAttributeArray2,\n                            MAX_EDGE_PER_VERTEX: maxEdgePerVetex,\n                            VERTEX_COUNT: numParticles,\n                            u_AveMovement: initPreviousData,\n                            u_interval: self.interval // 每次迭代更新，首次设置为 interval，在 onIterationCompleted 中更新\n                        });\n                        kernelAveMovement = world\n                            .createKernel(gForceShader_1.aveMovementBundle)\n                            .setDispatch([1, 1, 1])\n                            .setBinding({\n                            u_Data: nodesEdgesArray,\n                            VERTEX_COUNT: numParticles,\n                            u_AveMovement: [0, 0, 0, 0]\n                        });\n                        execute = function () { return __awaiter(_this, void 0, void 0, function () {\n                            var i, stepInterval, finalParticleData;\n                            return __generator(this, function (_a) {\n                                switch (_a.label) {\n                                    case 0:\n                                        i = 0;\n                                        _a.label = 1;\n                                    case 1:\n                                        if (!(i < maxIteration)) return [3 /*break*/, 5];\n                                        // TODO: 似乎都来自 kernelGForce 是一个引用\n                                        // 当前坐标作为下一次迭代的 PreviousData\n                                        // if (i > 0) {\n                                        //   kernelAveMovement.setBinding({\n                                        //     u_PreviousData: kernelGForce\n                                        //   });\n                                        // }\n                                        // eslint-disable-next-line no-await-in-loop\n                                        return [4 /*yield*/, kernelGForce.execute()];\n                                    case 2:\n                                        // TODO: 似乎都来自 kernelGForce 是一个引用\n                                        // 当前坐标作为下一次迭代的 PreviousData\n                                        // if (i > 0) {\n                                        //   kernelAveMovement.setBinding({\n                                        //     u_PreviousData: kernelGForce\n                                        //   });\n                                        // }\n                                        // eslint-disable-next-line no-await-in-loop\n                                        _a.sent();\n                                        // midRes = await kernelGForce.getOutput();\n                                        // 每次迭代完成后\n                                        // 计算平均位移，用于提前终止迭代\n                                        kernelAveMovement.setBinding({\n                                            u_Data: kernelGForce\n                                        });\n                                        // eslint-disable-next-line no-await-in-loop\n                                        return [4 /*yield*/, kernelAveMovement.execute()];\n                                    case 3:\n                                        // eslint-disable-next-line no-await-in-loop\n                                        _a.sent();\n                                        stepInterval = Math.max(0.02, self.interval - i * 0.002);\n                                        kernelGForce.setBinding({\n                                            u_interval: stepInterval,\n                                            u_AveMovement: kernelAveMovement\n                                        });\n                                        _a.label = 4;\n                                    case 4:\n                                        i++;\n                                        return [3 /*break*/, 1];\n                                    case 5: return [4 /*yield*/, kernelGForce.getOutput()];\n                                    case 6:\n                                        finalParticleData = _a.sent();\n                                        // 所有迭代完成后\n                                        if (canvas) {\n                                            // 传递数据给主线程\n                                            ctx.postMessage({\n                                                type: constants_1.LAYOUT_MESSAGE.GPUEND,\n                                                vertexEdgeData: finalParticleData\n                                                // edgeIndexBufferData,\n                                            });\n                                        }\n                                        else {\n                                            nodes.forEach(function (node, i) {\n                                                var x = finalParticleData[4 * i];\n                                                var y = finalParticleData[4 * i + 1];\n                                                node.x = x;\n                                                node.y = y;\n                                            });\n                                        }\n                                        if (onLayoutEnd)\n                                            onLayoutEnd();\n                                        return [2 /*return*/];\n                                }\n                            });\n                        }); };\n                        return [4 /*yield*/, execute()];\n                    case 1:\n                        _b.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    GForceGPULayout.prototype.getType = function () {\n        return \"gForce-gpu\";\n    };\n    return GForceGPULayout;\n}(base_1.Base));\nexports.GForceGPULayout = GForceGPULayout;\n"},"sourceMaps":{"js":{"version":3,"file":"gForce.js","sourceRoot":"","sources":["../../../src/layout/gpu/gForce.ts"],"names":[],"mappings":"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","sourcesContent":["// @ts-nocheck\n/**\n * @fileOverview fruchterman layout\n * @author shiwu.wyy@antfin.com\n */\n\nimport {\n  IndexMap,\n  OutNode,\n  PointTuple,\n  Edge,\n  GForceGPULayoutOptions,\n  Degree\n} from \"../types\";\nimport { Base } from \"../base\";\nimport { isNumber } from \"../../util\";\n// @ts-ignore\nimport { World } from \"@antv/g-webgpu\";\nimport {\n  proccessToFunc,\n  buildTextureDataWithTwoEdgeAttr,\n  arrayToTextureData\n} from \"../../util/gpu\";\nimport { getDegree } from \"../../util/math\";\nimport { gForceBundle, aveMovementBundle } from \"./gForceShader\";\nimport { LAYOUT_MESSAGE } from \"../constants\";\n// @ts-ignore\n// import { Compiler } from '@antv/g-webgpu-compiler';\n// import { gForceCode, aveMovementCode } from './gForceShader';\n\ntype NodeMap = {\n  [key: string]: OutNode;\n};\n\n/**\n * graphin 中的 force 布局\n */\nexport class GForceGPULayout extends Base {\n  /** 布局中心 */\n  public center: PointTuple;\n\n  /** 停止迭代的最大迭代数 */\n  public maxIteration: number = 1000;\n\n  /** 弹簧引力系数 */\n  public edgeStrength: number | ((d?: any) => number) | undefined = 200;\n\n  /** 斥力系数 */\n  public nodeStrength: number | ((d?: any) => number) | undefined = 1000;\n\n  /** 库伦系数 */\n  public coulombDisScale: number = 0.005;\n\n  /** 阻尼系数 */\n  public damping: number = 0.9;\n\n  /** 最大速度 */\n  public maxSpeed: number = 1000;\n\n  /** 一次迭代的平均移动距离小于该值时停止迭代 */\n  public minMovement: number = 0.5;\n\n  /** 迭代中衰减 */\n  public interval: number = 0.02;\n\n  /** 斥力的一个系数 */\n  public factor: number = 1;\n\n  /** 每个节点质量的回调函数，若不指定，则默认使用度数作为节点质量 */\n  public getMass: ((d?: any) => number) | undefined;\n\n  /** 理想边长 */\n  public linkDistance: number | ((d?: any) => number) | undefined = 1;\n\n  /** 重力大小 */\n  public gravity: number = 10;\n\n  /** 每个节点中心力的 x、y、强度的回调函数，若不指定，则没有额外中心力 */\n  public getCenter: ((d?: any, degree?: number) => number[]) | undefined;\n\n  /** 是否启用web worker。前提是在web worker里执行布局，否则无效\t*/\n  public workerEnabled: boolean = false;\n\n  public nodes: OutNode[] = [];\n\n  public edges: Edge[] = [];\n\n  public width: number = 300;\n\n  public height: number = 300;\n\n  public nodeMap: NodeMap = {};\n\n  public nodeIdxMap: IndexMap = {};\n\n  public onLayoutEnd: () => void;\n\n  /** 存储节点度数 */\n  private degrees: Degree[];\n\n  constructor(options?: GForceGPULayoutOptions) {\n    super();\n    this.updateCfg(options);\n  }\n\n  public getDefaultCfg() {\n    return {\n      maxIteration: 2000,\n      gravity: 10,\n      clustering: false,\n      clusterGravity: 10\n    };\n  }\n\n  /**\n   * 执行布局\n   */\n  public async execute() {\n    const self = this;\n    const nodes = self.nodes;\n\n    if (!nodes || nodes.length === 0) {\n      if (self.onLayoutEnd) self.onLayoutEnd();\n      return;\n    }\n\n    if (!self.width && typeof window !== \"undefined\") {\n      self.width = window.innerWidth;\n    }\n    if (!self.height && typeof window !== \"undefined\") {\n      self.height = window.innerHeight;\n    }\n    if (!self.center) {\n      self.center = [self.width / 2, self.height / 2];\n    }\n    const center = self.center;\n\n    if (nodes.length === 1) {\n      nodes[0].x = center[0];\n      nodes[0].y = center[1];\n      if (self.onLayoutEnd) self.onLayoutEnd();\n      return;\n    }\n    const nodeMap: NodeMap = {};\n    const nodeIdxMap: IndexMap = {};\n    nodes.forEach((node, i) => {\n      if (!isNumber(node.x)) node.x = Math.random() * self.width;\n      if (!isNumber(node.y)) node.y = Math.random() * self.height;\n      nodeMap[node.id] = node;\n      nodeIdxMap[node.id] = i;\n    });\n    self.nodeMap = nodeMap;\n    self.nodeIdxMap = nodeIdxMap;\n\n    self.nodeStrength = proccessToFunc(self.nodeStrength, 1);\n    self.edgeStrength = proccessToFunc(self.edgeStrength, 1);\n\n    // layout\n    await self.run();\n  }\n\n  public executeWithWorker(canvas?: HTMLCanvasElement, ctx?: any) {\n    const self = this;\n    const nodes = self.nodes;\n    const center = self.center;\n\n    if (!nodes || nodes.length === 0) {\n      return;\n    }\n    if (nodes.length === 1) {\n      nodes[0].x = center[0];\n      nodes[0].y = center[1];\n      return;\n    }\n    const nodeMap: NodeMap = {};\n    const nodeIdxMap: IndexMap = {};\n    nodes.forEach((node, i) => {\n      if (!isNumber(node.x)) node.x = Math.random() * self.width;\n      if (!isNumber(node.y)) node.y = Math.random() * self.height;\n      nodeMap[node.id] = node;\n      nodeIdxMap[node.id] = i;\n    });\n    self.nodeMap = nodeMap;\n    self.nodeIdxMap = nodeIdxMap;\n\n    self.nodeStrength = proccessToFunc(self.nodeStrength, 1);\n    self.edgeStrength = proccessToFunc(self.edgeStrength, 1);\n\n    // layout\n    self.run(canvas, ctx);\n  }\n\n  public async run(canvas?: HTMLCanvasElement, ctx?: any) {\n    const self = this;\n    const nodes = self.nodes;\n    const edges = self.edges;\n    const maxIteration = self.maxIteration;\n    if (!self.width && typeof window !== \"undefined\") {\n      self.width = window.innerWidth;\n    }\n    if (!self.height && typeof window !== \"undefined\") {\n      self.height = window.innerHeight;\n    }\n\n    const numParticles = nodes.length;\n\n    self.linkDistance = proccessToFunc(self.linkDistance) as ((\n      d?: any\n    ) => number);\n    self.edgeStrength = proccessToFunc(self.edgeStrength) as ((\n      d?: any\n    ) => number);\n    const {\n      maxEdgePerVetex,\n      array: nodesEdgesArray\n    } = buildTextureDataWithTwoEdgeAttr(\n      nodes,\n      edges,\n      self.linkDistance,\n      self.edgeStrength\n    );\n\n    // init degree for mass\n    self.degrees = getDegree(nodes.length, self.nodeIdxMap, edges).map((degree) => degree.all);\n    const masses: number[] = [];\n    const nodeStrengths: number[] = [];\n    const centerXs: number[] = [];\n    const centerYs: number[] = [];\n    const centerGravities: number[] = [];\n    const fxs: number[] = [];\n    const fys: number[] = [];\n\n    if (!self.getMass) {\n      self.getMass = (d) => {\n        return self.degrees[self.nodeIdxMap[d.id]] || 1;\n      };\n    }\n    const gravity = self.gravity;\n    const center = self.center;\n    nodes.forEach((node, i) => {\n      masses.push((self.getMass as (d?: any) => number)(node));\n      nodeStrengths.push((self.nodeStrength as Function)(node));\n      if (!self.degrees[i]) self.degrees[i] = 0;\n      let nodeGravity = [center[0], center[1], gravity];\n      if (self.getCenter) {\n        const customCenter = self.getCenter(node, self.degrees[i]);\n        if (\n          customCenter &&\n          isNumber(customCenter[0]) &&\n          isNumber(customCenter[1]) &&\n          isNumber(customCenter[2])\n        ) {\n          nodeGravity = customCenter;\n        }\n      }\n      centerXs.push(nodeGravity[0]);\n      centerYs.push(nodeGravity[1]);\n      centerGravities.push(nodeGravity[2]);\n      if (isNumber(node.fx) && isNumber(node.fy)) {\n        fxs.push(node.fx || 0.001);\n        fys.push(node.fy || 0.001);\n      } else {\n        fxs.push(0);\n        fys.push(0);\n      }\n    });\n\n    // 每个节点的额外属性占两个数组各一格，nodeAttributeArray1 中是：mass, degree, nodeSterngth, 0\n    const nodeAttributeArray1 = arrayToTextureData([\n      masses,\n      self.degrees,\n      nodeStrengths,\n      fxs\n    ]);\n    // nodeAttributeArray2 中是：centerX, centerY, gravity, 0,\n    const nodeAttributeArray2 = arrayToTextureData([\n      centerXs,\n      centerYs,\n      centerGravities,\n      fys\n    ]);\n\n    const workerEnabled = self.workerEnabled;\n    let world;\n\n    if (workerEnabled) {\n      world = World.create({\n        canvas,\n        engineOptions: {\n          supportCompute: true\n        }\n      });\n    } else {\n      world = World.create({\n        engineOptions: {\n          supportCompute: true\n        }\n      });\n    }\n\n    // TODO: 最终的预编译代码放入到 gForceShader.ts 中直接引入，不再需要下面三行\n    // const compiler = new Compiler();\n    // const gForceBundle = compiler.compileBundle(gForceCode);\n    // console.log(gForceBundle.toString());\n\n    const onLayoutEnd = self.onLayoutEnd;\n\n    const initPreviousData = [];\n    nodesEdgesArray.forEach((value) => {\n      initPreviousData.push(value);\n    });\n    for (let i = 0; i < 4; i++) {\n      initPreviousData.push(0);\n    }\n\n    const kernelGForce = world\n      .createKernel(gForceBundle)\n      .setDispatch([numParticles, 1, 1])\n      .setBinding({\n        u_Data: nodesEdgesArray, // 节点边输入输出\n        u_damping: self.damping,\n        u_maxSpeed: self.maxSpeed,\n        u_minMovement: self.minMovement,\n        u_coulombDisScale: self.coulombDisScale,\n        u_factor: self.factor,\n        u_NodeAttributeArray1: nodeAttributeArray1,\n        u_NodeAttributeArray2: nodeAttributeArray2,\n        MAX_EDGE_PER_VERTEX: maxEdgePerVetex,\n        VERTEX_COUNT: numParticles,\n        u_AveMovement: initPreviousData,\n        u_interval: self.interval // 每次迭代更新，首次设置为 interval，在 onIterationCompleted 中更新\n      });\n\n    // const aveMovementBundle = compiler.compileBundle(aveMovementCode);\n    // console.log(aveMovementBundle.toString());\n\n    const kernelAveMovement = world\n      .createKernel(aveMovementBundle)\n      .setDispatch([1, 1, 1])\n      .setBinding({\n        u_Data: nodesEdgesArray,\n        VERTEX_COUNT: numParticles,\n        u_AveMovement: [0, 0, 0, 0]\n      });\n\n    // 执行迭代\n    // let midRes = nodesEdgesArray;\n    const execute = async () => {\n      for (let i = 0; i < maxIteration; i++) {\n        // TODO: 似乎都来自 kernelGForce 是一个引用\n        // 当前坐标作为下一次迭代的 PreviousData\n        // if (i > 0) {\n        //   kernelAveMovement.setBinding({\n        //     u_PreviousData: kernelGForce\n        //   });\n        // }\n\n        // eslint-disable-next-line no-await-in-loop\n        await kernelGForce.execute();\n\n        // midRes = await kernelGForce.getOutput();\n\n        // 每次迭代完成后\n        // 计算平均位移，用于提前终止迭代\n        kernelAveMovement.setBinding({\n          u_Data: kernelGForce\n        });\n\n        // eslint-disable-next-line no-await-in-loop\n        await kernelAveMovement.execute();\n\n        // 更新衰减函数\n        const stepInterval = Math.max(0.02, self.interval - i * 0.002);\n        kernelGForce.setBinding({\n          u_interval: stepInterval,\n          u_AveMovement: kernelAveMovement\n        });\n      }\n      const finalParticleData = await kernelGForce.getOutput();\n\n      // 所有迭代完成后\n      if (canvas) {\n        // 传递数据给主线程\n        ctx.postMessage({\n          type: LAYOUT_MESSAGE.GPUEND,\n          vertexEdgeData: finalParticleData\n          // edgeIndexBufferData,\n        });\n      } else {\n        nodes.forEach((node, i) => {\n          const x = finalParticleData[4 * i];\n          const y = finalParticleData[4 * i + 1];\n          node.x = x;\n          node.y = y;\n        });\n      }\n\n      if (onLayoutEnd) onLayoutEnd();\n    };\n\n    await execute();\n  }\n\n  public getType() {\n    return \"gForce-gpu\";\n  }\n}\n"]}},"error":null,"hash":"6f9f8f251ad7df86e9a376bf4e7d7438","cacheData":{"env":{}}}