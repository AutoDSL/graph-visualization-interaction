{"id":"node_modules/@antv/layout/lib/layout/mds.js","dependencies":[{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\mds.js.map","includedInParent":true,"mtime":1676178923726},{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\src\\layout\\mds.ts","includedInParent":true,"mtime":1676178924006},{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\package.json","includedInParent":true,"mtime":1676178924413},{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\package.json","includedInParent":true,"mtime":1676178923486},{"name":"ml-matrix","loc":{"line":23,"column":26,"index":962},"parent":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\mds.js","resolved":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\ml-matrix\\src\\index.js"},{"name":"../util","loc":{"line":24,"column":21,"index":997},"parent":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\mds.js","resolved":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\util\\index.js"},{"name":"./base","loc":{"line":25,"column":21,"index":1030},"parent":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\mds.js","resolved":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\base.js"}],"generated":{"js":"\"use strict\";\n/**\n * @fileOverview MDS layout\n * @author shiwu.wyy@antfin.com\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MDSLayout = void 0;\nvar ml_matrix_1 = require(\"ml-matrix\");\nvar util_1 = require(\"../util\");\nvar base_1 = require(\"./base\");\n/**\n * mds 布局\n */\nvar MDSLayout = /** @class */ (function (_super) {\n    __extends(MDSLayout, _super);\n    function MDSLayout(options) {\n        var _this = _super.call(this) || this;\n        /** 布局中心 */\n        _this.center = [0, 0];\n        /** 边长度 */\n        _this.linkDistance = 50;\n        _this.nodes = [];\n        _this.edges = [];\n        /** 迭代结束的回调函数 */\n        _this.onLayoutEnd = function () { };\n        _this.updateCfg(options);\n        return _this;\n    }\n    MDSLayout.prototype.getDefaultCfg = function () {\n        return {\n            center: [0, 0],\n            linkDistance: 50\n        };\n    };\n    /**\n     * 执行布局\n     */\n    MDSLayout.prototype.execute = function () {\n        var self = this;\n        var nodes = self.nodes, _a = self.edges, edges = _a === void 0 ? [] : _a;\n        var center = self.center;\n        if (!nodes || nodes.length === 0) {\n            if (self.onLayoutEnd)\n                self.onLayoutEnd();\n            return;\n        }\n        if (nodes.length === 1) {\n            nodes[0].x = center[0];\n            nodes[0].y = center[1];\n            if (self.onLayoutEnd)\n                self.onLayoutEnd();\n            return;\n        }\n        var linkDistance = self.linkDistance;\n        // the graph-theoretic distance (shortest path distance) matrix\n        var adjMatrix = (0, util_1.getAdjMatrix)({ nodes: nodes, edges: edges }, false);\n        var distances = (0, util_1.floydWarshall)(adjMatrix);\n        self.handleInfinity(distances);\n        // scale the ideal edge length acoording to linkDistance\n        var scaledD = (0, util_1.scaleMatrix)(distances, linkDistance);\n        self.scaledDistances = scaledD;\n        // get positions by MDS\n        var positions = self.runMDS();\n        self.positions = positions;\n        positions.forEach(function (p, i) {\n            nodes[i].x = p[0] + center[0];\n            nodes[i].y = p[1] + center[1];\n        });\n        if (self.onLayoutEnd)\n            self.onLayoutEnd();\n        return {\n            nodes: nodes,\n            edges: edges\n        };\n    };\n    /**\n     * mds 算法\n     * @return {array} positions 计算后的节点位置数组\n     */\n    MDSLayout.prototype.runMDS = function () {\n        var self = this;\n        var dimension = 2;\n        var distances = self.scaledDistances;\n        // square distances\n        var M = ml_matrix_1.Matrix.mul(ml_matrix_1.Matrix.pow(distances, 2), -0.5);\n        // double centre the rows/columns\n        var rowMeans = M.mean(\"row\");\n        var colMeans = M.mean(\"column\");\n        var totalMean = M.mean();\n        M.add(totalMean)\n            .subRowVector(rowMeans)\n            .subColumnVector(colMeans);\n        // take the SVD of the double centred matrix, and return the\n        // points from it\n        var ret = new ml_matrix_1.SingularValueDecomposition(M);\n        var eigenValues = ml_matrix_1.Matrix.sqrt(ret.diagonalMatrix).diagonal();\n        return ret.leftSingularVectors.toJSON().map(function (row) {\n            return ml_matrix_1.Matrix.mul([row], [eigenValues])\n                .toJSON()[0]\n                .splice(0, dimension);\n        });\n    };\n    MDSLayout.prototype.handleInfinity = function (distances) {\n        var maxDistance = -999999;\n        distances.forEach(function (row) {\n            row.forEach(function (value) {\n                if (value === Infinity) {\n                    return;\n                }\n                if (maxDistance < value) {\n                    maxDistance = value;\n                }\n            });\n        });\n        distances.forEach(function (row, i) {\n            row.forEach(function (value, j) {\n                if (value === Infinity) {\n                    distances[i][j] = maxDistance;\n                }\n            });\n        });\n    };\n    MDSLayout.prototype.getType = function () {\n        return \"mds\";\n    };\n    return MDSLayout;\n}(base_1.Base));\nexports.MDSLayout = MDSLayout;\n"},"sourceMaps":{"js":{"version":3,"file":"mds.js","sourceRoot":"","sources":["../../src/layout/mds.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @fileOverview MDS layout\n * @author shiwu.wyy@antfin.com\n */\n\nimport { Matrix as MLMatrix, SingularValueDecomposition } from \"ml-matrix\";\nimport { PointTuple, OutNode, Edge, Matrix, MDSLayoutOptions } from \"./types\";\nimport { floydWarshall, getAdjMatrix, scaleMatrix } from \"../util\";\nimport { Base } from \"./base\";\n\n/**\n * mds 布局\n */\nexport class MDSLayout extends Base {\n  /** 布局中心 */\n  public center: PointTuple = [0, 0];\n\n  /** 边长度 */\n  public linkDistance: number = 50;\n\n  private scaledDistances: Matrix[];\n\n  public nodes: OutNode[] = [];\n\n  public edges: Edge[] = [];\n\n  /** 迭代结束的回调函数 */\n  public onLayoutEnd: () => void = () => {};\n\n  constructor(options?: MDSLayoutOptions) {\n    super();\n    this.updateCfg(options);\n  }\n\n  public getDefaultCfg() {\n    return {\n      center: [0, 0],\n      linkDistance: 50\n    };\n  }\n\n  /**\n   * 执行布局\n   */\n  public execute() {\n    const self = this;\n    const { nodes, edges = [] } = self;\n    const center = self.center;\n    if (!nodes || nodes.length === 0) {\n      if (self.onLayoutEnd) self.onLayoutEnd();\n      return;\n    }\n    if (nodes.length === 1) {\n      nodes[0].x = center[0];\n      nodes[0].y = center[1];\n      if (self.onLayoutEnd) self.onLayoutEnd();\n      return;\n    }\n    const linkDistance = self.linkDistance;\n    // the graph-theoretic distance (shortest path distance) matrix\n    const adjMatrix = getAdjMatrix({ nodes, edges }, false);\n    const distances = floydWarshall(adjMatrix);\n    self.handleInfinity(distances);\n\n    // scale the ideal edge length acoording to linkDistance\n    const scaledD = scaleMatrix(distances, linkDistance);\n    self.scaledDistances = scaledD;\n\n    // get positions by MDS\n    const positions = self.runMDS();\n    self.positions = positions;\n    positions.forEach((p: number[], i: number) => {\n      nodes[i].x = p[0] + center[0];\n      nodes[i].y = p[1] + center[1];\n    });\n\n    if (self.onLayoutEnd) self.onLayoutEnd();\n\n    return {\n      nodes,\n      edges\n    };\n  }\n\n  /**\n   * mds 算法\n   * @return {array} positions 计算后的节点位置数组\n   */\n  public runMDS(): PointTuple[] {\n    const self = this;\n    const dimension = 2;\n    const distances = self.scaledDistances;\n\n    // square distances\n    const M = MLMatrix.mul(MLMatrix.pow(distances, 2), -0.5);\n\n    // double centre the rows/columns\n    const rowMeans = M.mean(\"row\");\n    const colMeans = M.mean(\"column\");\n    const totalMean = M.mean();\n    M.add(totalMean)\n      .subRowVector(rowMeans)\n      .subColumnVector(colMeans);\n\n    // take the SVD of the double centred matrix, and return the\n    // points from it\n    const ret = new SingularValueDecomposition(M);\n    const eigenValues = MLMatrix.sqrt(ret.diagonalMatrix).diagonal();\n    return ret.leftSingularVectors.toJSON().map((row: number[]) => {\n      return MLMatrix.mul([row], [eigenValues])\n        .toJSON()[0]\n        .splice(0, dimension) as PointTuple;\n    });\n  }\n\n  public handleInfinity(distances: Matrix[]) {\n    let maxDistance = -999999;\n    distances.forEach((row) => {\n      row.forEach((value) => {\n        if (value === Infinity) {\n          return;\n        }\n        if (maxDistance < value) {\n          maxDistance = value;\n        }\n      });\n    });\n    distances.forEach((row, i) => {\n      row.forEach((value, j) => {\n        if (value === Infinity) {\n          distances[i][j] = maxDistance;\n        }\n      });\n    });\n  }\n\n  public getType() {\n    return \"mds\";\n  }\n}\n"]}},"error":null,"hash":"7c557d2b2cd1cd3ecbbed7f66f89fdf5","cacheData":{"env":{}}}