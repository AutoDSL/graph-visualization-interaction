{"id":"node_modules/@antv/layout/lib/layout/dagre/src/rank/util.js","dependencies":[{"name":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\rank\\util.js.map","includedInParent":true,"mtime":499162500000},{"name":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\src\\layout\\dagre\\src\\rank\\util.ts","includedInParent":true,"mtime":499162500000},{"name":"D:\\myData\\前端\\doing\\AutoPL\\package.json","includedInParent":true,"mtime":1674182060254},{"name":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\package.json","includedInParent":true,"mtime":1674179681168}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.slack = exports.longestPathWithLayer = exports.longestPath = void 0;\n/*\n * Initializes ranks for the input graph using the longest path algorithm. This\n * algorithm scales well and is fast in practice, it yields rather poor\n * solutions. Nodes are pushed to the lowest layer possible, leaving the bottom\n * ranks wide and leaving edges longer than necessary. However, due to its\n * speed, this algorithm is good for getting an initial ranking that can be fed\n * into other algorithms.\n *\n * This algorithm does not normalize layers because it will be used by other\n * algorithms in most cases. If using this algorithm directly, be sure to\n * run normalize at the end.\n *\n * Pre-conditions:\n *\n *    1. Input graph is a DAG.\n *    2. Input graph node labels can be assigned properties.\n *\n * Post-conditions:\n *\n *    1. Each node will be assign an (unnormalized) \"rank\" property.\n */\nvar longestPath = function (g) {\n    var _a;\n    var visited = {};\n    var dfs = function (v) {\n        var _a;\n        var label = g.node(v);\n        if (!label)\n            return 0;\n        if (visited[v]) {\n            return label.rank;\n        }\n        visited[v] = true;\n        var rank;\n        (_a = g.outEdges(v)) === null || _a === void 0 ? void 0 : _a.forEach(function (edgeObj) {\n            var wRank = dfs(edgeObj.w);\n            var minLen = g.edge(edgeObj).minlen;\n            var r = wRank - minLen;\n            if (r) {\n                if (rank === undefined || r < rank) {\n                    rank = r;\n                }\n            }\n        });\n        if (!rank) {\n            rank = 0;\n        }\n        label.rank = rank;\n        return rank;\n    };\n    (_a = g.sources()) === null || _a === void 0 ? void 0 : _a.forEach(function (source) { return dfs(source); });\n};\nexports.longestPath = longestPath;\nvar longestPathWithLayer = function (g) {\n    var _a;\n    // 用longest path，找出最深的点\n    var visited = {};\n    var minRank;\n    var dfs = function (v) {\n        var _a;\n        var label = g.node(v);\n        if (!label)\n            return 0;\n        if (visited[v]) {\n            return label.rank;\n        }\n        visited[v] = true;\n        var rank;\n        (_a = g.outEdges(v)) === null || _a === void 0 ? void 0 : _a.forEach(function (edgeObj) {\n            var wRank = dfs(edgeObj.w);\n            var minLen = g.edge(edgeObj).minlen;\n            var r = wRank - minLen;\n            if (r) {\n                if (rank === undefined || r < rank) {\n                    rank = r;\n                }\n            }\n        });\n        if (!rank) {\n            rank = 0;\n        }\n        if (minRank === undefined || rank < minRank) {\n            minRank = rank;\n        }\n        label.rank = rank;\n        return rank;\n    };\n    (_a = g.sources()) === null || _a === void 0 ? void 0 : _a.forEach(function (source) {\n        if (g.node(source))\n            dfs(source);\n    });\n    if (minRank === undefined) {\n        minRank = 0;\n    }\n    // minRank += 1; // NOTE: 最小的层级是dummy root，+1\n    // forward一遍，赋值层级\n    var forwardVisited = {};\n    var dfsForward = function (v, nextRank) {\n        var _a;\n        var label = g.node(v);\n        var currRank = (!isNaN(label.layer) ? label.layer : nextRank);\n        // 没有指定，取最大值\n        if (label.rank === undefined || label.rank < currRank) {\n            label.rank = currRank;\n        }\n        if (forwardVisited[v])\n            return;\n        forwardVisited[v] = true;\n        // DFS遍历子节点\n        (_a = g.outEdges(v)) === null || _a === void 0 ? void 0 : _a.map(function (e) {\n            dfsForward(e.w, currRank + g.edge(e).minlen);\n        });\n    };\n    // 指定层级的，更新下游\n    g.nodes().forEach(function (n) {\n        var label = g.node(n);\n        if (!label)\n            return;\n        if (!isNaN(label.layer)) {\n            dfsForward(n, label.layer); // 默认的dummy root所在层的rank是-1\n        }\n        else {\n            label.rank -= minRank;\n        }\n    });\n};\nexports.longestPathWithLayer = longestPathWithLayer;\n/*\n * Returns the amount of slack for the given edge. The slack is defined as the\n * difference between the length of the edge and its minimum length.\n */\nvar slack = function (g, e) {\n    return (g.node(e.w).rank -\n        g.node(e.v).rank -\n        g.edge(e).minlen);\n};\nexports.slack = slack;\nexports.default = {\n    longestPath: longestPath,\n    longestPathWithLayer: longestPathWithLayer,\n    slack: slack,\n};\n"},"sourceMaps":{"js":{"version":3,"file":"util.js","sourceRoot":"","sources":["../../../../../src/layout/dagre/src/rank/util.ts"],"names":[],"mappings":";;;AAEA;;;;;;;;;;;;;;;;;;;;GAoBG;AACH,IAAM,WAAW,GAAG,UAAC,CAAQ;;IAC3B,IAAM,OAAO,GAA4B,EAAE,CAAC;IAE5C,IAAM,GAAG,GAAG,UAAC,CAAS;;QACpB,IAAM,KAAK,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,CAAE,CAAC;QACzB,IAAI,CAAC,KAAK;YAAE,OAAO,CAAC,CAAC;QACrB,IAAI,OAAO,CAAC,CAAC,CAAC,EAAE;YACd,OAAO,KAAK,CAAC,IAAK,CAAC;SACpB;QACD,OAAO,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC;QAElB,IAAI,IAAY,CAAC;QAEjB,MAAA,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,0CAAE,OAAO,CACpB,UAAC,OAAO;YACN,IAAM,KAAK,GAAG,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;YAC7B,IAAM,MAAM,GAAG,CAAC,CAAC,IAAI,CAAC,OAAO,CAAE,CAAC,MAAO,CAAC;YACxC,IAAM,CAAC,GAAG,KAAK,GAAG,MAAM,CAAC;YACzB,IAAI,CAAC,EAAE;gBACL,IAAI,IAAI,KAAK,SAAS,IAAI,CAAC,GAAG,IAAI,EAAE;oBAClC,IAAI,GAAG,CAAC,CAAC;iBACV;aACF;QACH,CAAC,CACF,CAAC;QAGF,IAAI,CAAC,IAAK,EAAE;YACV,IAAI,GAAG,CAAC,CAAC;SACV;QAED,KAAK,CAAC,IAAI,GAAG,IAAI,CAAC;QAClB,OAAO,IAAI,CAAC;IACd,CAAC,CAAC;IAEF,MAAA,CAAC,CAAC,OAAO,EAAE,0CAAE,OAAO,CAAC,UAAC,MAAM,IAAK,OAAA,GAAG,CAAC,MAAM,CAAC,EAAX,CAAW,CAAC,CAAC;AAChD,CAAC,CAAC;AAoGO,kCAAW;AAlGpB,IAAM,oBAAoB,GAAG,UAAC,CAAQ;;IACpC,uBAAuB;IACvB,IAAM,OAAO,GAA4B,EAAE,CAAC;IAC5C,IAAI,OAAe,CAAC;IAEpB,IAAM,GAAG,GAAG,UAAC,CAAS;;QACpB,IAAM,KAAK,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,CAAE,CAAC;QACzB,IAAI,CAAC,KAAK;YAAE,OAAO,CAAC,CAAC;QACrB,IAAI,OAAO,CAAC,CAAC,CAAC,EAAE;YACd,OAAO,KAAK,CAAC,IAAK,CAAC;SACpB;QACD,OAAO,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC;QAElB,IAAI,IAAY,CAAC;QAEjB,MAAA,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,0CAAE,OAAO,CACpB,UAAC,OAAO;YACN,IAAM,KAAK,GAAG,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;YAC7B,IAAM,MAAM,GAAG,CAAC,CAAC,IAAI,CAAC,OAAO,CAAE,CAAC,MAAO,CAAC;YACxC,IAAM,CAAC,GAAG,KAAK,GAAG,MAAM,CAAC;YACzB,IAAI,CAAC,EAAE;gBACL,IAAI,IAAI,KAAK,SAAS,IAAI,CAAC,GAAG,IAAI,EAAE;oBAClC,IAAI,GAAG,CAAC,CAAC;iBACV;aACF;QACH,CAAC,CACF,CAAC;QAGF,IAAI,CAAC,IAAK,EAAE;YACV,IAAI,GAAG,CAAC,CAAC;SACV;QAED,IAAI,OAAO,KAAK,SAAS,IAAI,IAAI,GAAG,OAAO,EAAE;YAC3C,OAAO,GAAG,IAAI,CAAC;SAChB;QAED,KAAK,CAAC,IAAI,GAAG,IAAI,CAAC;QAClB,OAAO,IAAI,CAAC;IACd,CAAC,CAAC;IAEF,MAAA,CAAC,CAAC,OAAO,EAAE,0CAAE,OAAO,CAAC,UAAC,MAAM;QAC1B,IAAI,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC;YAAE,GAAG,CAAC,MAAM,CAAC,CAAA;IACjC,CAAC,CAAC,CAAC;IAEH,IAAI,OAAQ,KAAK,SAAS,EAAE;QAC1B,OAAO,GAAG,CAAC,CAAC;KACb;IAED,6CAA6C;IAE7C,iBAAiB;IACjB,IAAM,cAAc,GAA4B,EAAE,CAAC;IACnD,IAAM,UAAU,GAAG,UAAC,CAAS,EAAE,QAAgB;;QAC7C,IAAM,KAAK,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,CAAE,CAAC;QAEzB,IAAM,QAAQ,GAAG,CACf,CAAC,KAAK,CAAC,KAAK,CAAC,KAAe,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,QAAQ,CAC7C,CAAC;QAEZ,YAAY;QACZ,IAAI,KAAK,CAAC,IAAI,KAAK,SAAS,IAAI,KAAK,CAAC,IAAI,GAAG,QAAQ,EAAE;YACrD,KAAK,CAAC,IAAI,GAAG,QAAQ,CAAC;SACvB;QAED,IAAI,cAAc,CAAC,CAAC,CAAC;YAAE,OAAO;QAC9B,cAAc,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC;QAEzB,WAAW;QACX,MAAA,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,0CAAE,GAAG,CAAC,UAAC,CAAC;YACnB,UAAU,CAAC,CAAC,CAAC,CAAC,EAAE,QAAQ,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,CAAE,CAAC,MAAO,CAAC,CAAC;QACjD,CAAC,CAAC,CAAC;IACL,CAAC,CAAC;IAEF,aAAa;IACb,CAAC,CAAC,KAAK,EAAE,CAAC,OAAO,CAAC,UAAC,CAAC;QAClB,IAAM,KAAK,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,CAAE,CAAC;QACzB,IAAG,CAAC,KAAK;YAAE,OAAO;QAClB,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,KAAe,CAAC,EAAE;YACjC,UAAU,CAAC,CAAC,EAAE,KAAK,CAAC,KAAe,CAAC,CAAC,CAAC,2BAA2B;SAClE;aAAM;YACJ,KAAK,CAAC,IAAe,IAAI,OAAO,CAAC;SACnC;IACH,CAAC,CAAC,CAAC;AACL,CAAC,CAAC;AAcoB,oDAAoB;AAZ1C;;;GAGG;AACH,IAAM,KAAK,GAAG,UAAC,CAAQ,EAAE,CAAO;IAC9B,OAAO,CACJ,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAE,CAAC,IAAe;QAC5B,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAE,CAAC,IAAe;QAC5B,CAAC,CAAC,IAAI,CAAC,CAAC,CAAE,CAAC,MAAiB,CAC9B,CAAC;AACJ,CAAC,CAAC;AAE0C,sBAAK;AAEjD,kBAAe;IACb,WAAW,aAAA;IACX,oBAAoB,sBAAA;IACpB,KAAK,OAAA;CACN,CAAC","sourcesContent":["import { Edge, Graph } from \"../../graph\";\n\n/*\n * Initializes ranks for the input graph using the longest path algorithm. This\n * algorithm scales well and is fast in practice, it yields rather poor\n * solutions. Nodes are pushed to the lowest layer possible, leaving the bottom\n * ranks wide and leaving edges longer than necessary. However, due to its\n * speed, this algorithm is good for getting an initial ranking that can be fed\n * into other algorithms.\n *\n * This algorithm does not normalize layers because it will be used by other\n * algorithms in most cases. If using this algorithm directly, be sure to\n * run normalize at the end.\n *\n * Pre-conditions:\n *\n *    1. Input graph is a DAG.\n *    2. Input graph node labels can be assigned properties.\n *\n * Post-conditions:\n *\n *    1. Each node will be assign an (unnormalized) \"rank\" property.\n */\nconst longestPath = (g: Graph) => {\n  const visited: Record<string, boolean> = {};\n\n  const dfs = (v: string) => {\n    const label = g.node(v)!;\n    if (!label) return 0;\n    if (visited[v]) {\n      return label.rank!;\n    }\n    visited[v] = true;\n\n    let rank: number;\n\n    g.outEdges(v)?.forEach(\n      (edgeObj) => {\n        const wRank = dfs(edgeObj.w);\n        const minLen = g.edge(edgeObj)!.minlen!;\n        const r = wRank - minLen;\n        if (r) {\n          if (rank === undefined || r < rank) {\n            rank = r;\n          }\n        }\n      }\n    );\n\n\n    if (!rank!) {\n      rank = 0;\n    }\n\n    label.rank = rank;\n    return rank;\n  };\n\n  g.sources()?.forEach((source) => dfs(source));\n};\n\nconst longestPathWithLayer = (g: Graph) => {\n  // 用longest path，找出最深的点\n  const visited: Record<string, boolean> = {};\n  let minRank: number;\n\n  const dfs = (v: string) => {\n    const label = g.node(v)!;\n    if (!label) return 0;\n    if (visited[v]) {\n      return label.rank!;\n    }\n    visited[v] = true;\n\n    let rank: number;\n\n    g.outEdges(v)?.forEach(\n      (edgeObj) => {\n        const wRank = dfs(edgeObj.w);\n        const minLen = g.edge(edgeObj)!.minlen!;\n        const r = wRank - minLen;\n        if (r) {\n          if (rank === undefined || r < rank) {\n            rank = r;\n          }\n        }\n      }\n    );\n\n\n    if (!rank!) {\n      rank = 0;\n    }\n\n    if (minRank === undefined || rank < minRank) {\n      minRank = rank;\n    }\n\n    label.rank = rank;\n    return rank;\n  };\n\n  g.sources()?.forEach((source) => {\n    if (g.node(source)) dfs(source)\n  });\n\n  if (minRank! === undefined) {\n    minRank = 0;\n  }\n\n  // minRank += 1; // NOTE: 最小的层级是dummy root，+1\n\n  // forward一遍，赋值层级\n  const forwardVisited: Record<string, boolean> = {};\n  const dfsForward = (v: string, nextRank: number) => {\n    const label = g.node(v)!;\n\n    const currRank = (\n      !isNaN(label.layer as number) ? label.layer : nextRank\n    ) as number;\n\n    // 没有指定，取最大值\n    if (label.rank === undefined || label.rank < currRank) {\n      label.rank = currRank;\n    }\n\n    if (forwardVisited[v]) return;\n    forwardVisited[v] = true;\n\n    // DFS遍历子节点\n    g.outEdges(v)?.map((e) => {\n      dfsForward(e.w, currRank + g.edge(e)!.minlen!);\n    });\n  };\n\n  // 指定层级的，更新下游\n  g.nodes().forEach((n) => {\n    const label = g.node(n)!;\n    if(!label) return;\n    if (!isNaN(label.layer as number)) {\n      dfsForward(n, label.layer as number); // 默认的dummy root所在层的rank是-1\n    } else {\n      (label.rank as number) -= minRank;\n    }\n  });\n};\n\n/*\n * Returns the amount of slack for the given edge. The slack is defined as the\n * difference between the length of the edge and its minimum length.\n */\nconst slack = (g: Graph, e: Edge) => {\n  return (\n    (g.node(e.w)!.rank as number) -\n    (g.node(e.v)!.rank as number) -\n    (g.edge(e)!.minlen as number)\n  );\n};\n\nexport { longestPath, longestPathWithLayer, slack };\n\nexport default {\n  longestPath,\n  longestPathWithLayer,\n  slack,\n};\n"]}},"error":null,"hash":"1fa1a455115fa3e04d69b31008bef0b7","cacheData":{"env":{}}}