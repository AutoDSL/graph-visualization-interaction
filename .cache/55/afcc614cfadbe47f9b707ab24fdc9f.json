{"id":"node_modules/@antv/layout/lib/layout/dagre/src/position/bk.js","dependencies":[{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\position\\bk.js.map","includedInParent":true,"mtime":1676178923534},{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\src\\layout\\dagre\\src\\position\\bk.ts","includedInParent":true,"mtime":1676178923810},{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\package.json","includedInParent":true,"mtime":1676178924413},{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\package.json","includedInParent":true,"mtime":1676178923486},{"name":"@antv/graphlib","loc":{"line":23,"column":25,"index":1363},"parent":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\position\\bk.js","resolved":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\graphlib\\es\\index.js"},{"name":"../util","loc":{"line":24,"column":21,"index":1403},"parent":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\position\\bk.js","resolved":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\util.js"}],"generated":{"js":"\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.width = exports.sep = exports.positionX = exports.balance = exports.alignCoordinates = exports.findSmallestWidthAlignment = exports.buildBlockGraph = exports.horizontalCompaction = exports.verticalAlignment = exports.hasConflict = exports.addConflict = exports.findOtherInnerSegmentNode = exports.findType2Conflicts = exports.findType1Conflicts = void 0;\n/*\n * This module provides coordinate assignment based on Brandes and Köpf, \"Fast\n * and Simple Horizontal Coordinate Assignment.\"\n */\nvar graphlib_1 = require(\"@antv/graphlib\");\nvar util_1 = require(\"../util\");\nvar BlockGraph = /** @class */ (function (_super) {\n    __extends(BlockGraph, _super);\n    function BlockGraph() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return BlockGraph;\n}(graphlib_1.Graph));\nvar findType1Conflicts = function (g, layering) {\n    var conflicts = {};\n    var visitLayer = function (prevLayer, layer) {\n        // last visited node in the previous layer that is incident on an inner\n        // segment.\n        var k0 = 0;\n        // Tracks the last node in this layer scanned for crossings with a type-1\n        // segment.\n        var scanPos = 0;\n        var prevLayerLength = prevLayer.length;\n        var lastNode = layer === null || layer === void 0 ? void 0 : layer[(layer === null || layer === void 0 ? void 0 : layer.length) - 1];\n        layer === null || layer === void 0 ? void 0 : layer.forEach(function (v, i) {\n            var _a;\n            var w = (0, exports.findOtherInnerSegmentNode)(g, v);\n            var k1 = w ? g.node(w).order : prevLayerLength;\n            if (w || v === lastNode) {\n                (_a = layer.slice(scanPos, i + 1)) === null || _a === void 0 ? void 0 : _a.forEach(function (scanNode) {\n                    var _a;\n                    (_a = g.predecessors(scanNode)) === null || _a === void 0 ? void 0 : _a.forEach(function (u) {\n                        var _a;\n                        var uLabel = g.node(u);\n                        var uPos = uLabel.order;\n                        if ((uPos < k0 || k1 < uPos) &&\n                            !(uLabel.dummy && ((_a = g.node(scanNode)) === null || _a === void 0 ? void 0 : _a.dummy))) {\n                            (0, exports.addConflict)(conflicts, u, scanNode);\n                        }\n                    });\n                });\n                scanPos = i + 1;\n                k0 = k1;\n            }\n        });\n        return layer;\n    };\n    if (layering === null || layering === void 0 ? void 0 : layering.length) {\n        layering.reduce(visitLayer);\n    }\n    return conflicts;\n};\nexports.findType1Conflicts = findType1Conflicts;\nvar findType2Conflicts = function (g, layering) {\n    var conflicts = {};\n    var scan = function (south, southPos, southEnd, prevNorthBorder, nextNorthBorder) {\n        var v;\n        var range = [];\n        for (var i = southPos; i < southEnd; i++) {\n            range.push(i);\n        }\n        range.forEach(function (i) {\n            var _a, _b;\n            v = south[i];\n            if ((_a = g.node(v)) === null || _a === void 0 ? void 0 : _a.dummy) {\n                (_b = g.predecessors(v)) === null || _b === void 0 ? void 0 : _b.forEach(function (u) {\n                    var uNode = g.node(u);\n                    if (uNode.dummy &&\n                        (uNode.order < prevNorthBorder ||\n                            uNode.order > nextNorthBorder)) {\n                        (0, exports.addConflict)(conflicts, u, v);\n                    }\n                });\n            }\n        });\n    };\n    var visitLayer = function (north, south) {\n        var prevNorthPos = -1;\n        var nextNorthPos;\n        var southPos = 0;\n        south === null || south === void 0 ? void 0 : south.forEach(function (v, southLookahead) {\n            var _a;\n            if (((_a = g.node(v)) === null || _a === void 0 ? void 0 : _a.dummy) === \"border\") {\n                var predecessors = g.predecessors(v) || [];\n                if (predecessors.length) {\n                    nextNorthPos = g.node(predecessors[0]).order;\n                    scan(south, southPos, southLookahead, prevNorthPos, nextNorthPos);\n                    southPos = southLookahead;\n                    prevNorthPos = nextNorthPos;\n                }\n            }\n            scan(south, southPos, south.length, nextNorthPos, north.length);\n        });\n        return south;\n    };\n    if (layering === null || layering === void 0 ? void 0 : layering.length) {\n        layering.reduce(visitLayer);\n    }\n    return conflicts;\n};\nexports.findType2Conflicts = findType2Conflicts;\nvar findOtherInnerSegmentNode = function (g, v) {\n    var _a, _b;\n    if ((_a = g.node(v)) === null || _a === void 0 ? void 0 : _a.dummy) {\n        return (_b = g.predecessors(v)) === null || _b === void 0 ? void 0 : _b.find(function (u) { return g.node(u).dummy; });\n    }\n};\nexports.findOtherInnerSegmentNode = findOtherInnerSegmentNode;\nvar addConflict = function (conflicts, v, w) {\n    var vv = v;\n    var ww = w;\n    if (vv > ww) {\n        var tmp = vv;\n        vv = ww;\n        ww = tmp;\n    }\n    var conflictsV = conflicts[vv];\n    if (!conflictsV) {\n        conflicts[vv] = conflictsV = {};\n    }\n    conflictsV[ww] = true;\n};\nexports.addConflict = addConflict;\nvar hasConflict = function (conflicts, v, w) {\n    var vv = v;\n    var ww = w;\n    if (vv > ww) {\n        var tmp = v;\n        vv = ww;\n        ww = tmp;\n    }\n    return !!conflicts[vv];\n};\nexports.hasConflict = hasConflict;\n/*\n * Try to align nodes into vertical \"blocks\" where possible. This algorithm\n * attempts to align a node with one of its median neighbors. If the edge\n * connecting a neighbor is a type-1 conflict then we ignore that possibility.\n * If a previous node has already formed a block with a node after the node\n * we're trying to form a block with, we also ignore that possibility - our\n * blocks would be split in that scenario.\n */\nvar verticalAlignment = function (g, layering, conflicts, neighborFn) {\n    var root = {};\n    var align = {};\n    var pos = {};\n    // We cache the position here based on the layering because the graph and\n    // layering may be out of sync. The layering matrix is manipulated to\n    // generate different extreme alignments.\n    layering === null || layering === void 0 ? void 0 : layering.forEach(function (layer) {\n        layer === null || layer === void 0 ? void 0 : layer.forEach(function (v, order) {\n            root[v] = v;\n            align[v] = v;\n            pos[v] = order;\n        });\n    });\n    layering === null || layering === void 0 ? void 0 : layering.forEach(function (layer) {\n        var prevIdx = -1;\n        layer === null || layer === void 0 ? void 0 : layer.forEach(function (v) {\n            var ws = neighborFn(v);\n            if (ws.length) {\n                ws = ws.sort(function (a, b) { return pos[a] - pos[b]; });\n                var mp = (ws.length - 1) / 2;\n                for (var i = Math.floor(mp), il = Math.ceil(mp); i <= il; ++i) {\n                    var w = ws[i];\n                    if (align[v] === v &&\n                        prevIdx < pos[w] &&\n                        !(0, exports.hasConflict)(conflicts, v, w)) {\n                        align[w] = v;\n                        align[v] = root[v] = root[w];\n                        prevIdx = pos[w];\n                    }\n                }\n            }\n        });\n    });\n    return { root: root, align: align };\n};\nexports.verticalAlignment = verticalAlignment;\nvar horizontalCompaction = function (g, layering, root, align, reverseSep) {\n    var _a;\n    // This portion of the algorithm differs from BK due to a number of problems.\n    // Instead of their algorithm we construct a new block graph and do two\n    // sweeps. The first sweep places blocks with the smallest possible\n    // coordinates. The second sweep removes unused space by moving blocks to the\n    // greatest coordinates without violating separation.\n    var xs = {};\n    var blockG = (0, exports.buildBlockGraph)(g, layering, root, reverseSep);\n    var borderType = reverseSep ? \"borderLeft\" : \"borderRight\";\n    var iterate = function (setXsFunc, nextNodesFunc) {\n        var stack = blockG.nodes();\n        var elem = stack.pop();\n        var visited = {};\n        while (elem) {\n            if (visited[elem]) {\n                setXsFunc(elem);\n            }\n            else {\n                visited[elem] = true;\n                stack.push(elem);\n                stack = stack.concat(nextNodesFunc(elem));\n            }\n            elem = stack.pop();\n        }\n    };\n    // First pass, assign smallest coordinates\n    var pass1 = function (elem) {\n        xs[elem] = (blockG.inEdges(elem) || []).reduce(function (acc, e) {\n            return Math.max(acc, (xs[e.v] || 0) + blockG.edge(e));\n        }, 0);\n    };\n    // Second pass, assign greatest coordinates\n    var pass2 = function (elem) {\n        var min = (blockG.outEdges(elem) || []).reduce(function (acc, e) {\n            return Math.min(acc, (xs[e.w] || 0) - blockG.edge(e));\n        }, Number.POSITIVE_INFINITY);\n        var node = g.node(elem);\n        if (min !== Number.POSITIVE_INFINITY && node.borderType !== borderType) {\n            xs[elem] = Math.max(xs[elem], min);\n        }\n    };\n    iterate(pass1, blockG.predecessors.bind(blockG));\n    iterate(pass2, blockG.successors.bind(blockG));\n    // Assign x coordinates to all nodes\n    (_a = Object.values(align)) === null || _a === void 0 ? void 0 : _a.forEach(function (v) {\n        xs[v] = xs[root[v]];\n    });\n    return xs;\n};\nexports.horizontalCompaction = horizontalCompaction;\nvar buildBlockGraph = function (g, layering, root, reverseSep) {\n    var blockGraph = new BlockGraph();\n    var graphLabel = g.graph();\n    var sepFn = (0, exports.sep)(graphLabel.nodesep, graphLabel.edgesep, reverseSep);\n    layering === null || layering === void 0 ? void 0 : layering.forEach(function (layer) {\n        var u;\n        layer === null || layer === void 0 ? void 0 : layer.forEach(function (v) {\n            var vRoot = root[v];\n            blockGraph.setNode(vRoot);\n            if (u) {\n                var uRoot = root[u];\n                var prevMax = blockGraph.edgeFromArgs(uRoot, vRoot);\n                blockGraph.setEdge(uRoot, vRoot, Math.max(sepFn(g, v, u), prevMax || 0));\n            }\n            u = v;\n        });\n    });\n    return blockGraph;\n};\nexports.buildBlockGraph = buildBlockGraph;\n/*\n * Returns the alignment that has the smallest width of the given alignments.\n */\nvar findSmallestWidthAlignment = function (g, xss) {\n    return (0, util_1.minBy)(Object.values(xss), function (xs) {\n        var _a;\n        var max = Number.NEGATIVE_INFINITY;\n        var min = Number.POSITIVE_INFINITY;\n        (_a = Object.keys(xs)) === null || _a === void 0 ? void 0 : _a.forEach(function (v) {\n            var x = xs[v];\n            var halfWidth = (0, exports.width)(g, v) / 2;\n            max = Math.max(x + halfWidth, max);\n            min = Math.min(x - halfWidth, min);\n        });\n        return max - min;\n    });\n};\nexports.findSmallestWidthAlignment = findSmallestWidthAlignment;\n/*\n * Align the coordinates of each of the layout alignments such that\n * left-biased alignments have their minimum coordinate at the same point as\n * the minimum coordinate of the smallest width alignment and right-biased\n * alignments have their maximum coordinate at the same point as the maximum\n * coordinate of the smallest width alignment.\n */\nfunction alignCoordinates(xss, alignTo) {\n    // @ts-ignore\n    var alignToVals = Object.values(alignTo);\n    var alignToMin = Math.min.apply(Math, alignToVals);\n    var alignToMax = Math.max.apply(Math, alignToVals);\n    [\"u\", \"d\"].forEach(function (vert) {\n        [\"l\", \"r\"].forEach(function (horiz) {\n            var alignment = vert + horiz;\n            var xs = xss[alignment];\n            var delta;\n            if (xs === alignTo)\n                return;\n            var xsVals = Object.values(xs);\n            delta =\n                horiz === \"l\"\n                    ? alignToMin - Math.min.apply(Math, xsVals)\n                    : alignToMax - Math.max.apply(Math, xsVals);\n            if (delta) {\n                xss[alignment] = {};\n                Object.keys(xs).forEach(function (key) {\n                    xss[alignment][key] = xs[key] + delta;\n                });\n            }\n        });\n    });\n}\nexports.alignCoordinates = alignCoordinates;\nvar balance = function (xss, align) {\n    var result = {};\n    Object.keys(xss.ul).forEach(function (key) {\n        if (align) {\n            result[key] = xss[align.toLowerCase()][key];\n        }\n        else {\n            var values = Object.values(xss).map(function (x) { return x[key]; });\n            result[key] = (values[0] + values[1]) / 2; // (ur + ul) / 2\n        }\n    });\n    return result;\n};\nexports.balance = balance;\nvar positionX = function (g) {\n    var layering = (0, util_1.buildLayerMatrix)(g);\n    var conflicts = Object.assign((0, exports.findType1Conflicts)(g, layering), (0, exports.findType2Conflicts)(g, layering));\n    var xss = {};\n    var adjustedLayering;\n    [\"u\", \"d\"].forEach(function (vert) {\n        adjustedLayering =\n            vert === \"u\" ? layering : Object.values(layering).reverse();\n        [\"l\", \"r\"].forEach(function (horiz) {\n            if (horiz === \"r\") {\n                adjustedLayering = adjustedLayering.map(function (inner) {\n                    return Object.values(inner).reverse();\n                });\n            }\n            var neighborFn = (vert === \"u\" ? g.predecessors : g.successors).bind(g);\n            var align = (0, exports.verticalAlignment)(g, adjustedLayering, conflicts, neighborFn);\n            var xs = (0, exports.horizontalCompaction)(g, adjustedLayering, align.root, align.align, horiz === \"r\");\n            if (horiz === \"r\") {\n                Object.keys(xs).forEach(function (key) {\n                    xs[key] = -xs[key];\n                });\n            }\n            xss[vert + horiz] = xs;\n        });\n    });\n    var smallestWidth = (0, exports.findSmallestWidthAlignment)(g, xss);\n    alignCoordinates(xss, smallestWidth);\n    return (0, exports.balance)(xss, g.graph().align);\n};\nexports.positionX = positionX;\nvar sep = function (nodeSep, edgeSep, reverseSep) {\n    return function (g, v, w) {\n        var vLabel = g.node(v);\n        var wLabel = g.node(w);\n        var sum = 0;\n        var delta;\n        sum += vLabel.width / 2;\n        if (vLabel.hasOwnProperty(\"labelpos\")) {\n            switch ((vLabel.labelpos || \"\").toLowerCase()) {\n                case \"l\":\n                    delta = -vLabel.width / 2;\n                    break;\n                case \"r\":\n                    delta = vLabel.width / 2;\n                    break;\n            }\n        }\n        if (delta) {\n            sum += reverseSep ? delta : -delta;\n        }\n        delta = 0;\n        sum += (vLabel.dummy ? edgeSep : nodeSep) / 2;\n        sum += (wLabel.dummy ? edgeSep : nodeSep) / 2;\n        sum += wLabel.width / 2;\n        if (wLabel.labelpos) {\n            switch ((wLabel.labelpos || \"\").toLowerCase()) {\n                case \"l\":\n                    delta = wLabel.width / 2;\n                    break;\n                case \"r\":\n                    delta = -wLabel.width / 2;\n                    break;\n            }\n        }\n        if (delta) {\n            sum += reverseSep ? delta : -delta;\n        }\n        delta = 0;\n        return sum;\n    };\n};\nexports.sep = sep;\nvar width = function (g, v) { return g.node(v).width || 0; };\nexports.width = width;\n"},"sourceMaps":{"js":{"version":3,"file":"bk.js","sourceRoot":"","sources":["../../../../../src/layout/dagre/src/position/bk.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * This module provides coordinate assignment based on Brandes and Köpf, \"Fast\n * and Simple Horizontal Coordinate Assignment.\"\n */\nimport { Graph as RawGraph } from \"@antv/graphlib\";\nimport { Graph } from \"../../graph\";\nimport { buildLayerMatrix, minBy } from \"../util\";\n\nclass BlockGraph extends RawGraph<string, string, number> {}\n\n/*\n * Marks all edges in the graph with a type-1 conflict with the \"type1Conflict\"\n * property. A type-1 conflict is one where a non-inner segment crosses an\n * inner segment. An inner segment is an edge with both incident nodes marked\n * with the \"dummy\" property.\n *\n * This algorithm scans layer by layer, starting with the second, for type-1\n * conflicts between the current layer and the previous layer. For each layer\n * it scans the nodes from left to right until it reaches one that is incident\n * on an inner segment. It then scans predecessors to determine if they have\n * edges that cross that inner segment. At the end a final scan is done for all\n * nodes on the current rank to see if they cross the last visited inner\n * segment.\n *\n * This algorithm (safely) assumes that a dummy node will only be incident on a\n * single node in the layers being scanned.\n */\n\ntype Conflicts = Record<string, Record<string, boolean>>;\n\nexport const findType1Conflicts = (g: Graph, layering?: string[][]) => {\n  const conflicts = {};\n\n  const visitLayer = (prevLayer: string[], layer: string[]) => {\n    // last visited node in the previous layer that is incident on an inner\n    // segment.\n    let k0 = 0;\n    // Tracks the last node in this layer scanned for crossings with a type-1\n    // segment.\n    let scanPos = 0;\n    const prevLayerLength = prevLayer.length;\n    const lastNode = layer?.[layer?.length - 1];\n\n    layer?.forEach((v: string, i: number) => {\n      const w = findOtherInnerSegmentNode(g, v);\n      const k1 = w ? g.node(w)!.order! : prevLayerLength;\n\n      if (w || v === lastNode) {\n        layer.slice(scanPos, i + 1)?.forEach((scanNode) => {\n          g.predecessors(scanNode)?.forEach((u) => {\n            const uLabel = g.node(u)!;\n            const uPos = uLabel.order as number;\n            if (\n              (uPos < k0 || k1 < uPos) &&\n              !(uLabel.dummy && g.node(scanNode)?.dummy)\n            ) {\n              addConflict(conflicts, u, scanNode);\n            }\n          });\n        });\n        scanPos = i + 1;\n        k0 = k1;\n      }\n    });\n\n    return layer;\n  };\n\n  if (layering?.length) {\n    layering.reduce(visitLayer);\n  }\n  return conflicts;\n};\n\nexport const findType2Conflicts = (g: Graph, layering?: string[][]) => {\n  const conflicts = {};\n\n  const scan = (\n    south: string[],\n    southPos: number,\n    southEnd: number,\n    prevNorthBorder: number,\n    nextNorthBorder: number\n  ) => {\n    let v: string;\n    const range = [];\n    for (let i = southPos; i < southEnd; i++) {\n      range.push(i);\n    }\n    range.forEach((i) => {\n      v = south[i];\n      if (g.node(v)?.dummy) {\n        g.predecessors(v)?.forEach((u) => {\n          const uNode = g.node(u)!;\n          if (\n            uNode.dummy &&\n            ((uNode.order as number) < prevNorthBorder ||\n              (uNode.order as number) > nextNorthBorder)\n          ) {\n            addConflict(conflicts, u, v);\n          }\n        });\n      }\n    });\n  };\n\n  const visitLayer = (north: string[], south: string[]) => {\n    let prevNorthPos = -1;\n    let nextNorthPos: number;\n    let southPos = 0;\n\n    south?.forEach((v: string, southLookahead: number) => {\n      if (g.node(v)?.dummy === \"border\") {\n        const predecessors = g.predecessors(v) || [];\n        if (predecessors.length) {\n          nextNorthPos = g.node(predecessors[0]!)!.order as number;\n          scan(south, southPos, southLookahead, prevNorthPos, nextNorthPos);\n          southPos = southLookahead;\n          prevNorthPos = nextNorthPos;\n        }\n      }\n      scan(south, southPos, south.length, nextNorthPos, north.length);\n    });\n\n    return south;\n  };\n\n  if (layering?.length) {\n    layering.reduce(visitLayer);\n  }\n  return conflicts;\n};\n\nexport const findOtherInnerSegmentNode = (g: Graph, v: string) => {\n  if (g.node(v)?.dummy) {\n    return g.predecessors(v)?.find((u) => g.node(u)!.dummy);\n  }\n};\n\nexport const addConflict = (conflicts: Conflicts, v: string, w: string) => {\n  let vv = v;\n  let ww = w;\n  if (vv > ww) {\n    const tmp = vv;\n    vv = ww;\n    ww = tmp;\n  }\n\n  let conflictsV = conflicts[vv];\n  if (!conflictsV) {\n    conflicts[vv] = conflictsV = {};\n  }\n  conflictsV[ww] = true;\n};\n\nexport const hasConflict = (conflicts: Conflicts, v: string, w: string) => {\n  let vv = v;\n  let ww = w;\n  if (vv > ww) {\n    const tmp = v;\n    vv = ww;\n    ww = tmp;\n  }\n  return !!conflicts[vv];\n};\n\n/*\n * Try to align nodes into vertical \"blocks\" where possible. This algorithm\n * attempts to align a node with one of its median neighbors. If the edge\n * connecting a neighbor is a type-1 conflict then we ignore that possibility.\n * If a previous node has already formed a block with a node after the node\n * we're trying to form a block with, we also ignore that possibility - our\n * blocks would be split in that scenario.\n */\nexport const verticalAlignment = (\n  g: Graph,\n  layering: string[][],\n  conflicts: Conflicts,\n  neighborFn: (v: string) => string[]\n) => {\n  const root: Record<string, string> = {};\n  const align: Record<string, string> = {};\n  const pos: Record<string, number> = {};\n\n  // We cache the position here based on the layering because the graph and\n  // layering may be out of sync. The layering matrix is manipulated to\n  // generate different extreme alignments.\n  layering?.forEach((layer) => {\n    layer?.forEach((v, order: number) => {\n      root[v] = v;\n      align[v] = v;\n      pos[v] = order;\n    });\n  });\n\n  layering?.forEach((layer) => {\n    let prevIdx = -1;\n    layer?.forEach((v) => {\n      let ws = neighborFn(v);\n      if (ws.length) {\n        ws = ws.sort((a: string, b: string) => pos[a] - pos[b]);\n        const mp = (ws.length - 1) / 2;\n        for (let i = Math.floor(mp), il = Math.ceil(mp); i <= il; ++i) {\n          const w = ws[i];\n          if (\n            align[v] === v &&\n            prevIdx < pos[w] &&\n            !hasConflict(conflicts, v, w)\n          ) {\n            align[w] = v;\n            align[v] = root[v] = root[w];\n            prevIdx = pos[w];\n          }\n        }\n      }\n    });\n  });\n\n  return { root, align };\n};\n\nexport const horizontalCompaction = (\n  g: Graph,\n  layering: string[][],\n  root: Record<string, string>,\n  align: Record<string, string>,\n  reverseSep?: boolean\n) => {\n  // This portion of the algorithm differs from BK due to a number of problems.\n  // Instead of their algorithm we construct a new block graph and do two\n  // sweeps. The first sweep places blocks with the smallest possible\n  // coordinates. The second sweep removes unused space by moving blocks to the\n  // greatest coordinates without violating separation.\n  const xs: Record<string, number> = {};\n  const blockG = buildBlockGraph(g, layering, root, reverseSep);\n  const borderType = reverseSep ? \"borderLeft\" : \"borderRight\";\n\n  const iterate = (\n    setXsFunc: (param: string) => void,\n    nextNodesFunc: (param: string) => string\n  ) => {\n    let stack = blockG.nodes();\n    let elem = stack.pop();\n    const visited: Record<string, boolean> = {};\n    while (elem) {\n      if (visited[elem]) {\n        setXsFunc(elem);\n      } else {\n        visited[elem] = true;\n        stack.push(elem);\n        stack = stack.concat(nextNodesFunc(elem));\n      }\n\n      elem = stack.pop();\n    }\n  };\n\n  // First pass, assign smallest coordinates\n  const pass1 = (elem: string) => {\n    xs[elem] = (blockG.inEdges(elem) || []).reduce((acc: number, e) => {\n      return Math.max(acc, (xs[e.v] || 0) + blockG.edge(e)!);\n    }, 0);\n  };\n\n  // Second pass, assign greatest coordinates\n  const pass2 = (elem: string) => {\n    const min = (blockG.outEdges(elem) || []).reduce((acc: number, e) => {\n      return Math.min(acc, (xs[e.w] || 0) - blockG.edge(e)!);\n    }, Number.POSITIVE_INFINITY);\n\n    const node = g.node(elem)!;\n    if (min !== Number.POSITIVE_INFINITY && node.borderType !== borderType) {\n      xs[elem] = Math.max(xs[elem], min);\n    }\n  };\n\n  iterate(pass1, blockG.predecessors.bind(blockG));\n  iterate(pass2, blockG.successors.bind(blockG));\n\n  // Assign x coordinates to all nodes\n  Object.values(align)?.forEach((v) => {\n    xs[v] = xs[root[v]];\n  });\n\n  return xs;\n};\n\nexport const buildBlockGraph = (\n  g: Graph,\n  layering: string[][],\n  root: Record<string, string>,\n  reverseSep?: boolean\n) => {\n  const blockGraph = new BlockGraph();\n  const graphLabel = g.graph();\n  const sepFn = sep(\n    graphLabel.nodesep as number,\n    graphLabel.edgesep as number,\n    reverseSep as boolean\n  );\n\n  layering?.forEach((layer) => {\n    let u: string;\n    layer?.forEach((v) => {\n      const vRoot = root[v];\n      blockGraph.setNode(vRoot);\n      if (u) {\n        const uRoot = root[u];\n        const prevMax = blockGraph.edgeFromArgs(uRoot, vRoot);\n        blockGraph.setEdge(\n          uRoot,\n          vRoot,\n          Math.max(sepFn(g, v, u), prevMax || 0)\n        );\n      }\n      u = v;\n    });\n  });\n\n  return blockGraph;\n};\n/*\n * Returns the alignment that has the smallest width of the given alignments.\n */\nexport const findSmallestWidthAlignment = (\n  g: Graph,\n  xss: Record<string, Record<string, number>>\n) => {\n  return minBy(Object.values(xss), (xs) => {\n    let max = Number.NEGATIVE_INFINITY;\n    let min = Number.POSITIVE_INFINITY;\n\n    Object.keys(xs)?.forEach((v: string) => {\n      const x = xs[v];\n      const halfWidth = width(g, v) / 2;\n\n      max = Math.max(x + halfWidth, max);\n      min = Math.min(x - halfWidth, min);\n    });\n\n    return max - min;\n  });\n};\n\n/*\n * Align the coordinates of each of the layout alignments such that\n * left-biased alignments have their minimum coordinate at the same point as\n * the minimum coordinate of the smallest width alignment and right-biased\n * alignments have their maximum coordinate at the same point as the maximum\n * coordinate of the smallest width alignment.\n */\nexport function alignCoordinates(\n  xss: Record<string, Record<string, number>>,\n  alignTo: Record<string, number>\n) {\n  // @ts-ignore\n  const alignToVals = Object.values(alignTo) as number[];\n  const alignToMin = Math.min(...alignToVals);\n  const alignToMax = Math.max(...alignToVals);\n\n  [\"u\", \"d\"].forEach((vert) => {\n    [\"l\", \"r\"].forEach((horiz) => {\n      const alignment = vert + horiz;\n      const xs = xss[alignment];\n      let delta: number;\n      if (xs === alignTo) return;\n\n      const xsVals = Object.values(xs) as number[];\n      delta =\n        horiz === \"l\"\n          ? alignToMin - Math.min(...xsVals)\n          : alignToMax - Math.max(...xsVals);\n\n      if (delta) {\n        xss[alignment] = {};\n        Object.keys(xs).forEach((key) => {\n          xss[alignment][key] = xs[key] + delta;\n        });\n      }\n    });\n  });\n}\n\nexport const balance = (\n  xss: Record<string, Record<string, number>>,\n  align?: string\n) => {\n  const result: Record<string, number> = {};\n  Object.keys(xss.ul).forEach((key) => {\n    if (align) {\n      result[key] = xss[align.toLowerCase()][key];\n    } else {\n      const values = Object.values(xss).map((x) => x[key]);\n      result[key] = (values[0] + values[1]) / 2; // (ur + ul) / 2\n    }\n  });\n  return result;\n};\n\nexport const positionX = (g: Graph) => {\n  const layering = buildLayerMatrix(g);\n  const conflicts = Object.assign(\n    findType1Conflicts(g, layering),\n    findType2Conflicts(g, layering)\n  );\n\n  const xss: Record<string, Record<string, number>> = {};\n  let adjustedLayering: string[][];\n  [\"u\", \"d\"].forEach((vert) => {\n    adjustedLayering =\n      vert === \"u\" ? layering : Object.values(layering).reverse();\n    [\"l\", \"r\"].forEach((horiz) => {\n      if (horiz === \"r\") {\n        adjustedLayering = adjustedLayering.map((inner) =>\n          Object.values(inner).reverse()\n        );\n      }\n\n      const neighborFn = (vert === \"u\" ? g.predecessors : g.successors).bind(g);\n      const align = verticalAlignment(\n        g,\n        adjustedLayering,\n        conflicts,\n        neighborFn\n      );\n      const xs = horizontalCompaction(\n        g,\n        adjustedLayering,\n        align.root,\n        align.align,\n        horiz === \"r\"\n      );\n      if (horiz === \"r\") {\n        Object.keys(xs).forEach((key) => {\n          xs[key] = -xs[key];\n        });\n      }\n      xss[vert + horiz] = xs;\n    });\n  });\n\n  const smallestWidth = findSmallestWidthAlignment(g, xss);\n  alignCoordinates(xss, smallestWidth);\n  return balance(xss, g.graph().align as string);\n};\n\nexport const sep = (nodeSep: number, edgeSep: number, reverseSep: boolean) => {\n  return (g: Graph, v: string, w: string) => {\n    const vLabel = g.node(v)!;\n    const wLabel = g.node(w)!;\n    let sum = 0;\n    let delta;\n\n    sum += vLabel.width! / 2;\n    if (vLabel.hasOwnProperty(\"labelpos\")) {\n      switch ((vLabel.labelpos || \"\").toLowerCase()) {\n        case \"l\":\n          delta = -vLabel.width! / 2;\n          break;\n        case \"r\":\n          delta = vLabel.width! / 2;\n          break;\n      }\n    }\n    if (delta) {\n      sum += reverseSep ? delta : -delta;\n    }\n    delta = 0;\n\n    sum += (vLabel.dummy ? edgeSep : nodeSep) / 2;\n    sum += (wLabel.dummy ? edgeSep : nodeSep) / 2;\n\n    sum += wLabel.width! / 2;\n    if (wLabel.labelpos) {\n      switch ((wLabel.labelpos || \"\").toLowerCase()) {\n        case \"l\":\n          delta = wLabel.width! / 2;\n          break;\n        case \"r\":\n          delta = -wLabel.width! / 2;\n          break;\n      }\n    }\n    if (delta) {\n      sum += reverseSep ? delta : -delta;\n    }\n    delta = 0;\n\n    return sum;\n  };\n};\n\nexport const width = (g: Graph, v: string) => g.node(v)!.width || 0;\n"]}},"error":null,"hash":"abcfb467fe8ec386c87bbee9c005f8ed","cacheData":{"env":{}}}