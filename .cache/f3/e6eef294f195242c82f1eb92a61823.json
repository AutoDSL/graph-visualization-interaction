{"id":"node_modules/@antv/layout/lib/layout/dagre/src/order/init-data-order.js","dependencies":[{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\order\\init-data-order.js.map","includedInParent":true,"mtime":1676178923699},{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\src\\layout\\dagre\\src\\order\\init-data-order.ts","includedInParent":true,"mtime":1676178923981},{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\package.json","includedInParent":true,"mtime":1676178924413},{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\package.json","includedInParent":true,"mtime":1676178923486}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * 按照数据中的结果设置fixorder\n */\nvar initDataOrder = function (g, nodeOrder) {\n    var simpleNodes = g.nodes().filter(function (v) {\n        var _a;\n        return !((_a = g.children(v)) === null || _a === void 0 ? void 0 : _a.length);\n    });\n    var ranks = simpleNodes.map(function (v) { return g.node(v).rank; });\n    var maxRank = Math.max.apply(Math, ranks);\n    var layers = Array(maxRank + 1).fill([]);\n    nodeOrder === null || nodeOrder === void 0 ? void 0 : nodeOrder.forEach(function (n) {\n        var node = g.node(n);\n        // 只考虑原有节点，dummy节点需要按照后续算法排出\n        if (!node || (node === null || node === void 0 ? void 0 : node.dummy)) {\n            return;\n        }\n        if (!isNaN(node.rank)) {\n            node.fixorder = layers[node.rank].length; // 设置fixorder为当层的顺序\n            layers[node.rank].push(n);\n        }\n    });\n};\nexports.default = initDataOrder;\n"},"sourceMaps":{"js":{"version":3,"file":"init-data-order.js","sourceRoot":"","sources":["../../../../../src/layout/dagre/src/order/init-data-order.ts"],"names":[],"mappings":";;AAEA;;GAEG;AACH,IAAM,aAAa,GAAG,UAAC,CAAQ,EAAE,SAAmB;IAClD,IAAM,WAAW,GAAG,CAAC,CAAC,KAAK,EAAE,CAAC,MAAM,CAAC,UAAC,CAAC;;QACrC,OAAO,CAAC,CAAA,MAAA,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,0CAAE,MAAM,CAAA,CAAC;IAChC,CAAC,CAAC,CAAC;IACH,IAAM,KAAK,GAAG,WAAW,CAAC,GAAG,CAAC,UAAC,CAAC,IAAK,OAAA,CAAC,CAAC,IAAI,CAAC,CAAC,CAAE,CAAC,IAAc,EAAzB,CAAyB,CAAC,CAAC;IAChE,IAAM,OAAO,GAAG,IAAI,CAAC,GAAG,OAAR,IAAI,EAAQ,KAAK,CAAC,CAAC;IACnC,IAAM,MAAM,GAAe,KAAK,CAAC,OAAO,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IAEvD,SAAS,aAAT,SAAS,uBAAT,SAAS,CAAE,OAAO,CAAC,UAAC,CAAC;QACnB,IAAM,IAAI,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;QACvB,4BAA4B;QAC5B,IAAI,CAAC,IAAI,KAAI,IAAI,aAAJ,IAAI,uBAAJ,IAAI,CAAE,KAAK,CAAA,EAAE;YACxB,OAAO;SACR;QACD,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAc,CAAC,EAAE;YAC/B,IAAI,CAAC,QAAQ,GAAG,MAAM,CAAC,IAAI,CAAC,IAAc,CAAC,CAAC,MAAM,CAAC,CAAC,mBAAmB;YACvE,MAAM,CAAC,IAAI,CAAC,IAAc,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;SACrC;IACH,CAAC,CAAC,CAAC;AACL,CAAC,CAAC;AAEF,kBAAe,aAAa,CAAC","sourcesContent":["import { Graph } from \"../../graph\";\n\n/**\n * 按照数据中的结果设置fixorder\n */\nconst initDataOrder = (g: Graph, nodeOrder: string[]) => {\n  const simpleNodes = g.nodes().filter((v) => {\n    return !g.children(v)?.length;\n  });\n  const ranks = simpleNodes.map((v) => g.node(v)!.rank as number);\n  const maxRank = Math.max(...ranks);\n  const layers: string[][] = Array(maxRank + 1).fill([]);\n\n  nodeOrder?.forEach((n) => {\n    const node = g.node(n);\n    // 只考虑原有节点，dummy节点需要按照后续算法排出\n    if (!node || node?.dummy) {\n      return;\n    }\n    if (!isNaN(node.rank as number)) {\n      node.fixorder = layers[node.rank as number].length; // 设置fixorder为当层的顺序\n      layers[node.rank as number].push(n);\n    }\n  });\n};\n\nexport default initDataOrder;\n"]}},"error":null,"hash":"0ad4eb186e8d2765ca0b1777438f9f7a","cacheData":{"env":{}}}