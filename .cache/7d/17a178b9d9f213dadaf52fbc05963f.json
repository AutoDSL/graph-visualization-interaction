{"id":"node_modules/@antv/layout/lib/layout/comboCombined.js","dependencies":[{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\comboCombined.js.map","includedInParent":true,"mtime":1676178923556},{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\src\\layout\\comboCombined.ts","includedInParent":true,"mtime":1676178923824},{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\package.json","includedInParent":true,"mtime":1676178924413},{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\package.json","includedInParent":true,"mtime":1676178923486},{"name":"./constants","loc":{"line":34,"column":26,"index":1363},"parent":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\comboCombined.js","resolved":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\constants.js"},{"name":"./base","loc":{"line":35,"column":21,"index":1400},"parent":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\comboCombined.js","resolved":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\base.js"},{"name":"../util","loc":{"line":36,"column":21,"index":1432},"parent":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\comboCombined.js","resolved":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\util\\index.js"},{"name":".","loc":{"line":37,"column":17,"index":1461},"parent":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\comboCombined.js","resolved":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\index.js"}],"generated":{"js":"\"use strict\";\n/**\n * @fileOverview Combo force layout\n * @author shiwu.wyy@antfin.com\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ComboCombinedLayout = void 0;\nvar constants_1 = require(\"./constants\");\nvar base_1 = require(\"./base\");\nvar util_1 = require(\"../util\");\nvar _1 = require(\".\");\n/**\n * combined two layouts (inner and outer) for graph with combos\n */\nvar ComboCombinedLayout = /** @class */ (function (_super) {\n    __extends(ComboCombinedLayout, _super);\n    function ComboCombinedLayout(options) {\n        var _this = _super.call(this) || this;\n        /** 布局中心 */\n        _this.center = [0, 0];\n        /** 内部计算参数 */\n        _this.nodes = [];\n        _this.edges = [];\n        _this.combos = [];\n        _this.comboEdges = [];\n        /** Combo 内部的 padding */\n        _this.comboPadding = 10;\n        _this.comboTrees = [];\n        _this.updateCfg(options);\n        return _this;\n    }\n    ComboCombinedLayout.prototype.getDefaultCfg = function () {\n        return {};\n    };\n    /**\n     * 执行布局\n     */\n    ComboCombinedLayout.prototype.execute = function () {\n        var self = this;\n        var nodes = self.nodes;\n        var center = self.center;\n        if (!nodes || nodes.length === 0) {\n            if (self.onLayoutEnd)\n                self.onLayoutEnd();\n            return;\n        }\n        if (nodes.length === 1) {\n            nodes[0].x = center[0];\n            nodes[0].y = center[1];\n            if (self.onLayoutEnd)\n                self.onLayoutEnd();\n            return;\n        }\n        self.initVals();\n        // layout\n        self.run();\n        if (self.onLayoutEnd)\n            self.onLayoutEnd();\n    };\n    ComboCombinedLayout.prototype.run = function () {\n        var _a;\n        var self = this;\n        var nodes = self.nodes, edges = self.edges, combos = self.combos, comboEdges = self.comboEdges, center = self.center;\n        var nodeMap = {};\n        nodes.forEach(function (node) {\n            nodeMap[node.id] = node;\n        });\n        var comboMap = {};\n        combos.forEach(function (combo) {\n            comboMap[combo.id] = combo;\n        });\n        var innerGraphs = self.getInnerGraphs(nodeMap);\n        // 每个 innerGraph 作为一个节点，带有大小，参与 force 计算\n        var outerNodeIds = [];\n        var outerNodes = [];\n        var nodeAncestorIdMap = {};\n        var allHaveNoPosition = true;\n        this.comboTrees.forEach(function (cTree) {\n            var innerNode = innerGraphs[cTree.id];\n            // 代表 combo 的节点\n            var oNode = __assign(__assign({}, cTree), { x: innerNode.x || comboMap[cTree.id].x, y: innerNode.y || comboMap[cTree.id].y, fx: innerNode.fx || comboMap[cTree.id].fx, fy: innerNode.fy || comboMap[cTree.id].fy, mass: innerNode.mass || comboMap[cTree.id].mass, size: innerNode.size });\n            outerNodes.push(oNode);\n            if (!isNaN(oNode.x) && oNode.x !== 0 && !isNaN(oNode.y) && oNode.y !== 0) {\n                allHaveNoPosition = false;\n            }\n            else {\n                oNode.x = Math.random() * 100;\n                oNode.y = Math.random() * 100;\n            }\n            outerNodeIds.push(cTree.id);\n            (0, util_1.traverseTreeUp)(cTree, function (child) {\n                if (child.id !== cTree.id)\n                    nodeAncestorIdMap[child.id] = cTree.id;\n                return true;\n            });\n        });\n        nodes.forEach(function (node) {\n            if (node.comboId && comboMap[node.comboId])\n                return;\n            // 代表节点的节点\n            var oNode = __assign({}, node);\n            outerNodes.push(oNode);\n            if (!isNaN(oNode.x) && oNode.x !== 0 && !isNaN(oNode.y) && oNode.y !== 0) {\n                allHaveNoPosition = false;\n            }\n            else {\n                oNode.x = Math.random() * 100;\n                oNode.y = Math.random() * 100;\n            }\n            outerNodeIds.push(node.id);\n        });\n        var outerEdges = [];\n        edges.concat(comboEdges).forEach(function (edge) {\n            var sourceAncestorId = nodeAncestorIdMap[edge.source] || edge.source;\n            var targetAncestorId = nodeAncestorIdMap[edge.target] || edge.target;\n            // 若两个点的祖先都在力导图的节点中，且是不同的节点，创建一条链接两个祖先的边到力导图的边中\n            if (sourceAncestorId !== targetAncestorId &&\n                outerNodeIds.includes(sourceAncestorId) &&\n                outerNodeIds.includes(targetAncestorId)) {\n                outerEdges.push({\n                    source: sourceAncestorId,\n                    target: targetAncestorId\n                });\n            }\n        });\n        // 若有需要最外层的 combo 或节点，则对最外层执行力导向\n        if (outerNodes === null || outerNodes === void 0 ? void 0 : outerNodes.length) {\n            if (outerNodes.length === 1) {\n                outerNodes[0].x = center[0];\n                outerNodes[0].y = center[1];\n            }\n            else {\n                var outerData = {\n                    nodes: outerNodes,\n                    edges: outerEdges\n                };\n                // 需要使用一个同步的布局\n                // @ts-ignore\n                var outerLayout = this.outerLayout || new _1.GForceLayout({\n                    gravity: 1,\n                    factor: 4,\n                    linkDistance: function (edge, source, target) {\n                        var _a, _b;\n                        var nodeSize = ((((_a = source.size) === null || _a === void 0 ? void 0 : _a[0]) || 30) + (((_b = target.size) === null || _b === void 0 ? void 0 : _b[0]) || 30)) / 2;\n                        return Math.min(nodeSize * 1.5, 700);\n                    }\n                });\n                var outerLayoutType = (_a = outerLayout.getType) === null || _a === void 0 ? void 0 : _a.call(outerLayout);\n                outerLayout.updateCfg({\n                    center: center,\n                    kg: 5,\n                    preventOverlap: true,\n                    animate: false,\n                });\n                // 若所有 outerNodes 都没有位置，且 outerLayout 是力导家族的布局，则先执行 preset mds 或 grid\n                if (allHaveNoPosition && constants_1.FORCE_LAYOUT_TYPE_MAP[outerLayoutType]) {\n                    var outerLayoutPreset = outerNodes.length < 100 ? new _1.MDSLayout() : new _1.GridLayout();\n                    outerLayoutPreset.layout(outerData);\n                }\n                outerLayout.layout(outerData);\n            }\n            // 根据外部布局结果，平移 innerGraphs 中的节点（第一层）\n            outerNodes.forEach(function (outerNode) {\n                var innerGraph = innerGraphs[outerNode.id];\n                if (!innerGraph) {\n                    var node = nodeMap[outerNode.id];\n                    if (node) {\n                        node.x = outerNode.x;\n                        node.y = outerNode.y;\n                    }\n                    return;\n                }\n                innerGraph.visited = true;\n                innerGraph.x = outerNode.x;\n                innerGraph.y = outerNode.y;\n                innerGraph.nodes.forEach(function (node) {\n                    node.x += outerNode.x;\n                    node.y += outerNode.y;\n                });\n            });\n        }\n        // 至上而下遍历树处理下面各层节点位置\n        var innerGraphIds = Object.keys(innerGraphs);\n        var _loop_1 = function (i) {\n            var id = innerGraphIds[i];\n            var innerGraph = innerGraphs[id];\n            if (!innerGraph)\n                return \"continue\";\n            innerGraph.nodes.forEach(function (node) {\n                if (!innerGraph.visited) {\n                    node.x += (innerGraph.x || 0);\n                    node.y += (innerGraph.y || 0);\n                }\n                if (nodeMap[node.id]) {\n                    nodeMap[node.id].x = node.x;\n                    nodeMap[node.id].y = node.y;\n                }\n            });\n            if (comboMap[id]) {\n                comboMap[id].x = innerGraph.x;\n                comboMap[id].y = innerGraph.y;\n            }\n        };\n        for (var i = innerGraphIds.length - 1; i >= 0; i--) {\n            _loop_1(i);\n        }\n        return { nodes: nodes, edges: edges, combos: combos, comboEdges: comboEdges };\n    };\n    ComboCombinedLayout.prototype.getInnerGraphs = function (nodeMap) {\n        var self = this;\n        var comboTrees = self.comboTrees, nodeSize = self.nodeSize, edges = self.edges, comboPadding = self.comboPadding, spacing = self.spacing;\n        var innerGraphs = {};\n        // @ts-ignore\n        var innerGraphLayout = this.innerLayout || (new _1.ConcentricLayout({ sortBy: 'id' }));\n        innerGraphLayout.center = [0, 0];\n        innerGraphLayout.preventOverlap = true;\n        innerGraphLayout.nodeSpacing = spacing;\n        (comboTrees || []).forEach(function (ctree) {\n            (0, util_1.traverseTreeUp)(ctree, function (treeNode) {\n                var _a;\n                // @ts-ignore\n                var padding = (comboPadding === null || comboPadding === void 0 ? void 0 : comboPadding(treeNode)) || 10; // 返回的最大值\n                if ((0, util_1.isArray)(padding))\n                    padding = Math.max.apply(Math, padding);\n                if (!((_a = treeNode.children) === null || _a === void 0 ? void 0 : _a.length)) {\n                    // 空 combo\n                    if (treeNode.itemType === 'combo') {\n                        var treeNodeSize = padding ? [padding * 2, padding * 2] : [30, 30];\n                        innerGraphs[treeNode.id] = {\n                            id: treeNode.id,\n                            nodes: [],\n                            size: treeNodeSize\n                        };\n                    }\n                }\n                else {\n                    // 非空 combo\n                    var innerGraphNodes = treeNode.children.map(function (child) {\n                        if (child.itemType === 'combo')\n                            return innerGraphs[child.id];\n                        var oriNode = nodeMap[child.id] || {};\n                        return __assign(__assign({}, oriNode), child);\n                    });\n                    var innerGraphNodeIds_1 = innerGraphNodes.map(function (node) { return node.id; });\n                    var innerGraphData = {\n                        nodes: innerGraphNodes,\n                        edges: edges.filter(function (edge) { return innerGraphNodeIds_1.includes(edge.source) && innerGraphNodeIds_1.includes(edge.target); })\n                    };\n                    var minNodeSize_1 = Infinity;\n                    innerGraphNodes.forEach(function (node) {\n                        var _a;\n                        // @ts-ignore\n                        if (!node.size)\n                            node.size = ((_a = innerGraphs[node.id]) === null || _a === void 0 ? void 0 : _a.size) || (nodeSize === null || nodeSize === void 0 ? void 0 : nodeSize(node)) || [30, 30];\n                        if ((0, util_1.isNumber)(node.size))\n                            node.size = [node.size, node.size];\n                        if (minNodeSize_1 > node.size[0])\n                            minNodeSize_1 = node.size[0];\n                        if (minNodeSize_1 > node.size[1])\n                            minNodeSize_1 = node.size[1];\n                    });\n                    // 根据节点数量、spacing，调整布局参数\n                    innerGraphLayout.layout(innerGraphData);\n                    var _b = (0, util_1.getLayoutBBox)(innerGraphNodes), minX = _b.minX, minY = _b.minY, maxX = _b.maxX, maxY = _b.maxY;\n                    // move the innerGraph to [0, 0],for later controled by parent layout\n                    var center_1 = { x: (maxX + minX) / 2, y: (maxY + minY) / 2 };\n                    innerGraphData.nodes.forEach(function (node) {\n                        node.x -= center_1.x;\n                        node.y -= center_1.y;\n                    });\n                    var innerGraphSize = Math.max(maxX - minX, maxY - minY, minNodeSize_1) + padding * 2;\n                    innerGraphs[treeNode.id] = {\n                        id: treeNode.id,\n                        nodes: innerGraphNodes,\n                        size: [innerGraphSize, innerGraphSize]\n                    };\n                }\n                return true;\n            });\n        });\n        return innerGraphs;\n    };\n    ComboCombinedLayout.prototype.initVals = function () {\n        var self = this;\n        var nodeSize = self.nodeSize;\n        var spacing = self.spacing;\n        var nodeSizeFunc;\n        var spacingFunc;\n        // nodeSpacing to function\n        if ((0, util_1.isNumber)(spacing)) {\n            spacingFunc = function () { return spacing; };\n        }\n        else if ((0, util_1.isFunction)(spacing)) {\n            spacingFunc = spacing;\n        }\n        else {\n            spacingFunc = function () { return 0; };\n        }\n        this.spacing = spacingFunc;\n        // nodeSize to function\n        if (!nodeSize) {\n            nodeSizeFunc = function (d) {\n                var spacing = spacingFunc(d);\n                if (d.size) {\n                    if ((0, util_1.isArray)(d.size)) {\n                        var res = d.size[0] > d.size[1] ? d.size[0] : d.size[1];\n                        return (res + spacing) / 2;\n                    }\n                    if ((0, util_1.isObject)(d.size)) {\n                        var res = d.size.width > d.size.height ? d.size.width : d.size.height;\n                        return (res + spacing) / 2;\n                    }\n                    return (d.size + spacing) / 2;\n                }\n                return 10 + spacing / 2;\n            };\n        }\n        else if ((0, util_1.isFunction)(nodeSize)) {\n            nodeSizeFunc = function (d) {\n                var size = nodeSize(d);\n                var spacing = spacingFunc(d);\n                if ((0, util_1.isArray)(d.size)) {\n                    var res = d.size[0] > d.size[1] ? d.size[0] : d.size[1];\n                    return (res + spacing) / 2;\n                }\n                return ((size || 10) + spacing) / 2;\n            };\n        }\n        else if ((0, util_1.isArray)(nodeSize)) {\n            var larger = nodeSize[0] > nodeSize[1] ? nodeSize[0] : nodeSize[1];\n            var radius_1 = larger / 2;\n            nodeSizeFunc = function (d) { return radius_1 + spacingFunc(d) / 2; };\n        }\n        else {\n            // number type\n            var radius_2 = nodeSize / 2;\n            nodeSizeFunc = function (d) { return radius_2 + spacingFunc(d) / 2; };\n        }\n        this.nodeSize = nodeSizeFunc;\n        // comboPadding to function\n        var comboPadding = self.comboPadding;\n        var comboPaddingFunc;\n        if ((0, util_1.isNumber)(comboPadding)) {\n            comboPaddingFunc = function () { return comboPadding; };\n        }\n        else if ((0, util_1.isArray)(comboPadding)) {\n            comboPaddingFunc = function () { return Math.max.apply(null, comboPadding); };\n        }\n        else if ((0, util_1.isFunction)(comboPadding)) {\n            comboPaddingFunc = comboPadding;\n        }\n        else {\n            // null type\n            comboPaddingFunc = function () { return 0; };\n        }\n        this.comboPadding = comboPaddingFunc;\n    };\n    ComboCombinedLayout.prototype.getType = function () {\n        return \"comboCombined\";\n    };\n    return ComboCombinedLayout;\n}(base_1.Base));\nexports.ComboCombinedLayout = ComboCombinedLayout;\n"},"sourceMaps":{"js":{"version":3,"file":"comboCombined.js","sourceRoot":"","sources":["../../src/layout/comboCombined.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @fileOverview Combo force layout\n * @author shiwu.wyy@antfin.com\n */\n\n import {\n  Edge,\n  Combo,\n  OutNode,\n  PointTuple,\n  ComboTree,\n  ComboCombinedLayoutOptions\n} from \"./types\";\nimport { FORCE_LAYOUT_TYPE_MAP } from './constants';\nimport { Base } from \"./base\";\nimport { isArray, isNumber, isFunction, traverseTreeUp, isObject, getLayoutBBox } from \"../util\";\nimport { CircularLayout, ConcentricLayout, GridLayout, RadialLayout, GForceLayout, MDSLayout } from \".\";\n\ntype Node = OutNode & {\n  depth?: number;\n  itemType?: string;\n  comboId?: string;\n  fx?: number;\n  fy?: number;\n  mass?: number;\n};\n\n/**\n * combined two layouts (inner and outer) for graph with combos\n */\nexport class ComboCombinedLayout extends Base {\n\n  /** 布局中心 */\n  public center: PointTuple = [0, 0];\n\n  /** 内部计算参数 */\n  public nodes: Node[] = [];\n\n  public edges: Edge[] = [];\n\n  public combos: Combo[] = [];\n\n  public comboEdges: Edge[] = [];\n\n  /** 节点大小，用于防止节点之间的重叠 */\n  public nodeSize: number | number[] | ((d?: unknown) => number) | undefined;\n\n  /** 节点/combo最小间距，防止重叠时的间隙 */\n  public spacing: ((d?: unknown) => number) | number | undefined;\n\n  /** 最外层的布局算法，需要使用同步的布局算法，默认为 forceAtlas2 */\n  public outerLayout: any;\n\n  /** combo 内部的布局算法，默认为 concentric */\n  public innerLayout: ConcentricLayout | CircularLayout | GridLayout | RadialLayout;\n\n  /** Combo 内部的 padding */\n  public comboPadding:\n    | ((d?: unknown) => number)\n    | number\n    | number[]\n    | undefined = 10;\n\n  public comboTrees: ComboTree[] = [];\n\n  constructor(options?: ComboCombinedLayoutOptions) {\n    super();\n    this.updateCfg(options);\n  }\n\n  public getDefaultCfg() {\n    return {};\n  }\n\n  /**\n   * 执行布局\n   */\n  public execute() {\n    const self = this;\n    const nodes = self.nodes;\n    const center = self.center;\n\n    if (!nodes || nodes.length === 0) {\n      if (self.onLayoutEnd) self.onLayoutEnd();\n      return;\n    }\n    if (nodes.length === 1) {\n      nodes[0].x = center[0];\n      nodes[0].y = center[1];\n      if (self.onLayoutEnd) self.onLayoutEnd();\n      return;\n    }\n\n    self.initVals();\n\n    // layout\n    self.run();\n    if (self.onLayoutEnd) self.onLayoutEnd();\n  }\n\n  public run() {\n    const self = this;\n    const { nodes, edges, combos, comboEdges, center } = self;\n    \n    const nodeMap: any = {};\n    nodes.forEach((node) => {\n      nodeMap[node.id] = node;\n    });\n    const comboMap: any = {};\n    combos.forEach((combo) => {\n      comboMap[combo.id] = combo;\n    });\n\n    const innerGraphs: any = self.getInnerGraphs(nodeMap);\n\n    // 每个 innerGraph 作为一个节点，带有大小，参与 force 计算\n    const outerNodeIds: string[] = [];\n    const outerNodes: Node[] = [];\n    const nodeAncestorIdMap: { [key: string]: string } = {};\n    let allHaveNoPosition = true;\n    this.comboTrees.forEach((cTree) => {\n      const innerNode = innerGraphs[cTree.id];\n      // 代表 combo 的节点\n      const oNode: Node = {\n        ...cTree,\n        x: innerNode.x || comboMap[cTree.id].x,\n        y: innerNode.y || comboMap[cTree.id].y,\n        fx: innerNode.fx || comboMap[cTree.id].fx,\n        fy: innerNode.fy || comboMap[cTree.id].fy,\n        mass: innerNode.mass || comboMap[cTree.id].mass,\n        size: innerNode.size\n      };\n      outerNodes.push(oNode);\n      if (!isNaN(oNode.x) && oNode.x !== 0 && !isNaN(oNode.y) && oNode.y !== 0) {\n        allHaveNoPosition = false;\n      } else {\n        oNode.x = Math.random() * 100;\n        oNode.y = Math.random() * 100;\n      }\n      outerNodeIds.push(cTree.id);\n      traverseTreeUp<ComboTree>(cTree, (child) => {\n        if (child.id !== cTree.id) nodeAncestorIdMap[child.id] = cTree.id;\n        return true;\n      });\n    });\n    nodes.forEach((node) => {\n      if (node.comboId && comboMap[node.comboId]) return;\n      // 代表节点的节点\n      const oNode: Node = { ...node };\n      outerNodes.push(oNode);\n      if (!isNaN(oNode.x) && oNode.x !== 0 && !isNaN(oNode.y) && oNode.y !== 0) {\n        allHaveNoPosition = false;\n      } else {\n        oNode.x = Math.random() * 100;\n        oNode.y = Math.random() * 100;\n      }\n      outerNodeIds.push(node.id);\n    });\n    const outerEdges: any = [];\n    edges.concat(comboEdges).forEach((edge) => {\n      const sourceAncestorId = nodeAncestorIdMap[edge.source] || edge.source;\n      const targetAncestorId = nodeAncestorIdMap[edge.target] || edge.target;\n      // 若两个点的祖先都在力导图的节点中，且是不同的节点，创建一条链接两个祖先的边到力导图的边中\n      if (sourceAncestorId !== targetAncestorId &&\n        outerNodeIds.includes(sourceAncestorId) &&\n        outerNodeIds.includes(targetAncestorId)) {\n        outerEdges.push({\n          source: sourceAncestorId,\n          target: targetAncestorId\n        });\n      }\n    });\n\n    // 若有需要最外层的 combo 或节点，则对最外层执行力导向\n    if (outerNodes?.length) {\n      if (outerNodes.length === 1) {\n        outerNodes[0].x = center[0];\n        outerNodes[0].y = center[1];\n      } else {\n        const outerData = {\n          nodes: outerNodes,\n          edges: outerEdges\n        };\n\n        // 需要使用一个同步的布局\n        // @ts-ignore\n        const outerLayout = this.outerLayout || new GForceLayout({\n          gravity: 1,\n          factor: 4,\n          linkDistance: (edge: any, source: any, target: any) => {\n            const nodeSize = ((source.size?.[0] || 30) + (target.size?.[0] || 30)) / 2;\n            return Math.min(nodeSize * 1.5, 700);\n          }\n        });\n        const outerLayoutType = outerLayout.getType?.();\n        outerLayout.updateCfg({\n          center,\n          kg: 5,\n          preventOverlap: true,\n          animate: false,\n        });\n        // 若所有 outerNodes 都没有位置，且 outerLayout 是力导家族的布局，则先执行 preset mds 或 grid\n        if (allHaveNoPosition && FORCE_LAYOUT_TYPE_MAP[outerLayoutType]) {\n          const outerLayoutPreset = outerNodes.length < 100 ? new MDSLayout() : new GridLayout();\n          outerLayoutPreset.layout(outerData);\n        }\n        outerLayout.layout(outerData);\n      }\n      // 根据外部布局结果，平移 innerGraphs 中的节点（第一层）\n      outerNodes.forEach((outerNode) => {\n        const innerGraph = innerGraphs[outerNode.id];\n        if (!innerGraph) {\n          const node = nodeMap[outerNode.id];\n          if (node) {\n            node.x = outerNode.x;\n            node.y = outerNode.y;\n          }\n          return;\n        }\n        innerGraph.visited = true;\n        innerGraph.x = outerNode.x;\n        innerGraph.y = outerNode.y;\n        innerGraph.nodes.forEach((node: OutNode) => {\n          node.x += outerNode.x;\n          node.y += outerNode.y;\n        });\n      });\n    }\n\n    // 至上而下遍历树处理下面各层节点位置\n    const innerGraphIds = Object.keys(innerGraphs);\n    for (let i = innerGraphIds.length - 1; i >= 0; i--) {\n      const id = innerGraphIds[i];\n      const innerGraph = innerGraphs[id];\n      if (!innerGraph) continue;\n      innerGraph.nodes.forEach((node: OutNode) => {\n        if (!innerGraph.visited) {\n          node.x += (innerGraph.x || 0);\n          node.y += (innerGraph.y || 0);\n        }\n        if (nodeMap[node.id]) {\n          nodeMap[node.id].x = node.x;\n          nodeMap[node.id].y = node.y;\n        }\n      });\n      if (comboMap[id]) {\n        comboMap[id].x = innerGraph.x;\n        comboMap[id].y = innerGraph.y;\n      }\n    }\n    return { nodes, edges, combos, comboEdges };\n  }\n\n  private getInnerGraphs(nodeMap: any) {\n    const self = this;\n    const { comboTrees, nodeSize, edges, comboPadding, spacing } = self;\n    const innerGraphs: any = {};\n\n    // @ts-ignore\n    const innerGraphLayout: any = this.innerLayout || (new ConcentricLayout({ sortBy: 'id' }));\n    innerGraphLayout.center = [0, 0];\n    innerGraphLayout.preventOverlap = true;\n    innerGraphLayout.nodeSpacing = spacing;\n\n    (comboTrees || []).forEach((ctree: any) => {\n      traverseTreeUp<ComboTree>(ctree, (treeNode) => {\n        // @ts-ignore\n        let padding = comboPadding?.(treeNode) || 10; // 返回的最大值\n        if (isArray(padding)) padding = Math.max(...padding);\n        if (!treeNode.children?.length) {\n          // 空 combo\n          if (treeNode.itemType === 'combo') {\n            const treeNodeSize = padding ? [padding * 2, padding * 2] : [30, 30];\n            innerGraphs[treeNode.id] = {\n              id: treeNode.id,\n              nodes: [],\n              size: treeNodeSize\n            };\n          }\n        } else {\n          // 非空 combo\n          const innerGraphNodes = treeNode.children.map((child) => {\n            if (child.itemType === 'combo') return innerGraphs[child.id];\n            const oriNode = nodeMap[child.id] || {};\n            return { ...oriNode, ...child };\n          });\n          const innerGraphNodeIds = innerGraphNodes.map((node) => node.id);\n          const innerGraphData = {\n            nodes: innerGraphNodes,\n            edges: edges.filter((edge) => innerGraphNodeIds.includes(edge.source) && innerGraphNodeIds.includes(edge.target))\n          };\n          let minNodeSize = Infinity;\n          innerGraphNodes.forEach((node) => {\n            // @ts-ignore\n            if (!node.size) node.size = innerGraphs[node.id]?.size || nodeSize?.(node) || [30, 30];\n            if (isNumber(node.size)) node.size = [node.size, node.size];\n            if (minNodeSize > node.size[0]) minNodeSize = node.size[0];\n            if (minNodeSize > node.size[1]) minNodeSize = node.size[1];\n          });\n\n          // 根据节点数量、spacing，调整布局参数\n          \n          innerGraphLayout.layout(innerGraphData);\n          const { minX, minY, maxX, maxY } = getLayoutBBox(innerGraphNodes);\n          // move the innerGraph to [0, 0],for later controled by parent layout\n          const center = { x: (maxX + minX) / 2, y: (maxY + minY) / 2 };\n          innerGraphData.nodes.forEach(node => {\n            node.x -= center.x;\n            node.y -= center.y;\n          })\n          const innerGraphSize = Math.max(maxX - minX, maxY - minY, minNodeSize) + padding * 2;\n          innerGraphs[treeNode.id] = {\n            id: treeNode.id,\n            nodes: innerGraphNodes,\n            size: [innerGraphSize, innerGraphSize]\n          };\n        }\n        return true;\n      });\n    });\n    return innerGraphs;\n  }\n\n  private initVals() {\n    const self = this;\n\n    const nodeSize = self.nodeSize;\n    const spacing = self.spacing;\n    let nodeSizeFunc: (d: any) => number;\n    let spacingFunc: (d: any) => number;\n\n    // nodeSpacing to function\n    if (isNumber(spacing)) {\n      spacingFunc = () => spacing as any;\n    } else if (isFunction(spacing)) {\n      spacingFunc = spacing;\n    } else {\n      spacingFunc = () => 0;\n    }\n    this.spacing = spacingFunc;\n\n    // nodeSize to function\n    if (!nodeSize) {\n      nodeSizeFunc = (d) => {\n        const spacing = spacingFunc(d);\n        if (d.size) {\n          if (isArray(d.size)) {\n            const res = d.size[0] > d.size[1] ? d.size[0] : d.size[1];\n            return (res + spacing) / 2;\n          }  if (isObject(d.size)) {\n            const res = d.size.width > d.size.height ? d.size.width : d.size.height;\n            return (res + spacing) / 2;\n          }\n          return (d.size + spacing) / 2;\n        }\n        return 10 + spacing / 2;\n      };\n    } else if (isFunction(nodeSize)) {\n      nodeSizeFunc = (d) => {\n        const size = nodeSize(d);\n        const spacing = spacingFunc(d);\n        if (isArray(d.size)) {\n          const res = d.size[0] > d.size[1] ? d.size[0] : d.size[1];\n          return (res + spacing) / 2;\n        }\n        return ((size || 10) + spacing) / 2;\n      };\n    } else if (isArray(nodeSize)) {\n      const larger = nodeSize[0] > nodeSize[1] ? nodeSize[0] : nodeSize[1];\n      const radius = larger / 2;\n      nodeSizeFunc = (d) => radius + spacingFunc(d) / 2;\n    } else {\n      // number type\n      const radius = nodeSize / 2;\n      nodeSizeFunc = (d) => radius + spacingFunc(d) / 2;\n    }\n    this.nodeSize = nodeSizeFunc;\n\n    // comboPadding to function\n    const comboPadding = self.comboPadding;\n    let comboPaddingFunc: (d: any) => number;\n    if (isNumber(comboPadding)) {\n      comboPaddingFunc = () => comboPadding as any;\n    } else if (isArray(comboPadding)) {\n      comboPaddingFunc = () => Math.max.apply(null, comboPadding);\n    } else if (isFunction(comboPadding)) {\n      comboPaddingFunc = comboPadding;\n    } else {\n      // null type\n      comboPaddingFunc = () => 0;\n    }\n    this.comboPadding = comboPaddingFunc;\n  }\n  public getType() {\n    return \"comboCombined\";\n  }\n}\n"]}},"error":null,"hash":"2d59d235c0acd56a96791da8eae4828e","cacheData":{"env":{}}}