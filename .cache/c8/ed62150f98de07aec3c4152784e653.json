{"id":"node_modules/@antv/layout/lib/layout/dagre/src/order/sort-subgraph.js","dependencies":[{"name":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\order\\sort-subgraph.js.map","includedInParent":true,"mtime":499162500000},{"name":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\src\\layout\\dagre\\src\\order\\sort-subgraph.ts","includedInParent":true,"mtime":499162500000},{"name":"D:\\myData\\前端\\doing\\AutoPL\\package.json","includedInParent":true,"mtime":1674182060254},{"name":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\package.json","includedInParent":true,"mtime":1674179681168},{"name":"./barycenter","loc":{"line":6,"column":43,"index":259},"parent":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\order\\sort-subgraph.js","resolved":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\order\\barycenter.js"},{"name":"./resolve-conflicts","loc":{"line":7,"column":50,"index":327},"parent":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\order\\sort-subgraph.js","resolved":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\order\\resolve-conflicts.js"},{"name":"./sort","loc":{"line":8,"column":37,"index":389},"parent":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\order\\sort-subgraph.js","resolved":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\order\\sort.js"}],"generated":{"js":"\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar barycenter_1 = __importDefault(require(\"./barycenter\"));\nvar resolve_conflicts_1 = __importDefault(require(\"./resolve-conflicts\"));\nvar sort_1 = __importDefault(require(\"./sort\"));\nvar sortSubgraph = function (g, v, cg, biasRight, usePrev) {\n    var _a, _b, _c, _d;\n    var movable = g.children(v);\n    // fixorder的点不参与排序（这个方案不合适，只排了新增节点，和原来的分离）\n    var node = g.node(v);\n    var bl = node ? node.borderLeft : undefined;\n    var br = node ? node.borderRight : undefined;\n    var subgraphs = {};\n    if (bl) {\n        movable = movable === null || movable === void 0 ? void 0 : movable.filter(function (w) {\n            return w !== bl && w !== br;\n        });\n    }\n    var barycenters = (0, barycenter_1.default)(g, movable || []);\n    barycenters === null || barycenters === void 0 ? void 0 : barycenters.forEach(function (entry) {\n        var _a;\n        if ((_a = g.children(entry.v)) === null || _a === void 0 ? void 0 : _a.length) {\n            var subgraphResult = sortSubgraph(g, entry.v, cg, biasRight);\n            subgraphs[entry.v] = subgraphResult;\n            if (subgraphResult.hasOwnProperty(\"barycenter\")) {\n                mergeBarycenters(entry, subgraphResult);\n            }\n        }\n    });\n    var entries = (0, resolve_conflicts_1.default)(barycenters, cg);\n    expandSubgraphs(entries, subgraphs);\n    // 添加fixorder信息到entries里边\n    // TODO: 不考虑复合情况，只用第一个点的fixorder信息，后续考虑更完备的实现\n    (_a = entries\n        .filter(function (e) { return e.vs.length > 0; })) === null || _a === void 0 ? void 0 : _a.forEach(function (e) {\n        var node = g.node(e.vs[0]);\n        if (node) {\n            e.fixorder = node.fixorder;\n            e.order = node.order;\n        }\n    });\n    var result = (0, sort_1.default)(entries, biasRight, usePrev);\n    if (bl) {\n        result.vs = [bl, result.vs, br].flat();\n        if ((_b = g.predecessors(bl)) === null || _b === void 0 ? void 0 : _b.length) {\n            var blPred = g.node(((_c = g.predecessors(bl)) === null || _c === void 0 ? void 0 : _c[0]) || \"\");\n            var brPred = g.node(((_d = g.predecessors(br)) === null || _d === void 0 ? void 0 : _d[0]) || \"\");\n            if (!result.hasOwnProperty(\"barycenter\")) {\n                result.barycenter = 0;\n                result.weight = 0;\n            }\n            result.barycenter =\n                (result.barycenter * result.weight +\n                    blPred.order +\n                    brPred.order) /\n                    (result.weight + 2);\n            result.weight += 2;\n        }\n    }\n    return result;\n};\nvar expandSubgraphs = function (entries, subgraphs) {\n    entries === null || entries === void 0 ? void 0 : entries.forEach(function (entry) {\n        var _a;\n        var vss = (_a = entry.vs) === null || _a === void 0 ? void 0 : _a.map(function (v) {\n            if (subgraphs[v]) {\n                return subgraphs[v].vs;\n            }\n            return v;\n        });\n        entry.vs = vss.flat();\n    });\n};\nvar mergeBarycenters = function (target, other) {\n    if (target.barycenter !== undefined) {\n        target.barycenter =\n            (target.barycenter * target.weight + other.barycenter * other.weight) /\n                (target.weight + other.weight);\n        target.weight += other.weight;\n    }\n    else {\n        target.barycenter = other.barycenter;\n        target.weight = other.weight;\n    }\n};\nexports.default = sortSubgraph;\n"},"sourceMaps":{"js":{"version":3,"file":"sort-subgraph.js","sourceRoot":"","sources":["../../../../../src/layout/dagre/src/order/sort-subgraph.ts"],"names":[],"mappings":"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","sourcesContent":["import { Graph } from \"../../graph\";\nimport barycenter from \"./barycenter\";\nimport resolveConflicts, { ConflictEntry } from \"./resolve-conflicts\";\nimport sort from \"./sort\";\n\nconst sortSubgraph = (\n  g: Graph,\n  v: string,\n  cg: Graph,\n  biasRight?: boolean,\n  usePrev?: boolean\n) => {\n  let movable = g.children(v);\n  // fixorder的点不参与排序（这个方案不合适，只排了新增节点，和原来的分离）\n  const node = g.node(v)!;\n  const bl = node ? node.borderLeft : undefined;\n  const br = node ? node.borderRight : undefined;\n  const subgraphs: Record<string, Partial<ConflictEntry>> = {};\n\n  if (bl) {\n    movable = movable?.filter((w) => {\n      return w !== bl && w !== br;\n    });\n  }\n\n  const barycenters = barycenter(g, movable || []);\n  barycenters?.forEach((entry) => {\n    if (g.children(entry.v)?.length) {\n      const subgraphResult = sortSubgraph(g, entry.v, cg, biasRight);\n      subgraphs[entry.v] = subgraphResult;\n      if (subgraphResult.hasOwnProperty(\"barycenter\")) {\n        mergeBarycenters(entry, subgraphResult);\n      }\n    }\n  });\n\n  const entries = resolveConflicts(barycenters, cg);\n  expandSubgraphs(entries, subgraphs);\n\n  // 添加fixorder信息到entries里边\n  // TODO: 不考虑复合情况，只用第一个点的fixorder信息，后续考虑更完备的实现\n  entries\n    .filter((e) => e.vs.length > 0)\n    ?.forEach((e) => {\n      const node = g.node(e.vs[0])!;\n      if (node) {\n        e.fixorder = node.fixorder;\n        e.order = node.order;\n      }\n    });\n\n  const result = sort(entries, biasRight, usePrev);\n\n  if (bl) {\n    result.vs = [bl, result.vs, br].flat();\n    if (g.predecessors(bl)?.length) {\n      const blPred = g.node(g.predecessors(bl)?.[0] || \"\")!;\n      const brPred = g.node(g.predecessors(br)?.[0] || \"\")!;\n      if (!result.hasOwnProperty(\"barycenter\")) {\n        result.barycenter = 0;\n        result.weight = 0;\n      }\n      result.barycenter =\n        (result.barycenter! * result.weight! +\n          (blPred.order as number) +\n          (brPred.order as number)) /\n        (result.weight! + 2);\n      result.weight! += 2;\n    }\n  }\n\n  return result;\n};\n\nconst expandSubgraphs = (\n  entries: ConflictEntry[],\n  subgraphs: Record<string, Partial<ConflictEntry>>\n) => {\n  entries?.forEach((entry) => {\n    const vss = entry.vs?.map((v: string) => {\n      if (subgraphs[v]) {\n        return subgraphs[v].vs!;\n      }\n      return v;\n    });\n    entry.vs = vss.flat();\n  });\n};\n\nconst mergeBarycenters = (\n  target: { weight?: number; barycenter?: number },\n  other: { weight?: number; barycenter?: number }\n) => {\n  if (target.barycenter !== undefined) {\n    target.barycenter =\n      (target.barycenter * target.weight! + other.barycenter! * other.weight!) /\n      (target.weight! + other.weight!);\n    target.weight! += other.weight!;\n  } else {\n    target.barycenter = other.barycenter;\n    target.weight = other.weight;\n  }\n};\n\nexport default sortSubgraph;\n"]}},"error":null,"hash":"e7f05a66344e92a8de8e40961eeb64ae","cacheData":{"env":{}}}