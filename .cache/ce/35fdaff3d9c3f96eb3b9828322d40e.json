{"id":"node_modules/@antv/layout/lib/layout/comboForce.js","dependencies":[{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\comboForce.js.map","includedInParent":true,"mtime":1676178923563},{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\src\\layout\\comboForce.ts","includedInParent":true,"mtime":1676178923828},{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\package.json","includedInParent":true,"mtime":1676178924413},{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\package.json","includedInParent":true,"mtime":1676178923486},{"name":"./base","loc":{"line":23,"column":21,"index":972},"parent":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\comboForce.js","resolved":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\base.js"},{"name":"../util","loc":{"line":24,"column":21,"index":1004},"parent":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\comboForce.js","resolved":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\util\\index.js"}],"generated":{"js":"\"use strict\";\n/**\n * @fileOverview Combo force layout\n * @author shiwu.wyy@antfin.com\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ComboForceLayout = void 0;\nvar base_1 = require(\"./base\");\nvar util_1 = require(\"../util\");\n/**\n * force layout for graph with combos\n */\nvar ComboForceLayout = /** @class */ (function (_super) {\n    __extends(ComboForceLayout, _super);\n    function ComboForceLayout(options) {\n        var _this = _super.call(this) || this;\n        /** 布局中心 */\n        _this.center = [0, 0];\n        /** 停止迭代的最大迭代数 */\n        _this.maxIteration = 100;\n        /** 重力大小，影响图的紧凑程度 */\n        _this.gravity = 10;\n        /** 群组中心力大小 */\n        _this.comboGravity = 10;\n        /** 默认边长度 */\n        _this.linkDistance = 10;\n        /** 每次迭代位移的衰减相关参数 */\n        _this.alpha = 1;\n        _this.alphaMin = 0.001;\n        _this.alphaDecay = 1 - Math.pow(_this.alphaMin, (1 / 300));\n        _this.alphaTarget = 0;\n        /** 节点运动速度衰减参数 */\n        _this.velocityDecay = 0.6;\n        /** 边引力大小 */\n        _this.edgeStrength = 0.6;\n        /** 节点引力大小 */\n        _this.nodeStrength = 30;\n        /** 是否开启防止重叠 */\n        _this.preventOverlap = false;\n        /** 是否开启节点之间的防止重叠 */\n        _this.preventNodeOverlap = false;\n        /** 是否开启 Combo 之间的防止重叠 */\n        _this.preventComboOverlap = false;\n        /** 防止重叠的碰撞力大小 */\n        _this.collideStrength = undefined;\n        /** 防止重叠的碰撞力大小 */\n        _this.nodeCollideStrength = 0.5;\n        /** 防止重叠的碰撞力大小 */\n        _this.comboCollideStrength = 0.5;\n        /** Combo 最小间距，防止重叠时的间隙 */\n        _this.comboSpacing = 20;\n        /** Combo 内部的 padding */\n        _this.comboPadding = 10;\n        /** 优化计算斥力的速度，两节点间距超过 optimizeRangeFactor * width 则不再计算斥力和重叠斥力 */\n        _this.optimizeRangeFactor = 1;\n        /** 每次迭代的回调函数 */\n        _this.onTick = function () { };\n        /** 迭代结束的回调函数 */\n        _this.onLayoutEnd = function () { };\n        /** 根据边两端节点层级差距的调整引力系数的因子，取值范围 [0, 1]。层级差距越大，引力越小 */\n        _this.depthAttractiveForceScale = 1;\n        /** 根据边两端节点层级差距的调整斥力系数的因子，取值范围 [1, Infinity]。层级差距越大，斥力越大 */\n        _this.depthRepulsiveForceScale = 2;\n        /** 内部计算参数 */\n        _this.nodes = [];\n        _this.edges = [];\n        _this.combos = [];\n        _this.comboTrees = [];\n        _this.width = 300;\n        _this.height = 300;\n        _this.bias = [];\n        _this.nodeMap = {};\n        _this.oriComboMap = {};\n        _this.indexMap = {};\n        _this.comboMap = {};\n        _this.previousLayouted = false;\n        _this.updateCfg(options);\n        return _this;\n    }\n    ComboForceLayout.prototype.getDefaultCfg = function () {\n        return {\n            maxIteration: 100,\n            center: [0, 0],\n            gravity: 10,\n            speed: 1,\n            comboGravity: 30,\n            preventOverlap: false,\n            preventComboOverlap: true,\n            preventNodeOverlap: true,\n            nodeSpacing: undefined,\n            collideStrength: undefined,\n            nodeCollideStrength: 0.5,\n            comboCollideStrength: 0.5,\n            comboSpacing: 20,\n            comboPadding: 10,\n            edgeStrength: 0.6,\n            nodeStrength: 30,\n            linkDistance: 10\n        };\n    };\n    /**\n     * 执行布局\n     */\n    ComboForceLayout.prototype.execute = function () {\n        var self = this;\n        var nodes = self.nodes;\n        var center = self.center;\n        self.comboTree = {\n            id: \"comboTreeRoot\",\n            depth: -1,\n            children: self.comboTrees\n        };\n        if (!nodes || nodes.length === 0) {\n            if (self.onLayoutEnd)\n                self.onLayoutEnd();\n            return;\n        }\n        if (nodes.length === 1) {\n            nodes[0].x = center[0];\n            nodes[0].y = center[1];\n            if (self.onLayoutEnd)\n                self.onLayoutEnd();\n            return;\n        }\n        self.initVals();\n        // layout\n        self.run();\n        if (self.onLayoutEnd)\n            self.onLayoutEnd();\n    };\n    ComboForceLayout.prototype.run = function () {\n        var self = this;\n        var nodes = self.nodes;\n        var maxIteration = self.previousLayouted\n            ? self.maxIteration / 5\n            : self.maxIteration;\n        if (!self.width && typeof window !== \"undefined\") {\n            self.width = window.innerWidth;\n        }\n        if (!self.height && typeof window !== \"undefined\") {\n            self.height = window.innerHeight;\n        }\n        var center = self.center;\n        var velocityDecay = self.velocityDecay;\n        // init the positions to make the nodes with same combo gather around the combo\n        var comboMap = self.comboMap;\n        if (!self.previousLayouted)\n            self.initPos(comboMap);\n        var _loop_1 = function (i) {\n            var displacements = [];\n            nodes.forEach(function (_, j) {\n                displacements[j] = { x: 0, y: 0 };\n            });\n            self.applyCalculate(displacements);\n            // gravity for combos\n            self.applyComboCenterForce(displacements);\n            // move\n            nodes.forEach(function (n, j) {\n                if (!(0, util_1.isNumber)(n.x) || !(0, util_1.isNumber)(n.y))\n                    return;\n                n.x += displacements[j].x * velocityDecay;\n                n.y += displacements[j].y * velocityDecay;\n            });\n            self.alpha += (self.alphaTarget - self.alpha) * self.alphaDecay;\n            self.onTick();\n        };\n        // iterate\n        for (var i = 0; i < maxIteration; i++) {\n            _loop_1(i);\n        }\n        // move to center\n        var meanCenter = [0, 0];\n        nodes.forEach(function (n) {\n            if (!(0, util_1.isNumber)(n.x) || !(0, util_1.isNumber)(n.y))\n                return;\n            meanCenter[0] += n.x;\n            meanCenter[1] += n.y;\n        });\n        meanCenter[0] /= nodes.length;\n        meanCenter[1] /= nodes.length;\n        var centerOffset = [center[0] - meanCenter[0], center[1] - meanCenter[1]];\n        nodes.forEach(function (n, j) {\n            if (!(0, util_1.isNumber)(n.x) || !(0, util_1.isNumber)(n.y))\n                return;\n            n.x += centerOffset[0];\n            n.y += centerOffset[1];\n        });\n        // arrange the empty combo\n        self.combos.forEach(function (combo) {\n            var mapped = comboMap[combo.id];\n            if (mapped && mapped.empty) {\n                combo.x = mapped.cx || combo.x;\n                combo.y = mapped.cy || combo.y;\n            }\n        });\n        self.previousLayouted = true;\n    };\n    ComboForceLayout.prototype.initVals = function () {\n        var self = this;\n        var edges = self.edges;\n        var nodes = self.nodes;\n        var combos = self.combos;\n        var count = {};\n        var nodeMap = {};\n        var indexMap = {};\n        nodes.forEach(function (node, i) {\n            nodeMap[node.id] = node;\n            indexMap[node.id] = i;\n        });\n        self.nodeMap = nodeMap;\n        self.indexMap = indexMap;\n        var oriComboMap = {};\n        combos.forEach(function (combo) {\n            oriComboMap[combo.id] = combo;\n        });\n        self.oriComboMap = oriComboMap;\n        self.comboMap = self.getComboMap();\n        var preventOverlap = self.preventOverlap;\n        self.preventComboOverlap = self.preventComboOverlap || preventOverlap;\n        self.preventNodeOverlap = self.preventNodeOverlap || preventOverlap;\n        var collideStrength = self.collideStrength;\n        if (collideStrength) {\n            self.comboCollideStrength = collideStrength;\n            self.nodeCollideStrength = collideStrength;\n        }\n        self.comboCollideStrength = self.comboCollideStrength\n            ? self.comboCollideStrength\n            : 0;\n        self.nodeCollideStrength = self.nodeCollideStrength\n            ? self.nodeCollideStrength\n            : 0;\n        // get edge bias\n        for (var i = 0; i < edges.length; ++i) {\n            var source = (0, util_1.getEdgeTerminal)(edges[i], 'source');\n            var target = (0, util_1.getEdgeTerminal)(edges[i], 'target');\n            if (count[source])\n                count[source]++;\n            else\n                count[source] = 1;\n            if (count[target])\n                count[target]++;\n            else\n                count[target] = 1;\n        }\n        var bias = [];\n        for (var i = 0; i < edges.length; ++i) {\n            var source = (0, util_1.getEdgeTerminal)(edges[i], 'source');\n            var target = (0, util_1.getEdgeTerminal)(edges[i], 'target');\n            bias[i] = count[source] / (count[source] + count[target]);\n        }\n        this.bias = bias;\n        var nodeSize = self.nodeSize;\n        var nodeSpacing = self.nodeSpacing;\n        var nodeSizeFunc;\n        var nodeSpacingFunc;\n        // nodeSpacing to function\n        if ((0, util_1.isNumber)(nodeSpacing)) {\n            nodeSpacingFunc = function () { return nodeSpacing; };\n        }\n        else if ((0, util_1.isFunction)(nodeSpacing)) {\n            nodeSpacingFunc = nodeSpacing;\n        }\n        else {\n            nodeSpacingFunc = function () { return 0; };\n        }\n        this.nodeSpacing = nodeSpacingFunc;\n        // nodeSize to function\n        if (!nodeSize) {\n            nodeSizeFunc = function (d) {\n                if (d.size) {\n                    if ((0, util_1.isArray)(d.size)) {\n                        var res = d.size[0] > d.size[1] ? d.size[0] : d.size[1];\n                        return res / 2;\n                    }\n                    if ((0, util_1.isObject)(d.size)) {\n                        var res = d.size.width > d.size.height ? d.size.width : d.size.height;\n                        return res / 2;\n                    }\n                    return d.size / 2;\n                }\n                return 10;\n            };\n        }\n        else if ((0, util_1.isFunction)(nodeSize)) {\n            nodeSizeFunc = function (d) {\n                return nodeSize(d);\n            };\n        }\n        else if ((0, util_1.isArray)(nodeSize)) {\n            var larger = nodeSize[0] > nodeSize[1] ? nodeSize[0] : nodeSize[1];\n            var radius_1 = larger / 2;\n            nodeSizeFunc = function (d) { return radius_1; };\n        }\n        else {\n            // number type\n            var radius_2 = nodeSize / 2;\n            nodeSizeFunc = function (d) { return radius_2; };\n        }\n        this.nodeSize = nodeSizeFunc;\n        // comboSpacing to function\n        var comboSpacing = self.comboSpacing;\n        var comboSpacingFunc;\n        if ((0, util_1.isNumber)(comboSpacing)) {\n            comboSpacingFunc = function () { return comboSpacing; };\n        }\n        else if ((0, util_1.isFunction)(comboSpacing)) {\n            comboSpacingFunc = comboSpacing;\n        }\n        else {\n            // null type\n            comboSpacingFunc = function () { return 0; };\n        }\n        this.comboSpacing = comboSpacingFunc;\n        // comboPadding to function\n        var comboPadding = self.comboPadding;\n        var comboPaddingFunc;\n        if ((0, util_1.isNumber)(comboPadding)) {\n            comboPaddingFunc = function () { return comboPadding; };\n        }\n        else if ((0, util_1.isArray)(comboPadding)) {\n            comboPaddingFunc = function () { return Math.max.apply(null, comboPadding); };\n        }\n        else if ((0, util_1.isFunction)(comboPadding)) {\n            comboPaddingFunc = comboPadding;\n        }\n        else {\n            // null type\n            comboPaddingFunc = function () { return 0; };\n        }\n        this.comboPadding = comboPaddingFunc;\n        // linkDistance to function\n        var linkDistance = this.linkDistance;\n        var linkDistanceFunc;\n        if (!linkDistance) {\n            linkDistance = 10;\n        }\n        if ((0, util_1.isNumber)(linkDistance)) {\n            linkDistanceFunc = function (d) {\n                return linkDistance;\n            };\n        }\n        else {\n            linkDistanceFunc = linkDistance;\n        }\n        this.linkDistance = linkDistanceFunc;\n        // linkStrength to function\n        var edgeStrength = this.edgeStrength;\n        var edgeStrengthFunc;\n        if (!edgeStrength) {\n            edgeStrength = 1;\n        }\n        if ((0, util_1.isNumber)(edgeStrength)) {\n            edgeStrengthFunc = function (d) {\n                return edgeStrength;\n            };\n        }\n        else {\n            edgeStrengthFunc = edgeStrength;\n        }\n        this.edgeStrength = edgeStrengthFunc;\n        // nodeStrength to function\n        var nodeStrength = this.nodeStrength;\n        var nodeStrengthFunc;\n        if (!nodeStrength) {\n            nodeStrength = 30;\n        }\n        if ((0, util_1.isNumber)(nodeStrength)) {\n            nodeStrengthFunc = function (d) {\n                return nodeStrength;\n            };\n        }\n        else {\n            nodeStrengthFunc = nodeStrength;\n        }\n        this.nodeStrength = nodeStrengthFunc;\n    };\n    ComboForceLayout.prototype.initPos = function (comboMap) {\n        var self = this;\n        var nodes = self.nodes;\n        nodes.forEach(function (node, i) {\n            var comboId = node.comboId;\n            var combo = comboMap[comboId];\n            if (comboId && combo) {\n                node.x = combo.cx + 100 / (i + 1);\n                node.y = combo.cy + 100 / (i + 1);\n            }\n            else {\n                node.x = 100 / (i + 1);\n                node.y = 100 / (i + 1);\n            }\n        });\n    };\n    ComboForceLayout.prototype.getComboMap = function () {\n        var self = this;\n        var nodeMap = self.nodeMap;\n        var comboTrees = self.comboTrees;\n        var oriComboMap = self.oriComboMap;\n        var comboMap = {};\n        (comboTrees || []).forEach(function (ctree) {\n            var treeChildren = [];\n            (0, util_1.traverseTreeUp)(ctree, function (treeNode) {\n                if (treeNode.itemType === \"node\")\n                    return true; // skip it\n                if (!oriComboMap[treeNode.id])\n                    return true; // means it is hidden, skip it\n                if (comboMap[treeNode.id] === undefined) {\n                    var combo = {\n                        id: treeNode.id,\n                        name: treeNode.id,\n                        cx: 0,\n                        cy: 0,\n                        count: 0,\n                        depth: self.oriComboMap[treeNode.id].depth || 0,\n                        children: []\n                    };\n                    comboMap[treeNode.id] = combo;\n                }\n                var children = treeNode.children;\n                if (children) {\n                    children.forEach(function (child) {\n                        if (!comboMap[child.id] && !nodeMap[child.id])\n                            return true; // means it is hidden\n                        treeChildren.push(child);\n                    });\n                }\n                var c = comboMap[treeNode.id];\n                c.cx = 0;\n                c.cy = 0;\n                if (treeChildren.length === 0) {\n                    c.empty = true;\n                    var oriCombo = oriComboMap[treeNode.id];\n                    c.cx = oriCombo.x;\n                    c.cy = oriCombo.y;\n                }\n                treeChildren.forEach(function (child) {\n                    c.count++;\n                    if (child.itemType !== \"node\") {\n                        var childCombo = comboMap[child.id];\n                        if ((0, util_1.isNumber)(childCombo.cx))\n                            c.cx += childCombo.cx;\n                        if ((0, util_1.isNumber)(childCombo.cy))\n                            c.cy += childCombo.cy;\n                        return;\n                    }\n                    var node = nodeMap[child.id];\n                    // means the node is hidden, skip it\n                    if (!node)\n                        return;\n                    if ((0, util_1.isNumber)(node.x)) {\n                        c.cx += node.x;\n                    }\n                    if ((0, util_1.isNumber)(node.y)) {\n                        c.cy += node.y;\n                    }\n                });\n                c.cx /= (c.count || 1);\n                c.cy /= (c.count || 1);\n                c.children = treeChildren;\n                return true;\n            });\n        });\n        return comboMap;\n    };\n    ComboForceLayout.prototype.applyComboCenterForce = function (displacements) {\n        var self = this;\n        var gravity = self.gravity;\n        var comboGravity = self.comboGravity || gravity;\n        var alpha = this.alpha;\n        var comboTrees = self.comboTrees;\n        var indexMap = self.indexMap;\n        var nodeMap = self.nodeMap;\n        var comboMap = self.comboMap;\n        (comboTrees || []).forEach(function (ctree) {\n            (0, util_1.traverseTreeUp)(ctree, function (treeNode) {\n                if (treeNode.itemType === \"node\")\n                    return true; // skip it\n                var combo = comboMap[treeNode.id];\n                // means the combo is hidden, skip it\n                if (!combo)\n                    return true;\n                var c = comboMap[treeNode.id];\n                // higher depth the combo, larger the gravity\n                var gravityScale = ((c.depth + 1) / 10) * 0.5;\n                // apply combo center force for all the descend nodes in this combo\n                // and update the center position and count for this combo\n                var comboX = c.cx;\n                var comboY = c.cy;\n                c.cx = 0;\n                c.cy = 0;\n                c.children.forEach(function (child) {\n                    if (child.itemType !== \"node\") {\n                        var childCombo = comboMap[child.id];\n                        if (childCombo && (0, util_1.isNumber)(childCombo.cx))\n                            c.cx += childCombo.cx;\n                        if (childCombo && (0, util_1.isNumber)(childCombo.cy))\n                            c.cy += childCombo.cy;\n                        return;\n                    }\n                    var node = nodeMap[child.id];\n                    var vecX = (node.x - comboX) || 0.005;\n                    var vecY = (node.y - comboY) || 0.005;\n                    var l = Math.sqrt(vecX * vecX + vecY * vecY);\n                    var childIdx = indexMap[node.id];\n                    var params = ((comboGravity * alpha) / l) * gravityScale;\n                    displacements[childIdx].x -= vecX * params;\n                    displacements[childIdx].y -= vecY * params;\n                    if ((0, util_1.isNumber)(node.x))\n                        c.cx += node.x;\n                    if ((0, util_1.isNumber)(node.y))\n                        c.cy += node.y;\n                });\n                c.cx /= (c.count || 1);\n                c.cy /= (c.count || 1);\n                return true;\n            });\n        });\n    };\n    ComboForceLayout.prototype.applyCalculate = function (displacements) {\n        var self = this;\n        var comboMap = self.comboMap;\n        var nodes = self.nodes;\n        // store the vx, vy, and distance to reduce dulplicate calculation\n        var vecMap = {};\n        nodes.forEach(function (v, i) {\n            nodes.forEach(function (u, j) {\n                if (i < j)\n                    return;\n                var vx = (v.x - u.x) || 0.005;\n                var vy = (v.y - u.y) || 0.005;\n                var vl2 = vx * vx + vy * vy;\n                var vl = Math.sqrt(vl2);\n                if (vl2 < 1)\n                    vl2 = vl;\n                vecMap[\"\".concat(v.id, \"-\").concat(u.id)] = { vx: vx, vy: vy, vl2: vl2, vl: vl };\n                vecMap[\"\".concat(u.id, \"-\").concat(v.id)] = { vl2: vl2, vl: vl, vx: -vx, vy: -vy };\n            });\n        });\n        // get the sizes of the combos\n        self.updateComboSizes(comboMap);\n        self.calRepulsive(displacements, vecMap);\n        self.calAttractive(displacements, vecMap);\n        var preventComboOverlap = self.preventComboOverlap;\n        if (preventComboOverlap)\n            self.comboNonOverlapping(displacements, comboMap);\n    };\n    /**\n     * Update the sizes of the combos according to their children\n     * Used for combos nonoverlap, but not re-render the combo shapes\n     */\n    ComboForceLayout.prototype.updateComboSizes = function (comboMap) {\n        var self = this;\n        var comboTrees = self.comboTrees;\n        var nodeMap = self.nodeMap;\n        var nodeSize = self.nodeSize;\n        var comboSpacing = self.comboSpacing;\n        var comboPadding = self.comboPadding;\n        (comboTrees || []).forEach(function (ctree) {\n            var treeChildren = [];\n            (0, util_1.traverseTreeUp)(ctree, function (treeNode) {\n                if (treeNode.itemType === \"node\")\n                    return true; // skip it\n                var c = comboMap[treeNode.id];\n                // means the combo is hidden, skip it\n                if (!c)\n                    return false;\n                var children = treeNode.children;\n                if (children) {\n                    children.forEach(function (child) {\n                        // means the combo is hidden.\n                        if (!comboMap[child.id] && !nodeMap[child.id])\n                            return;\n                        treeChildren.push(child);\n                    });\n                }\n                c.minX = Infinity;\n                c.minY = Infinity;\n                c.maxX = -Infinity;\n                c.maxY = -Infinity;\n                treeChildren.forEach(function (child) {\n                    if (child.itemType !== \"node\")\n                        return true; // skip it\n                    var node = nodeMap[child.id];\n                    if (!node)\n                        return true; // means it is hidden\n                    var r = nodeSize(node);\n                    var nodeMinX = node.x - r;\n                    var nodeMinY = node.y - r;\n                    var nodeMaxX = node.x + r;\n                    var nodeMaxY = node.y + r;\n                    if (c.minX > nodeMinX)\n                        c.minX = nodeMinX;\n                    if (c.minY > nodeMinY)\n                        c.minY = nodeMinY;\n                    if (c.maxX < nodeMaxX)\n                        c.maxX = nodeMaxX;\n                    if (c.maxY < nodeMaxY)\n                        c.maxY = nodeMaxY;\n                });\n                var minSize = self.oriComboMap[treeNode.id].size || 10;\n                if ((0, util_1.isArray)(minSize))\n                    minSize = minSize[0];\n                var maxLength = Math.max(c.maxX - c.minX, c.maxY - c.minY, minSize);\n                c.r = maxLength / 2 + comboSpacing(c) / 2 + comboPadding(c);\n                return true;\n            });\n        });\n    };\n    /**\n     * prevent the overlappings among combos\n     */\n    ComboForceLayout.prototype.comboNonOverlapping = function (displacements, comboMap) {\n        var self = this;\n        var comboTree = self.comboTree;\n        var comboCollideStrength = self.comboCollideStrength;\n        var indexMap = self.indexMap;\n        var nodeMap = self.nodeMap;\n        (0, util_1.traverseTreeUp)(comboTree, function (treeNode) {\n            if (!comboMap[treeNode.id] &&\n                !nodeMap[treeNode.id] &&\n                treeNode.id !== \"comboTreeRoot\") {\n                return false;\n            } // means it is hidden\n            var children = treeNode.children;\n            // 同个子树下的子 combo 间两两对比\n            if (children && children.length > 1) {\n                children.forEach(function (v, i) {\n                    if (v.itemType === \"node\")\n                        return false; // skip it\n                    var cv = comboMap[v.id];\n                    if (!cv)\n                        return; // means it is hidden, skip it\n                    children.forEach(function (u, j) {\n                        if (i <= j)\n                            return false;\n                        if (u.itemType === \"node\")\n                            return false; // skip it\n                        var cu = comboMap[u.id];\n                        if (!cu)\n                            return false; // means it is hidden, skip it\n                        var vx = (cv.cx - cu.cx) || 0.005;\n                        var vy = (cv.cy - cu.cy) || 0.005;\n                        var l = vx * vx + vy * vy;\n                        var rv = cv.r || 1;\n                        var ru = cu.r || 1;\n                        var r = rv + ru;\n                        var ru2 = ru * ru;\n                        var rv2 = rv * rv;\n                        // overlapping\n                        if (l < r * r) {\n                            var vnodes = v.children;\n                            if (!vnodes || vnodes.length === 0)\n                                return false; // skip it\n                            var unodes_1 = u.children;\n                            if (!unodes_1 || unodes_1.length === 0)\n                                return false; // skip it\n                            var sqrtl = Math.sqrt(l);\n                            var ll = ((r - sqrtl) / sqrtl) * comboCollideStrength;\n                            var xl_1 = vx * ll;\n                            var yl_1 = vy * ll;\n                            var rratio_1 = ru2 / (rv2 + ru2);\n                            var irratio_1 = 1 - rratio_1;\n                            // 两兄弟 combo 的子节点上施加斥力\n                            vnodes.forEach(function (vn) {\n                                if (vn.itemType !== \"node\")\n                                    return false; // skip it\n                                if (!nodeMap[vn.id])\n                                    return; // means it is hidden, skip it\n                                var vindex = indexMap[vn.id];\n                                unodes_1.forEach(function (un) {\n                                    if (un.itemType !== \"node\")\n                                        return false;\n                                    if (!nodeMap[un.id])\n                                        return false; // means it is hidden, skip it\n                                    var uindex = indexMap[un.id];\n                                    displacements[vindex].x += xl_1 * rratio_1;\n                                    displacements[vindex].y += yl_1 * rratio_1;\n                                    displacements[uindex].x -= xl_1 * irratio_1;\n                                    displacements[uindex].y -= yl_1 * irratio_1;\n                                });\n                            });\n                        }\n                    });\n                });\n            }\n            return true;\n        });\n    };\n    /**\n     * Calculate the repulsive force between each node pair\n     * @param displacements The array stores the displacements for nodes\n     * @param vecMap The map stores vector between each node pair\n     */\n    ComboForceLayout.prototype.calRepulsive = function (displacements, vecMap) {\n        var self = this;\n        var nodes = self.nodes;\n        var max = self.width * self.optimizeRangeFactor;\n        var nodeStrength = self.nodeStrength;\n        var alpha = self.alpha;\n        var nodeCollideStrength = self.nodeCollideStrength;\n        var preventNodeOverlap = self.preventNodeOverlap;\n        var nodeSizeFunc = self.nodeSize;\n        var nodeSpacingFunc = self.nodeSpacing;\n        var scale = self.depthRepulsiveForceScale;\n        var center = self.center;\n        nodes.forEach(function (v, i) {\n            if (!v.x || !v.y)\n                return;\n            // center gravity\n            if (center) {\n                var gravity = self.gravity;\n                var vecX = (v.x - center[0]) || 0.005;\n                var vecY = (v.y - center[1]) || 0.005;\n                var l = Math.sqrt(vecX * vecX + vecY * vecY);\n                displacements[i].x -= (vecX * gravity * alpha) / l;\n                displacements[i].y -= (vecY * gravity * alpha) / l;\n            }\n            nodes.forEach(function (u, j) {\n                if (i === j) {\n                    return;\n                }\n                if (!u.x || !u.y)\n                    return;\n                var _a = vecMap[\"\".concat(v.id, \"-\").concat(u.id)], vl2 = _a.vl2, vl = _a.vl;\n                if (vl > max)\n                    return;\n                var _b = vecMap[\"\".concat(v.id, \"-\").concat(u.id)], vx = _b.vx, vy = _b.vy;\n                var depthDiff = Math.log(Math.abs(u.depth - v.depth) / 10) + 1 || 1;\n                depthDiff = depthDiff < 1 ? 1 : depthDiff;\n                if (u.comboId !== v.comboId)\n                    depthDiff += 1;\n                var depthParam = depthDiff ? Math.pow(scale, depthDiff) : 1;\n                var params = ((nodeStrength(u) * alpha) / vl2) * depthParam;\n                displacements[i].x += vx * params;\n                displacements[i].y += vy * params;\n                // prevent node overlappings\n                if (i < j && preventNodeOverlap) {\n                    var ri = (nodeSizeFunc(v) + nodeSpacingFunc(v)) || 1;\n                    var rj = (nodeSizeFunc(u) + nodeSpacingFunc(u)) || 1;\n                    var r = ri + rj;\n                    if (vl2 < r * r) {\n                        var ll = ((r - vl) / vl) * nodeCollideStrength;\n                        var rj2 = rj * rj;\n                        var rratio = rj2 / (ri * ri + rj2);\n                        var xl = vx * ll;\n                        var yl = vy * ll;\n                        displacements[i].x += xl * rratio;\n                        displacements[i].y += yl * rratio;\n                        rratio = 1 - rratio;\n                        displacements[j].x -= xl * rratio;\n                        displacements[j].y -= yl * rratio;\n                    }\n                }\n            });\n        });\n    };\n    /**\n     * Calculate the attractive force between the node pair with edge\n     * @param displacements The array stores the displacements for nodes\n     * @param vecMap The map stores vector between each node pair\n     */\n    ComboForceLayout.prototype.calAttractive = function (displacements, vecMap) {\n        var self = this;\n        var edges = self.edges;\n        var linkDistance = self.linkDistance;\n        var alpha = self.alpha;\n        var edgeStrength = self.edgeStrength;\n        var bias = self.bias;\n        var scale = self.depthAttractiveForceScale;\n        edges.forEach(function (e, i) {\n            var source = (0, util_1.getEdgeTerminal)(e, 'source');\n            var target = (0, util_1.getEdgeTerminal)(e, 'target');\n            if (!source || !target || source === target)\n                return;\n            var uIndex = self.indexMap[source];\n            var vIndex = self.indexMap[target];\n            var u = self.nodeMap[source];\n            var v = self.nodeMap[target];\n            if (!u || !v)\n                return;\n            var depthDiff = u.depth === v.depth ? 0 : Math.log(Math.abs(u.depth - v.depth) / 10);\n            if (u.comboId === v.comboId) {\n                depthDiff = depthDiff / 2;\n            }\n            var depthParam = depthDiff ? Math.pow(scale, depthDiff) : 1;\n            if (u.comboId !== v.comboId && depthParam === 1) {\n                depthParam = scale / 2;\n            }\n            else if (u.comboId === v.comboId) {\n                depthParam = 2;\n            }\n            if (!(0, util_1.isNumber)(v.x) || !(0, util_1.isNumber)(u.x) || !(0, util_1.isNumber)(v.y) || !(0, util_1.isNumber)(u.y)) {\n                return;\n            }\n            var _a = vecMap[\"\".concat(target, \"-\").concat(source)], vl = _a.vl, vx = _a.vx, vy = _a.vy;\n            var l = ((vl - linkDistance(e)) / vl) * alpha * edgeStrength(e) * depthParam;\n            var vecX = vx * l;\n            var vecY = vy * l;\n            var b = bias[i];\n            displacements[vIndex].x -= vecX * b;\n            displacements[vIndex].y -= vecY * b;\n            displacements[uIndex].x += vecX * (1 - b);\n            displacements[uIndex].y += vecY * (1 - b);\n        });\n    };\n    ComboForceLayout.prototype.getType = function () {\n        return \"comboForce\";\n    };\n    return ComboForceLayout;\n}(base_1.Base));\nexports.ComboForceLayout = ComboForceLayout;\n"},"sourceMaps":{"js":{"version":3,"file":"comboForce.js","sourceRoot":"","sources":["../../src/layout/comboForce.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @fileOverview Combo force layout\n * @author shiwu.wyy@antfin.com\n */\n\nimport {\n  Edge,\n  OutNode,\n  PointTuple,\n  IndexMap,\n  Combo,\n  ComboTree,\n  Point,\n  ComboForceLayoutOptions\n} from \"./types\";\nimport { Base } from \"./base\";\nimport { isArray, isNumber, isFunction, traverseTreeUp, isObject, getEdgeTerminal } from \"../util\";\n\ntype Node = OutNode & {\n  depth: number;\n  itemType?: string;\n  comboId?: string;\n};\n\ntype NodeMap = {\n  [key: string]: Node;\n};\n\ntype ComboMap = {\n  [key: string]: Combo;\n};\n\n/**\n * force layout for graph with combos\n */\nexport class ComboForceLayout extends Base {\n  /** 布局中心 */\n  public center: PointTuple = [0, 0];\n\n  /** 停止迭代的最大迭代数 */\n  public maxIteration: number = 100;\n\n  /** 重力大小，影响图的紧凑程度 */\n  public gravity: number = 10;\n\n  /** 群组中心力大小 */\n  public comboGravity: number = 10;\n\n  /** 默认边长度 */\n  public linkDistance: number | ((d?: unknown) => number) = 10;\n\n  /** 每次迭代位移的衰减相关参数 */\n  public alpha: number = 1;\n\n  public alphaMin: number = 0.001;\n\n  public alphaDecay: number = 1 - this.alphaMin ** (1 / 300);\n\n  public alphaTarget: number = 0;\n\n  /** 节点运动速度衰减参数 */\n  public velocityDecay: number = 0.6;\n\n  /** 边引力大小 */\n  public edgeStrength: number | ((d?: unknown) => number) = 0.6;\n\n  /** 节点引力大小 */\n  public nodeStrength: number | ((d?: unknown) => number) = 30;\n\n  /** 是否开启防止重叠 */\n  public preventOverlap: boolean = false;\n\n  /** 是否开启节点之间的防止重叠 */\n  public preventNodeOverlap: boolean = false;\n\n  /** 是否开启 Combo 之间的防止重叠 */\n  public preventComboOverlap: boolean = false;\n\n  /** 防止重叠的碰撞力大小 */\n  public collideStrength: number | undefined = undefined;\n\n  /** 防止重叠的碰撞力大小 */\n  public nodeCollideStrength: number | undefined = 0.5;\n\n  /** 防止重叠的碰撞力大小 */\n  public comboCollideStrength: number | undefined = 0.5;\n\n  /** 节点大小，用于防止重叠 */\n  public nodeSize: number | number[] | ((d?: unknown) => number) | undefined;\n\n  /** 节点最小间距，防止重叠时的间隙 */\n  public nodeSpacing: ((d?: unknown) => number) | number | undefined;\n\n  /** Combo 最小间距，防止重叠时的间隙 */\n  public comboSpacing: ((d?: unknown) => number) | number | undefined = 20;\n\n  /** Combo 内部的 padding */\n  public comboPadding:\n    | ((d?: unknown) => number)\n    | number\n    | number[]\n    | undefined = 10;\n\n  /** 优化计算斥力的速度，两节点间距超过 optimizeRangeFactor * width 则不再计算斥力和重叠斥力 */\n  public optimizeRangeFactor: number = 1;\n\n  /** 每次迭代的回调函数 */\n  public onTick: () => void = () => {};\n\n  /** 迭代结束的回调函数 */\n  public onLayoutEnd: () => void = () => {};\n\n  /** 根据边两端节点层级差距的调整引力系数的因子，取值范围 [0, 1]。层级差距越大，引力越小 */\n  public depthAttractiveForceScale: number = 1;\n\n  /** 根据边两端节点层级差距的调整斥力系数的因子，取值范围 [1, Infinity]。层级差距越大，斥力越大 */\n  public depthRepulsiveForceScale: number = 2;\n\n  /** 内部计算参数 */\n  public nodes: Node[] = [];\n\n  public edges: Edge[] = [];\n\n  public combos: Combo[] = [];\n\n  private comboTrees: ComboTree[] = [];\n\n  // add a virtual root to comboTrees\n  private comboTree: ComboTree;\n\n  private width: number = 300;\n\n  private height: number = 300;\n\n  private bias: number[] = [];\n\n  private nodeMap: NodeMap = {};\n\n  private oriComboMap: ComboMap = {};\n\n  private indexMap: IndexMap = {};\n\n  private comboMap: ComboMap = {};\n\n  private previousLayouted: boolean = false;\n\n  constructor(options?: ComboForceLayoutOptions) {\n    super();\n    this.updateCfg(options);\n  }\n\n  public getDefaultCfg() {\n    return {\n      maxIteration: 100,\n      center: [0, 0],\n      gravity: 10,\n      speed: 1,\n      comboGravity: 30,\n      preventOverlap: false,\n      preventComboOverlap: true,\n      preventNodeOverlap: true,\n      nodeSpacing: undefined,\n      collideStrength: undefined,\n      nodeCollideStrength: 0.5,\n      comboCollideStrength: 0.5,\n      comboSpacing: 20,\n      comboPadding: 10,\n      edgeStrength: 0.6,\n      nodeStrength: 30,\n      linkDistance: 10\n    };\n  }\n\n  /**\n   * 执行布局\n   */\n  public execute() {\n    const self = this;\n    const nodes = self.nodes;\n    const center = self.center;\n    self.comboTree = {\n      id: \"comboTreeRoot\",\n      depth: -1,\n      children: self.comboTrees\n    };\n\n    if (!nodes || nodes.length === 0) {\n      if (self.onLayoutEnd) self.onLayoutEnd();\n      return;\n    }\n    if (nodes.length === 1) {\n      nodes[0].x = center[0];\n      nodes[0].y = center[1];\n      if (self.onLayoutEnd) self.onLayoutEnd();\n      return;\n    }\n\n    self.initVals();\n\n    // layout\n    self.run();\n    if (self.onLayoutEnd) self.onLayoutEnd();\n  }\n\n  public run() {\n    const self = this;\n    const nodes = self.nodes;\n    const maxIteration = self.previousLayouted\n      ? self.maxIteration / 5\n      : self.maxIteration;\n    if (!self.width && typeof window !== \"undefined\") {\n      self.width = window.innerWidth;\n    }\n    if (!self.height && typeof window !== \"undefined\") {\n      self.height = window.innerHeight;\n    }\n    const center = self.center;\n    const velocityDecay = self.velocityDecay;\n\n    // init the positions to make the nodes with same combo gather around the combo\n    const comboMap = self.comboMap;\n    if (!self.previousLayouted) self.initPos(comboMap);\n\n    // iterate\n    for (let i = 0; i < maxIteration; i++) {\n      const displacements: Point[] = [];\n      nodes.forEach((_, j) => {\n        displacements[j] = { x: 0, y: 0 };\n      });\n      self.applyCalculate(displacements);\n\n      // gravity for combos\n      self.applyComboCenterForce(displacements);\n\n      // move\n      nodes.forEach((n, j) => {\n        if (!isNumber(n.x) || !isNumber(n.y)) return;\n        n.x += displacements[j].x * velocityDecay;\n        n.y += displacements[j].y * velocityDecay;\n      });\n      self.alpha += (self.alphaTarget - self.alpha) * self.alphaDecay;\n      self.onTick();\n    }\n\n    // move to center\n    const meanCenter = [0, 0];\n    nodes.forEach((n) => {\n      if (!isNumber(n.x) || !isNumber(n.y)) return;\n      meanCenter[0] += n.x;\n      meanCenter[1] += n.y;\n    });\n    meanCenter[0] /= nodes.length;\n    meanCenter[1] /= nodes.length;\n    const centerOffset = [center[0] - meanCenter[0], center[1] - meanCenter[1]];\n    nodes.forEach((n, j) => {\n      if (!isNumber(n.x) || !isNumber(n.y)) return;\n      n.x += centerOffset[0];\n      n.y += centerOffset[1];\n    });\n\n    // arrange the empty combo\n    self.combos.forEach((combo) => {\n      const mapped = comboMap[combo.id];\n      if (mapped && mapped.empty) {\n        combo.x = mapped.cx || combo.x;\n        combo.y = mapped.cy || combo.y;\n      }\n    });\n\n    self.previousLayouted = true;\n  }\n\n  private initVals() {\n    const self = this;\n    const edges = self.edges;\n    const nodes = self.nodes;\n    const combos = self.combos;\n    const count: any = {};\n\n    const nodeMap: NodeMap = {};\n    const indexMap: IndexMap = {};\n    nodes.forEach((node, i) => {\n      nodeMap[node.id] = node;\n      indexMap[node.id] = i;\n    });\n    self.nodeMap = nodeMap;\n    self.indexMap = indexMap;\n\n    const oriComboMap: ComboMap = {};\n    combos.forEach((combo) => {\n      oriComboMap[combo.id] = combo;\n    });\n    self.oriComboMap = oriComboMap;\n    self.comboMap = self.getComboMap();\n\n    const preventOverlap = self.preventOverlap;\n    self.preventComboOverlap = self.preventComboOverlap || preventOverlap;\n    self.preventNodeOverlap = self.preventNodeOverlap || preventOverlap;\n\n    const collideStrength = self.collideStrength;\n    if (collideStrength) {\n      self.comboCollideStrength = collideStrength;\n      self.nodeCollideStrength = collideStrength;\n    }\n    self.comboCollideStrength = self.comboCollideStrength\n      ? self.comboCollideStrength\n      : 0;\n    self.nodeCollideStrength = self.nodeCollideStrength\n      ? self.nodeCollideStrength\n      : 0;\n\n    // get edge bias\n    for (let i = 0; i < edges.length; ++i) {\n      const source = getEdgeTerminal(edges[i], 'source');\n      const target = getEdgeTerminal(edges[i], 'target');\n      if (count[source]) count[source]++;\n      else count[source] = 1;\n      if (count[target]) count[target]++;\n      else count[target] = 1;\n    }\n    const bias = [];\n    for (let i = 0; i < edges.length; ++i) {\n      const source = getEdgeTerminal(edges[i], 'source');\n      const target = getEdgeTerminal(edges[i], 'target');\n      bias[i] = count[source] / (count[source] + count[target]);\n    }\n    this.bias = bias;\n\n    const nodeSize = self.nodeSize;\n    const nodeSpacing = self.nodeSpacing;\n    let nodeSizeFunc: (d: any) => number;\n    let nodeSpacingFunc: (d: any) => number;\n\n    // nodeSpacing to function\n    if (isNumber(nodeSpacing)) {\n      nodeSpacingFunc = () => nodeSpacing as any;\n    } else if (isFunction(nodeSpacing)) {\n      nodeSpacingFunc = nodeSpacing;\n    } else {\n      nodeSpacingFunc = () => 0;\n    }\n    this.nodeSpacing = nodeSpacingFunc;\n\n    // nodeSize to function\n    if (!nodeSize) {\n      nodeSizeFunc = (d) => {\n        if (d.size) {\n          if (isArray(d.size)) {\n            const res = d.size[0] > d.size[1] ? d.size[0] : d.size[1];\n            return res / 2;\n          }  if (isObject(d.size)) {\n            const res = d.size.width > d.size.height ? d.size.width : d.size.height;\n            return res / 2;\n          }\n          return d.size / 2;\n        }\n        return 10;\n      };\n    } else if (isFunction(nodeSize)) {\n      nodeSizeFunc = (d) => {\n        return nodeSize(d);\n      };\n    } else if (isArray(nodeSize)) {\n      const larger = nodeSize[0] > nodeSize[1] ? nodeSize[0] : nodeSize[1];\n      const radius = larger / 2;\n      nodeSizeFunc = (d) => radius;\n    } else {\n      // number type\n      const radius = nodeSize / 2;\n      nodeSizeFunc = (d) => radius;\n    }\n    this.nodeSize = nodeSizeFunc;\n\n    // comboSpacing to function\n    const comboSpacing = self.comboSpacing;\n    let comboSpacingFunc: (d: any) => number;\n    if (isNumber(comboSpacing)) {\n      comboSpacingFunc = () => comboSpacing as any;\n    } else if (isFunction(comboSpacing)) {\n      comboSpacingFunc = comboSpacing;\n    } else {\n      // null type\n      comboSpacingFunc = () => 0;\n    }\n    this.comboSpacing = comboSpacingFunc;\n\n    // comboPadding to function\n    const comboPadding = self.comboPadding;\n    let comboPaddingFunc: (d: any) => number;\n    if (isNumber(comboPadding)) {\n      comboPaddingFunc = () => comboPadding as any;\n    } else if (isArray(comboPadding)) {\n      comboPaddingFunc = () => Math.max.apply(null, comboPadding);\n    } else if (isFunction(comboPadding)) {\n      comboPaddingFunc = comboPadding;\n    } else {\n      // null type\n      comboPaddingFunc = () => 0;\n    }\n    this.comboPadding = comboPaddingFunc;\n\n    // linkDistance to function\n    let linkDistance = this.linkDistance;\n    let linkDistanceFunc;\n    if (!linkDistance) {\n      linkDistance = 10;\n    }\n    if (isNumber(linkDistance)) {\n      linkDistanceFunc = (d: any) => {\n        return linkDistance;\n      };\n    } else {\n      linkDistanceFunc = linkDistance;\n    }\n    this.linkDistance = linkDistanceFunc as ((d?: unknown) => number);\n\n    // linkStrength to function\n    let edgeStrength = this.edgeStrength;\n    let edgeStrengthFunc;\n    if (!edgeStrength) {\n      edgeStrength = 1;\n    }\n    if (isNumber(edgeStrength)) {\n      edgeStrengthFunc = (d: any) => {\n        return edgeStrength;\n      };\n    } else {\n      edgeStrengthFunc = edgeStrength;\n    }\n    this.edgeStrength = edgeStrengthFunc as ((d?: unknown) => number);\n\n    // nodeStrength to function\n    let nodeStrength = this.nodeStrength;\n    let nodeStrengthFunc;\n    if (!nodeStrength) {\n      nodeStrength = 30;\n    }\n    if (isNumber(nodeStrength)) {\n      nodeStrengthFunc = (d: any) => {\n        return nodeStrength;\n      };\n    } else {\n      nodeStrengthFunc = nodeStrength;\n    }\n    this.nodeStrength = nodeStrengthFunc as ((d?: unknown) => number);\n  }\n\n  private initPos(comboMap: ComboMap) {\n    const self = this;\n    const nodes = self.nodes;\n    nodes.forEach((node, i) => {\n      const comboId = (node as any).comboId;\n      const combo: any = comboMap[comboId];\n      if (comboId && combo) {\n        node.x = combo.cx + 100 / (i + 1);\n        node.y = combo.cy + 100 / (i + 1);\n      } else {\n        node.x = 100 / (i + 1);\n        node.y = 100 / (i + 1);\n      }\n    });\n  }\n\n  private getComboMap() {\n    const self = this;\n    const nodeMap = self.nodeMap;\n    const comboTrees = self.comboTrees;\n    const oriComboMap = self.oriComboMap;\n    const comboMap: ComboMap = {};\n\n    (comboTrees || []).forEach((ctree: any) => {\n      const treeChildren: Combo[] | Node[] = [];\n      traverseTreeUp<ComboTree>(ctree, (treeNode) => {\n        if (treeNode.itemType === \"node\") return true; // skip it\n        if (!oriComboMap[treeNode.id]) return true; // means it is hidden, skip it\n        if (comboMap[treeNode.id] === undefined) {\n          const combo = {\n            id: treeNode.id,\n            name: treeNode.id,\n            cx: 0,\n            cy: 0,\n            count: 0,\n            depth: self.oriComboMap[treeNode.id].depth as number || 0,\n            children: [] as any\n          };\n          comboMap[treeNode.id] = combo;\n        }\n        const children = treeNode.children;\n        if (children) {\n          children.forEach((child: any) => {\n            if (!comboMap[child.id] && !nodeMap[child.id]) return true; // means it is hidden\n            treeChildren.push(child);\n          });\n        }\n        const c: any = comboMap[treeNode.id];\n        c.cx = 0;\n        c.cy = 0;\n\n        if (treeChildren.length === 0) {\n          c.empty = true;\n          const oriCombo = oriComboMap[treeNode.id];\n          c.cx = oriCombo.x as number;\n          c.cy = oriCombo.y as number;\n        }\n\n        treeChildren.forEach((child: Combo | Node) => {\n          (c.count as number)++;\n          if (child.itemType !== \"node\") {\n            const childCombo = comboMap[child.id];\n            if (isNumber(childCombo.cx)) c.cx += childCombo.cx;\n            if (isNumber(childCombo.cy)) c.cy += childCombo.cy;\n            return;\n          }\n          const node = nodeMap[child.id];\n          // means the node is hidden, skip it\n          if (!node) return;\n\n          if (isNumber(node.x)) {\n            c.cx += node.x;\n          }\n          if (isNumber(node.y)) {\n            c.cy += node.y;\n          }\n        });\n        c.cx /= (c.count || 1) as number;\n        c.cy /= (c.count || 1) as number;\n\n        c.children = treeChildren as any;\n\n        return true;\n      });\n    });\n\n    return comboMap;\n  }\n\n  private applyComboCenterForce(displacements: Point[]) {\n    const self = this;\n    const gravity = self.gravity;\n    const comboGravity = self.comboGravity || gravity;\n    const alpha = this.alpha;\n    const comboTrees = self.comboTrees;\n    const indexMap = self.indexMap;\n    const nodeMap = self.nodeMap;\n    const comboMap = self.comboMap;\n\n    (comboTrees || []).forEach((ctree) => {\n      traverseTreeUp<ComboTree>(ctree, (treeNode) => {\n        if (treeNode.itemType === \"node\") return true; // skip it\n        const combo = comboMap[treeNode.id];\n        // means the combo is hidden, skip it\n        if (!combo) return true;\n        const c: any = comboMap[treeNode.id];\n\n        // higher depth the combo, larger the gravity\n        const gravityScale = (((c.depth as number) + 1) / 10) * 0.5;\n        // apply combo center force for all the descend nodes in this combo\n        // and update the center position and count for this combo\n        const comboX = c.cx;\n        const comboY = c.cy;\n        c.cx = 0;\n        c.cy = 0;\n        c.children!.forEach((child: any) => {\n          if (child.itemType !== \"node\") {\n            const childCombo = comboMap[child.id];\n            if (childCombo && isNumber(childCombo.cx)) c.cx += childCombo.cx;\n            if (childCombo && isNumber(childCombo.cy)) c.cy += childCombo.cy;\n            return;\n          }\n          const node = nodeMap[child.id];\n          const vecX = (node.x - comboX) || 0.005;\n          const vecY = (node.y - comboY) || 0.005;\n          const l = Math.sqrt(vecX * vecX + vecY * vecY);\n          const childIdx = indexMap[node.id];\n          const params = ((comboGravity * alpha) / l) * gravityScale;\n          displacements[childIdx].x -= vecX * params;\n          displacements[childIdx].y -= vecY * params;\n\n          if (isNumber(node.x)) c.cx += node.x;\n          if (isNumber(node.y)) c.cy += node.y;\n        });\n        c.cx /= (c.count || 1) as number;\n        c.cy /= (c.count || 1) as number;\n        return true;\n      });\n    });\n  }\n\n  private applyCalculate(displacements: Point[]) {\n    const self = this;\n    const comboMap = self.comboMap;\n    const nodes = self.nodes;\n    // store the vx, vy, and distance to reduce dulplicate calculation\n    const vecMap: any = {};\n    nodes.forEach((v, i) => {\n      nodes.forEach((u, j) => {\n        if (i < j) return;\n        const vx = (v.x - u.x) || 0.005;\n        const vy = (v.y - u.y) || 0.005;\n        let vl2 = vx * vx + vy * vy;\n        const vl = Math.sqrt(vl2);\n        if (vl2 < 1) vl2 = vl;\n        vecMap[`${v.id}-${u.id}`] = { vx, vy, vl2, vl };\n        vecMap[`${u.id}-${v.id}`] = { vl2, vl, vx: -vx, vy: -vy };\n      });\n    });\n    // get the sizes of the combos\n    self.updateComboSizes(comboMap);\n    self.calRepulsive(displacements, vecMap);\n    self.calAttractive(displacements, vecMap);\n\n    const preventComboOverlap = self.preventComboOverlap;\n    if (preventComboOverlap) self.comboNonOverlapping(displacements, comboMap);\n  }\n\n  /**\n   * Update the sizes of the combos according to their children\n   * Used for combos nonoverlap, but not re-render the combo shapes\n   */\n  private updateComboSizes(comboMap: ComboMap) {\n    const self = this;\n    const comboTrees = self.comboTrees;\n    const nodeMap = self.nodeMap;\n    const nodeSize = self.nodeSize as ((d?: unknown) => number);\n    const comboSpacing = self.comboSpacing as ((d?: unknown) => number);\n    const comboPadding = self.comboPadding as ((d?: unknown) => number);\n    (comboTrees || []).forEach((ctree) => {\n      const treeChildren: Combo[] | Node[] = [];\n      traverseTreeUp<ComboTree>(ctree, (treeNode: ComboTree) => {\n        if (treeNode.itemType === \"node\") return true; // skip it\n        const c = comboMap[treeNode.id];\n        // means the combo is hidden, skip it\n        if (!c) return false;\n        const children = treeNode.children;\n        if (children) {\n          children.forEach((child: any) => {\n            // means the combo is hidden.\n            if (!comboMap[child.id] && !nodeMap[child.id]) return;\n            treeChildren.push(child);\n          });\n        }\n\n        c.minX = Infinity;\n        c.minY = Infinity;\n        c.maxX = -Infinity;\n        c.maxY = -Infinity;\n        treeChildren.forEach((child: any) => {\n          if (child.itemType !== \"node\") return true; // skip it\n          const node = nodeMap[child.id];\n          if (!node) return true; // means it is hidden\n          const r = nodeSize(node);\n          const nodeMinX = node.x - r;\n          const nodeMinY = node.y - r;\n          const nodeMaxX = node.x + r;\n          const nodeMaxY = node.y + r;\n          if (c.minX! > nodeMinX) c.minX = nodeMinX;\n          if (c.minY! > nodeMinY) c.minY = nodeMinY;\n          if (c.maxX! < nodeMaxX) c.maxX = nodeMaxX;\n          if (c.maxY! < nodeMaxY) c.maxY = nodeMaxY;\n        });\n        let minSize = self.oriComboMap[treeNode.id].size || 10;\n        if (isArray(minSize)) minSize = minSize[0];\n        const maxLength = Math.max(\n          c.maxX - c.minX,\n          c.maxY - c.minY,\n          minSize as number\n        );\n        c.r = maxLength / 2 + comboSpacing(c) / 2 + comboPadding(c);\n\n        return true;\n      });\n    });\n  }\n\n  /**\n   * prevent the overlappings among combos\n   */\n  private comboNonOverlapping(displacements: Point[], comboMap: ComboMap) {\n    const self = this;\n    const comboTree = self.comboTree;\n    const comboCollideStrength = self.comboCollideStrength as number;\n    const indexMap = self.indexMap;\n    const nodeMap = self.nodeMap;\n\n    traverseTreeUp<ComboTree>(comboTree, (treeNode) => {\n      if (\n        !comboMap[treeNode.id] &&\n        !nodeMap[treeNode.id] &&\n        treeNode.id !== \"comboTreeRoot\"\n      ) {\n        return false;\n      } // means it is hidden\n      const children = treeNode.children;\n      // 同个子树下的子 combo 间两两对比\n      if (children && children.length > 1) {\n        children.forEach((v, i) => {\n          if (v.itemType === \"node\") return false; // skip it\n          const cv: any = comboMap[v.id];\n          if (!cv) return; // means it is hidden, skip it\n          children.forEach((u, j) => {\n            if (i <= j) return false;\n            if (u.itemType === \"node\") return false; // skip it\n            const cu: any = comboMap[u.id];\n            if (!cu) return false; // means it is hidden, skip it\n            const vx = (cv.cx - cu.cx) || 0.005;\n            const vy = (cv.cy - cu.cy) || 0.005;\n            const l = vx * vx + vy * vy;\n            const rv = cv.r as number || 1;\n            const ru = cu.r as number || 1;\n            const r = rv + ru;\n            const ru2 = ru * ru;\n            const rv2 = rv * rv;\n            // overlapping\n            if (l < r * r) {\n              const vnodes = v.children;\n              if (!vnodes || vnodes.length === 0) return false; // skip it\n              const unodes = u.children;\n              if (!unodes || unodes.length === 0) return false; // skip it\n              const sqrtl = Math.sqrt(l);\n              const ll = ((r - sqrtl) / sqrtl) * comboCollideStrength;\n              const xl = vx * ll;\n              const yl = vy * ll;\n              const rratio = ru2 / (rv2 + ru2);\n              const irratio = 1 - rratio;\n              // 两兄弟 combo 的子节点上施加斥力\n              vnodes.forEach((vn) => {\n                if (vn.itemType !== \"node\") return false; // skip it\n                if (!nodeMap[vn.id]) return; // means it is hidden, skip it\n                const vindex = indexMap[vn.id];\n                unodes.forEach((un) => {\n                  if (un.itemType !== \"node\") return false;\n                  if (!nodeMap[un.id]) return false; // means it is hidden, skip it\n                  const uindex = indexMap[un.id];\n                  displacements[vindex].x += xl * rratio;\n                  displacements[vindex].y += yl * rratio;\n                  displacements[uindex].x -= xl * irratio;\n                  displacements[uindex].y -= yl * irratio;\n                });\n              });\n            }\n          });\n        });\n      }\n      return true;\n    });\n  }\n\n  /**\n   * Calculate the repulsive force between each node pair\n   * @param displacements The array stores the displacements for nodes\n   * @param vecMap The map stores vector between each node pair\n   */\n  private calRepulsive(displacements: Point[], vecMap: any) {\n    const self = this;\n    const nodes = self.nodes;\n    const max = self.width * self.optimizeRangeFactor;\n    const nodeStrength = self.nodeStrength as (d?: unknown) => number;\n    const alpha = self.alpha;\n    const nodeCollideStrength = self.nodeCollideStrength as number;\n    const preventNodeOverlap = self.preventNodeOverlap;\n    const nodeSizeFunc = self.nodeSize as ((d?: unknown) => number);\n    const nodeSpacingFunc = self.nodeSpacing as ((d?: unknown) => number);\n    const scale = self.depthRepulsiveForceScale;\n    const center = self.center;\n    nodes.forEach((v, i) => {\n      if (!v.x || !v.y) return;\n\n      // center gravity\n      if (center) {\n        const gravity = self.gravity;\n        const vecX = (v.x - center[0]) || 0.005;\n        const vecY = (v.y - center[1]) || 0.005;\n        const l = Math.sqrt(vecX * vecX + vecY * vecY);\n        displacements[i].x -= (vecX * gravity * alpha) / l;\n        displacements[i].y -= (vecY * gravity * alpha) / l;\n      }\n\n      nodes.forEach((u, j) => {\n        if (i === j) {\n          return;\n        }\n        if (!u.x || !u.y) return;\n        const { vl2, vl } = vecMap[`${v.id}-${u.id}`];\n        if (vl > max) return;\n\n        const { vx, vy } = vecMap[`${v.id}-${u.id}`];\n\n        let depthDiff = Math.log(Math.abs(u.depth - v.depth) / 10) + 1 || 1;\n        depthDiff = depthDiff < 1 ? 1 : depthDiff;\n        if (u.comboId !== v.comboId) depthDiff += 1;\n        const depthParam = depthDiff ? scale ** depthDiff : 1;\n\n        const params = ((nodeStrength(u) * alpha) / vl2) * depthParam;\n        displacements[i].x += vx * params;\n        displacements[i].y += vy * params;\n\n        // prevent node overlappings\n        if (i < j && preventNodeOverlap) {\n          const ri = (nodeSizeFunc(v) + nodeSpacingFunc(v)) || 1;\n          const rj = (nodeSizeFunc(u) + nodeSpacingFunc(u)) || 1;\n          const r = ri + rj;\n          if (vl2 < r * r) {\n            const ll = ((r - vl) / vl) * nodeCollideStrength;\n            const rj2 = rj * rj;\n            let rratio = rj2 / (ri * ri + rj2);\n            const xl = vx * ll;\n            const yl = vy * ll;\n            displacements[i].x += xl * rratio;\n            displacements[i].y += yl * rratio;\n            rratio = 1 - rratio;\n            displacements[j].x -= xl * rratio;\n            displacements[j].y -= yl * rratio;\n          }\n        }\n      });\n    });\n  }\n\n  /**\n   * Calculate the attractive force between the node pair with edge\n   * @param displacements The array stores the displacements for nodes\n   * @param vecMap The map stores vector between each node pair\n   */\n  private calAttractive(displacements: Point[], vecMap: any) {\n    const self = this;\n    const edges = self.edges;\n    const linkDistance = self.linkDistance as (d?: unknown) => number;\n    const alpha = self.alpha;\n    const edgeStrength = self.edgeStrength as (d?: unknown) => number;\n    const bias = self.bias;\n    const scale = self.depthAttractiveForceScale;\n    edges.forEach((e, i) => {\n      const source = getEdgeTerminal(e, 'source');\n      const target = getEdgeTerminal(e, 'target');\n      if (!source || !target || source === target) return;\n      const uIndex = self.indexMap[source];\n      const vIndex = self.indexMap[target];\n      const u: Node = self.nodeMap[source];\n      const v: Node = self.nodeMap[target];\n      if (!u || !v) return;\n\n      let depthDiff = u.depth === v.depth ? 0 : Math.log(Math.abs(u.depth - v.depth) / 10);\n      if (u.comboId === v.comboId) {\n        depthDiff = depthDiff / 2;\n      }\n      let depthParam = depthDiff ? scale ** depthDiff : 1;\n      if (u.comboId !== v.comboId && depthParam === 1) {\n        depthParam = scale / 2;\n      } else if (u.comboId === v.comboId) {\n        depthParam = 2;\n      }\n\n      if (!isNumber(v.x) || !isNumber(u.x) || !isNumber(v.y) || !isNumber(u.y)) {\n        return;\n      }\n      const { vl, vx, vy } = vecMap[`${target}-${source}`];\n      const l =\n        ((vl - linkDistance(e)) / vl) * alpha * edgeStrength(e) * depthParam;\n      const vecX = vx * l;\n      const vecY = vy * l;\n\n      const b = bias[i];\n      displacements[vIndex].x -= vecX * b;\n      displacements[vIndex].y -= vecY * b;\n      displacements[uIndex].x += vecX * (1 - b);\n      displacements[uIndex].y += vecY * (1 - b);\n    });\n  }\n\n  public getType() {\n    return \"comboForce\";\n  }\n}\n"]}},"error":null,"hash":"563e2a2d29902b040d2fe990e1532a68","cacheData":{"env":{}}}