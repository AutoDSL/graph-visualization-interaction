{"id":"node_modules/@antv/layout/lib/util/math.js","dependencies":[{"name":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\lib\\util\\math.js.map","includedInParent":true,"mtime":499162500000},{"name":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\src\\util\\math.ts","includedInParent":true,"mtime":499162500000},{"name":"D:\\myData\\前端\\doing\\AutoPL\\package.json","includedInParent":true,"mtime":1674182060254},{"name":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\package.json","includedInParent":true,"mtime":1674179681168},{"name":"./array","loc":{"line":4,"column":22,"index":365},"parent":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\lib\\util\\math.js","resolved":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\lib\\util\\array.js"},{"name":"./number","loc":{"line":5,"column":23,"index":400},"parent":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\lib\\util\\math.js","resolved":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\lib\\util\\number.js"},{"name":"./object","loc":{"line":6,"column":23,"index":436},"parent":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\lib\\util\\math.js","resolved":"D:\\myData\\前端\\doing\\AutoPL\\node_modules\\@antv\\layout\\lib\\util\\object.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getCoreNodeAndRelativeLeafNodes = exports.getAvgNodePosition = exports.getLayoutBBox = exports.traverseTreeUp = exports.scaleMatrix = exports.getAdjMatrix = exports.floydWarshall = exports.getDegreeMap = exports.getDegree = exports.getEdgeTerminal = void 0;\nvar array_1 = require(\"./array\");\nvar number_1 = require(\"./number\");\nvar object_1 = require(\"./object\");\nvar getEdgeTerminal = function (edge, type) {\n    var terminal = edge[type];\n    if ((0, object_1.isObject)(terminal)) {\n        return terminal.cell;\n    }\n    return terminal;\n};\nexports.getEdgeTerminal = getEdgeTerminal;\nvar getDegree = function (n, nodeIdxMap, edges) {\n    var degrees = [];\n    for (var i = 0; i < n; i++) {\n        degrees[i] = {\n            in: 0,\n            out: 0,\n            all: 0\n        };\n    }\n    if (!edges)\n        return degrees;\n    edges.forEach(function (e) {\n        var source = (0, exports.getEdgeTerminal)(e, 'source');\n        var target = (0, exports.getEdgeTerminal)(e, 'target');\n        if (source && degrees[nodeIdxMap[source]]) {\n            degrees[nodeIdxMap[source]].out += 1;\n            degrees[nodeIdxMap[source]].all += 1;\n        }\n        if (target && degrees[nodeIdxMap[target]]) {\n            degrees[nodeIdxMap[target]].in += 1;\n            degrees[nodeIdxMap[target]].all += 1;\n        }\n    });\n    return degrees;\n};\nexports.getDegree = getDegree;\nvar getDegreeMap = function (nodes, edges) {\n    var degreesMap = {};\n    nodes.forEach(function (node) {\n        degreesMap[node.id] = {\n            in: 0,\n            out: 0,\n            all: 0\n        };\n    });\n    if (!edges)\n        return degreesMap;\n    edges.forEach(function (e) {\n        var source = (0, exports.getEdgeTerminal)(e, 'source');\n        var target = (0, exports.getEdgeTerminal)(e, 'target');\n        if (source) {\n            degreesMap[source].out += 1;\n            degreesMap[source].all += 1;\n        }\n        if (target) {\n            degreesMap[target].in += 1;\n            degreesMap[target].all += 1;\n        }\n    });\n    return degreesMap;\n};\nexports.getDegreeMap = getDegreeMap;\nvar floydWarshall = function (adjMatrix) {\n    // initialize\n    var dist = [];\n    var size = adjMatrix.length;\n    for (var i = 0; i < size; i += 1) {\n        dist[i] = [];\n        for (var j = 0; j < size; j += 1) {\n            if (i === j) {\n                dist[i][j] = 0;\n            }\n            else if (adjMatrix[i][j] === 0 || !adjMatrix[i][j]) {\n                dist[i][j] = Infinity;\n            }\n            else {\n                dist[i][j] = adjMatrix[i][j];\n            }\n        }\n    }\n    // floyd\n    for (var k = 0; k < size; k += 1) {\n        for (var i = 0; i < size; i += 1) {\n            for (var j = 0; j < size; j += 1) {\n                if (dist[i][j] > dist[i][k] + dist[k][j]) {\n                    dist[i][j] = dist[i][k] + dist[k][j];\n                }\n            }\n        }\n    }\n    return dist;\n};\nexports.floydWarshall = floydWarshall;\nvar getAdjMatrix = function (data, directed) {\n    var nodes = data.nodes, edges = data.edges;\n    var matrix = [];\n    // map node with index in data.nodes\n    var nodeMap = {};\n    if (!nodes) {\n        throw new Error('invalid nodes data!');\n    }\n    if (nodes) {\n        nodes.forEach(function (node, i) {\n            nodeMap[node.id] = i;\n            var row = [];\n            matrix.push(row);\n        });\n    }\n    edges === null || edges === void 0 ? void 0 : edges.forEach(function (e) {\n        var source = (0, exports.getEdgeTerminal)(e, 'source');\n        var target = (0, exports.getEdgeTerminal)(e, 'target');\n        var sIndex = nodeMap[source];\n        var tIndex = nodeMap[target];\n        if (sIndex === undefined || tIndex === undefined)\n            return;\n        matrix[sIndex][tIndex] = 1;\n        if (!directed) {\n            matrix[tIndex][sIndex] = 1;\n        }\n    });\n    return matrix;\n};\nexports.getAdjMatrix = getAdjMatrix;\n/**\n * scale matrix\n * @param matrix [ [], [], [] ]\n * @param ratio\n */\nvar scaleMatrix = function (matrix, ratio) {\n    var result = [];\n    matrix.forEach(function (row) {\n        var newRow = [];\n        row.forEach(function (v) {\n            newRow.push(v * ratio);\n        });\n        result.push(newRow);\n    });\n    return result;\n};\nexports.scaleMatrix = scaleMatrix;\n/**\n * depth first traverse, from leaves to root, children in inverse order\n *  if the fn returns false, terminate the traverse\n */\nvar traverseUp = function (data, fn) {\n    if (data && data.children) {\n        for (var i = data.children.length - 1; i >= 0; i--) {\n            if (!traverseUp(data.children[i], fn))\n                return;\n        }\n    }\n    if (!fn(data)) {\n        return false;\n    }\n    return true;\n};\n/**\n * depth first traverse, from leaves to root, children in inverse order\n * if the fn returns false, terminate the traverse\n */\nvar traverseTreeUp = function (data, fn) {\n    if (typeof fn !== 'function') {\n        return;\n    }\n    traverseUp(data, fn);\n};\nexports.traverseTreeUp = traverseTreeUp;\n/**\n * calculate the bounding box for the nodes according to their x, y, and size\n * @param nodes nodes in the layout\n * @returns\n */\nvar getLayoutBBox = function (nodes) {\n    var minX = Infinity;\n    var minY = Infinity;\n    var maxX = -Infinity;\n    var maxY = -Infinity;\n    nodes.forEach(function (node) {\n        var size = node.size;\n        if ((0, array_1.isArray)(size)) {\n            if (size.length === 1)\n                size = [size[0], size[0]];\n        }\n        else if ((0, number_1.isNumber)(size)) {\n            size = [size, size];\n        }\n        else if (size === undefined || isNaN(size)) {\n            size = [30, 30];\n        }\n        var halfSize = [size[0] / 2, size[1] / 2];\n        var left = node.x - halfSize[0];\n        var right = node.x + halfSize[0];\n        var top = node.y - halfSize[1];\n        var bottom = node.y + halfSize[1];\n        if (minX > left)\n            minX = left;\n        if (minY > top)\n            minY = top;\n        if (maxX < right)\n            maxX = right;\n        if (maxY < bottom)\n            maxY = bottom;\n    });\n    return { minX: minX, minY: minY, maxX: maxX, maxY: maxY };\n};\nexports.getLayoutBBox = getLayoutBBox;\n/**\n * 获取节点集合的平均位置信息\n * @param nodes 节点集合\n * @returns 平局内置\n */\nvar getAvgNodePosition = function (nodes) {\n    var totalNodes = { x: 0, y: 0 };\n    nodes.forEach(function (node) {\n        totalNodes.x += node.x || 0;\n        totalNodes.y += node.y || 0;\n    });\n    // 获取均值向量\n    var length = nodes.length || 1;\n    return {\n        x: totalNodes.x / length,\n        y: totalNodes.y / length,\n    };\n};\nexports.getAvgNodePosition = getAvgNodePosition;\n// 找出指定节点关联的边的起点或终点\nvar getCoreNode = function (type, node, edges) {\n    var _a, _b;\n    if (type === 'source') {\n        return (((_a = edges === null || edges === void 0 ? void 0 : edges.find(function (edge) { return edge.target === node.id; })) === null || _a === void 0 ? void 0 : _a.source) || {});\n    }\n    return (((_b = edges === null || edges === void 0 ? void 0 : edges.find(function (edge) { return edge.source === node.id; })) === null || _b === void 0 ? void 0 : _b.target) || {});\n};\n// 找出指定节点为起点或终点的所有一度叶子节点\nvar getRelativeNodeIds = function (type, coreNode, edges) {\n    var relativeNodes = [];\n    switch (type) {\n        case 'source':\n            relativeNodes = edges === null || edges === void 0 ? void 0 : edges.filter(function (edge) { return edge.source === coreNode.id; }).map(function (edge) { return edge.target; });\n            break;\n        case 'target':\n            relativeNodes = edges === null || edges === void 0 ? void 0 : edges.filter(function (edge) { return edge.target === coreNode.id; }).map(function (edge) { return edge.source; });\n            break;\n        case 'both':\n            relativeNodes = edges === null || edges === void 0 ? void 0 : edges.filter(function (edge) { return edge.source === coreNode.id; }).map(function (edge) { return edge.target; }).concat(edges === null || edges === void 0 ? void 0 : edges.filter(function (edge) { return edge.target === coreNode.id; }).map(function (edge) { return edge.source; }));\n            break;\n        default:\n            break;\n    }\n    // 去重\n    var set = new Set(relativeNodes);\n    return Array.from(set);\n};\n// 找出同类型的节点\nvar getSameTypeNodes = function (type, nodeClusterBy, node, relativeNodes, degreesMap) {\n    // @ts-ignore\n    var typeName = node[nodeClusterBy] || '';\n    // @ts-ignore\n    var sameTypeNodes = (relativeNodes === null || relativeNodes === void 0 ? void 0 : relativeNodes.filter(function (item) { return item[nodeClusterBy] === typeName; })) || [];\n    if (type === 'leaf') {\n        sameTypeNodes = sameTypeNodes.filter(function (node) { var _a, _b; return ((_a = degreesMap[node.id]) === null || _a === void 0 ? void 0 : _a.in) === 0 || ((_b = degreesMap[node.id]) === null || _b === void 0 ? void 0 : _b.out) === 0; });\n    }\n    return sameTypeNodes;\n};\n// 找出与指定节点关联的边的起点或终点出发的所有一度叶子节点\nvar getCoreNodeAndRelativeLeafNodes = function (type, node, edges, nodeClusterBy, degreesMap, nodeMap) {\n    var _a = degreesMap[node.id], inDegree = _a.in, outDegree = _a.out;\n    var coreNode = node;\n    var relativeLeafNodes = [];\n    if (inDegree === 0) {\n        // 如果为没有出边的叶子节点，则找出与它关联的边的起点出发的所有一度节点\n        coreNode = getCoreNode('source', node, edges);\n        relativeLeafNodes = getRelativeNodeIds('both', coreNode, edges).map(function (nodeId) { return nodeMap[nodeId]; });\n    }\n    else if (outDegree === 0) {\n        // 如果为没有入边边的叶子节点，则找出与它关联的边的起点出发的所有一度节点\n        coreNode = getCoreNode('target', node, edges);\n        relativeLeafNodes = getRelativeNodeIds('both', coreNode, edges).map(function (nodeId) { return nodeMap[nodeId]; });\n    }\n    relativeLeafNodes = relativeLeafNodes.filter(function (node) { return degreesMap[node.id] && (degreesMap[node.id].in === 0 || degreesMap[node.id].out === 0); });\n    var sameTypeLeafNodes = getSameTypeNodes(type, nodeClusterBy, node, relativeLeafNodes, degreesMap);\n    return { coreNode: coreNode, relativeLeafNodes: relativeLeafNodes, sameTypeLeafNodes: sameTypeLeafNodes };\n};\nexports.getCoreNodeAndRelativeLeafNodes = getCoreNodeAndRelativeLeafNodes;\n"},"sourceMaps":{"js":{"version":3,"file":"math.js","sourceRoot":"","sources":["../../src/util/math.ts"],"names":[],"mappings":"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","sourcesContent":["import { Matrix, Model, IndexMap, Edge, Node, OutNode, Degree, NodeMap } from '../layout/types';\nimport { isArray } from './array';\nimport { isNumber } from './number';\nimport { isObject } from './object';\n\nexport const getEdgeTerminal = (edge: Edge, type: 'source' | 'target') => {\n  const terminal = edge[type];\n  if (isObject(terminal)) {\n    return terminal.cell;\n  }\n  return terminal;\n};\n\nexport const getDegree = (n: number, nodeIdxMap: IndexMap, edges: Edge[] | null) => {\n  const degrees: Degree[] = [];\n  for (let i = 0; i < n; i++) {\n    degrees[i] = {\n      in: 0,\n      out: 0,\n      all: 0\n    };\n  }\n  if (!edges) return degrees;\n  edges.forEach((e) => {\n    const source = getEdgeTerminal(e, 'source');\n    const target = getEdgeTerminal(e, 'target');\n    if (source && degrees[nodeIdxMap[source]]) {\n      degrees[nodeIdxMap[source]].out += 1;\n      degrees[nodeIdxMap[source]].all += 1;\n    }\n    if (target && degrees[nodeIdxMap[target]]) {\n      degrees[nodeIdxMap[target]].in += 1;\n      degrees[nodeIdxMap[target]].all += 1;\n    }\n  });\n  return degrees;\n};\n\nexport const getDegreeMap = (nodes: Node[], edges: Edge[] | null) => {\n  const degreesMap: { [id: string]: Degree } = {};\n  nodes.forEach((node) => {\n    degreesMap[node.id] = {\n      in: 0,\n      out: 0,\n      all: 0\n    };\n  });\n\n  if (!edges) return degreesMap;\n  edges.forEach((e) => {\n    const source = getEdgeTerminal(e, 'source');\n    const target = getEdgeTerminal(e, 'target');\n    if (source) {\n      degreesMap[source].out += 1;\n      degreesMap[source].all += 1;\n    }\n    if (target) {\n      degreesMap[target].in += 1;\n      degreesMap[target].all += 1;\n    }\n  });\n  return degreesMap;\n};\n\nexport const floydWarshall = (adjMatrix: Matrix[]): Matrix[] => {\n  // initialize\n  const dist: Matrix[] = [];\n  const size = adjMatrix.length;\n  for (let i = 0; i < size; i += 1) {\n    dist[i] = [];\n    for (let j = 0; j < size; j += 1) {\n      if (i === j) {\n        dist[i][j] = 0;\n      } else if (adjMatrix[i][j] === 0 || !adjMatrix[i][j]) {\n        dist[i][j] = Infinity;\n      } else {\n        dist[i][j] = adjMatrix[i][j];\n      }\n    }\n  }\n  // floyd\n  for (let k = 0; k < size; k += 1) {\n    for (let i = 0; i < size; i += 1) {\n      for (let j = 0; j < size; j += 1) {\n        if (dist[i][j] > dist[i][k] + dist[k][j]) {\n          dist[i][j] = dist[i][k] + dist[k][j];\n        }\n      }\n    }\n  }\n  return dist;\n};\n\nexport const getAdjMatrix = (data: Model, directed: boolean): Matrix[] => {\n  const {\n    nodes,\n    edges\n  } = data;\n  const matrix: Matrix[] = [];\n  // map node with index in data.nodes\n  const nodeMap: {\n    [key: string]: number;\n  } = {};\n\n  if (!nodes) {\n    throw new Error('invalid nodes data!');\n  }\n  if (nodes) {\n    nodes.forEach((node, i) => {\n      nodeMap[node.id] = i;\n      const row: number[] = [];\n      matrix.push(row);\n    });\n  }\n\n  edges?.forEach((e) => {\n    const source = getEdgeTerminal(e, 'source');\n    const target = getEdgeTerminal(e, 'target');\n    const sIndex = nodeMap[source as string];\n    const tIndex = nodeMap[target as string];\n    if (sIndex === undefined || tIndex === undefined) return;\n    matrix[sIndex][tIndex] = 1;\n    if (!directed) {\n      matrix[tIndex][sIndex] = 1;\n    }\n  });\n  return matrix;\n};\n\n/**\n * scale matrix\n * @param matrix [ [], [], [] ]\n * @param ratio\n */\nexport const scaleMatrix = (matrix: Matrix[], ratio: number) => {\n  const result: Matrix[] = [];\n  matrix.forEach((row) => {\n    const newRow: number[] = [];\n    row.forEach((v) => {\n      newRow.push(v * ratio);\n    });\n    result.push(newRow);\n  });\n  return result;\n};\n\n/**\n * depth first traverse, from leaves to root, children in inverse order\n *  if the fn returns false, terminate the traverse\n */\nconst traverseUp = <T extends { children?: T[] }>(data: T, fn: (param: T) => boolean) => {\n  if (data && data.children) {\n    for (let i = data.children.length - 1; i >= 0; i--) {\n      if (!traverseUp(data.children[i], fn)) return;\n    }\n  }\n\n  if (!fn(data)) {\n    return false;\n  }\n  return true;\n};\n\n/**\n * depth first traverse, from leaves to root, children in inverse order\n * if the fn returns false, terminate the traverse\n */\nexport const traverseTreeUp = <T extends { children?: T[] }>(\n  data: T,\n  fn: (param: T) => boolean,\n) => {\n  if (typeof fn !== 'function') {\n    return;\n  }\n  traverseUp(data, fn);\n};\n\n/**\n * calculate the bounding box for the nodes according to their x, y, and size\n * @param nodes nodes in the layout\n * @returns \n */\nexport const getLayoutBBox = (nodes: OutNode[]) => {\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n  nodes.forEach((node) => {\n    let size = node.size;\n    if (isArray(size)) {\n      if (size.length === 1) size = [size[0], size[0]];\n    }  else if (isNumber(size)) {\n      size = [size, size];\n    } else if (size === undefined || isNaN(size as any)) {\n      size = [30, 30];\n    }\n\n    const halfSize = [size[0] / 2, size[1] / 2];\n    const left = node.x - halfSize[0];\n    const right = node.x + halfSize[0];\n    const top = node.y - halfSize[1];\n    const bottom = node.y + halfSize[1];\n\n    if (minX > left) minX = left;\n    if (minY > top) minY = top;\n    if (maxX < right) maxX = right;\n    if (maxY < bottom) maxY = bottom;\n  });\n  return { minX, minY, maxX, maxY };\n};\n\n/**\n * 获取节点集合的平均位置信息\n * @param nodes 节点集合\n * @returns 平局内置\n */\nexport const getAvgNodePosition = (nodes: OutNode[]) => {\n  const totalNodes = { x: 0, y: 0 };\n  nodes.forEach((node) => {\n    totalNodes.x += node.x || 0;\n    totalNodes.y += node.y || 0;\n  });\n  // 获取均值向量\n  const length = nodes.length || 1;\n  return {\n    x: totalNodes.x / length,\n    y: totalNodes.y / length,\n  };\n};\n\n// 找出指定节点关联的边的起点或终点\nconst getCoreNode = (type: 'source' | 'target', node: Node, edges: Edge[]) => {\n  if (type === 'source') {\n    return (edges?.find((edge) => edge.target === node.id)?.source || {}) as Node;\n  }\n  return (edges?.find((edge) => edge.source === node.id)?.target || {}) as Node;\n};\n\n// 找出指定节点为起点或终点的所有一度叶子节点\nconst getRelativeNodeIds = (type: 'source' | 'target' | 'both', coreNode: Node, edges: Edge[]) => {\n  let relativeNodes: string[] = [];\n  switch (type) {\n    case 'source':\n      relativeNodes = edges?.filter((edge) => edge.source === coreNode.id).map((edge) => edge.target);\n      break;\n    case 'target':\n      relativeNodes = edges?.filter((edge) => edge.target === coreNode.id).map((edge) => edge.source);\n      break;\n    case 'both':\n      relativeNodes = edges\n        ?.filter((edge) => edge.source === coreNode.id)\n        .map((edge) => edge.target)\n        .concat(edges?.filter((edge) => edge.target === coreNode.id).map((edge) => edge.source));\n      break;\n    default:\n      break;\n  }\n  // 去重\n  const set = new Set(relativeNodes);\n  return Array.from(set);\n};\n// 找出同类型的节点\nconst getSameTypeNodes = (type: 'leaf' | 'all', nodeClusterBy: string, node: Node, relativeNodes: Node[], degreesMap: { [id: string]: Degree }) => {\n  // @ts-ignore\n  const typeName = node[nodeClusterBy] || '';\n  // @ts-ignore\n  let sameTypeNodes = relativeNodes?.filter((item) => item[nodeClusterBy] === typeName) || [];\n  if (type === 'leaf') {\n    sameTypeNodes = sameTypeNodes.filter((node) => degreesMap[node.id]?.in === 0 ||degreesMap[node.id]?.out === 0);\n  }\n  return sameTypeNodes;\n};\n\n\n// 找出与指定节点关联的边的起点或终点出发的所有一度叶子节点\nexport const getCoreNodeAndRelativeLeafNodes = (type: 'leaf' | 'all', node: Node, edges: Edge[], nodeClusterBy: string, degreesMap: { [id: string]: Degree }, nodeMap: NodeMap) => {\n  const { in: inDegree, out: outDegree } = degreesMap[node.id];\n  let coreNode: Node = node;\n  let relativeLeafNodes: Node[] = [];\n  if (inDegree === 0) {\n    // 如果为没有出边的叶子节点，则找出与它关联的边的起点出发的所有一度节点\n    coreNode = getCoreNode('source', node, edges);\n    relativeLeafNodes = getRelativeNodeIds('both', coreNode, edges).map((nodeId) => nodeMap[nodeId]);\n  } else if (outDegree === 0) {\n    // 如果为没有入边边的叶子节点，则找出与它关联的边的起点出发的所有一度节点\n    coreNode = getCoreNode('target', node, edges);\n    relativeLeafNodes = getRelativeNodeIds('both', coreNode, edges).map((nodeId) => nodeMap[nodeId]);\n  }\n  relativeLeafNodes = relativeLeafNodes.filter(\n    (node) => degreesMap[node.id] && (degreesMap[node.id].in === 0 || degreesMap[node.id].out === 0),\n  );\n  const sameTypeLeafNodes = getSameTypeNodes(type, nodeClusterBy, node, relativeLeafNodes, degreesMap);\n  return { coreNode, relativeLeafNodes, sameTypeLeafNodes };\n};"]}},"error":null,"hash":"27d1e2bdd35fb9fb0c51e0cff49b06d3","cacheData":{"env":{}}}