{"id":"node_modules/@antv/layout/lib/layout/dagre/src/order/cross-count.js","dependencies":[{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\order\\cross-count.js.map","includedInParent":true,"mtime":1676178923588},{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\src\\layout\\dagre\\src\\order\\cross-count.ts","includedInParent":true,"mtime":1676178923846},{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\package.json","includedInParent":true,"mtime":1676178924413},{"name":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\package.json","includedInParent":true,"mtime":1676178923486},{"name":"../util","loc":{"line":19,"column":21,"index":610},"parent":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\order\\cross-count.js","resolved":"D:\\myData\\前端\\doing\\graph-visualization-interaction\\node_modules\\@antv\\layout\\lib\\layout\\dagre\\src\\util.js"}],"generated":{"js":"\"use strict\";\n/*\n * A function that takes a layering (an array of layers, each with an array of\n * ordererd nodes) and a graph and returns a weighted crossing count.\n *\n * Pre-conditions:\n *\n *    1. Input graph must be simple (not a multigraph), directed, and include\n *       only simple edges.\n *    2. Edges in the input graph must have assigned weights.\n *\n * Post-conditions:\n *\n *    1. The graph and layering matrix are left unchanged.\n *\n * This algorithm is derived from Barth, et al., \"Bilayer Cross Counting.\"\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"../util\");\nvar twoLayerCrossCount = function (g, northLayer, southLayer) {\n    // Sort all of the edges between the north and south layers by their position\n    // in the north layer and then the south. Map these edges to the position of\n    // their head in the south layer.\n    var southPos = (0, util_1.zipObject)(southLayer, southLayer.map(function (v, i) { return i; }));\n    var unflat = northLayer.map(function (v) {\n        var _a;\n        var unsort = (_a = g.outEdges(v)) === null || _a === void 0 ? void 0 : _a.map(function (e) {\n            return { pos: southPos[e.w] || 0, weight: g.edge(e).weight };\n        });\n        return unsort === null || unsort === void 0 ? void 0 : unsort.sort(function (a, b) { return a.pos - b.pos; });\n    });\n    var southEntries = unflat.flat().filter(function (entry) { return entry !== undefined; });\n    // Build the accumulator tree\n    var firstIndex = 1;\n    while (firstIndex < southLayer.length)\n        firstIndex <<= 1;\n    var treeSize = 2 * firstIndex - 1;\n    firstIndex -= 1;\n    var tree = Array(treeSize).fill(0, 0, treeSize);\n    // Calculate the weighted crossings\n    var cc = 0;\n    southEntries === null || southEntries === void 0 ? void 0 : southEntries.forEach(function (entry) {\n        if (entry) {\n            var index = entry.pos + firstIndex;\n            tree[index] += entry.weight;\n            var weightSum = 0;\n            while (index > 0) {\n                if (index % 2) {\n                    weightSum += tree[index + 1];\n                }\n                index = (index - 1) >> 1;\n                tree[index] += entry.weight;\n            }\n            cc += entry.weight * weightSum;\n        }\n    });\n    return cc;\n};\nvar crossCount = function (g, layering) {\n    var cc = 0;\n    for (var i = 1; i < (layering === null || layering === void 0 ? void 0 : layering.length); i += 1) {\n        cc += twoLayerCrossCount(g, layering[i - 1], layering[i]);\n    }\n    return cc;\n};\nexports.default = crossCount;\n"},"sourceMaps":{"js":{"version":3,"file":"cross-count.js","sourceRoot":"","sources":["../../../../../src/layout/dagre/src/order/cross-count.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * A function that takes a layering (an array of layers, each with an array of\n * ordererd nodes) and a graph and returns a weighted crossing count.\n *\n * Pre-conditions:\n *\n *    1. Input graph must be simple (not a multigraph), directed, and include\n *       only simple edges.\n *    2. Edges in the input graph must have assigned weights.\n *\n * Post-conditions:\n *\n *    1. The graph and layering matrix are left unchanged.\n *\n * This algorithm is derived from Barth, et al., \"Bilayer Cross Counting.\"\n */\n\nimport { Graph } from \"../../graph\";\nimport { zipObject } from \"../util\";\n\nconst twoLayerCrossCount = (\n  g: Graph,\n  northLayer: string[],\n  southLayer: string[]\n) => {\n  // Sort all of the edges between the north and south layers by their position\n  // in the north layer and then the south. Map these edges to the position of\n  // their head in the south layer.\n  const southPos = zipObject(\n    southLayer,\n    southLayer.map((v, i) => i)\n  );\n  const unflat = northLayer.map((v) => {\n    const unsort = g.outEdges(v)?.map((e) => {\n      return { pos: southPos[e.w] || 0, weight: g.edge(e)!.weight };\n    });\n    return unsort?.sort((a, b) => a.pos - b.pos);\n  });\n  const southEntries = unflat.flat().filter((entry) => entry !== undefined);\n\n  // Build the accumulator tree\n  let firstIndex = 1;\n  while (firstIndex < southLayer.length) firstIndex <<= 1;\n  const treeSize = 2 * firstIndex - 1;\n  firstIndex -= 1;\n  const tree = Array(treeSize).fill(0, 0, treeSize);\n\n  // Calculate the weighted crossings\n  let cc = 0;\n  southEntries?.forEach((entry) => {\n    if (entry) {\n      let index = entry.pos + firstIndex;\n      tree[index] += entry.weight;\n      let weightSum = 0;\n      while (index > 0) {\n        if (index % 2) {\n          weightSum += tree[index + 1];\n        }\n        index = (index - 1) >> 1;\n        tree[index] += entry.weight;\n      }\n      cc += entry.weight! * weightSum;\n    }\n  });\n\n  return cc;\n};\n\nconst crossCount = (g: Graph, layering: string[][]) => {\n  let cc = 0;\n  for (let i = 1; i < layering?.length; i += 1) {\n    cc += twoLayerCrossCount(g, layering[i - 1], layering[i]);\n  }\n  return cc;\n};\n\nexport default crossCount;\n"]}},"error":null,"hash":"9b4727bec5c253036c38f73203866bff","cacheData":{"env":{}}}